<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵荆州的个人博客</title>
  
  <subtitle>赵荆州的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingzhouzhao.github.io/"/>
  <updated>2021-09-27T09:23:39.240Z</updated>
  <id>https://jingzhouzhao.github.io/</id>
  
  <author>
    <name>赵荆州</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis Mapper 源码分析</title>
    <link href="https://jingzhouzhao.github.io/archives/fb5cf917.html"/>
    <id>https://jingzhouzhao.github.io/archives/fb5cf917.html</id>
    <published>2021-09-22T06:26:02.000Z</published>
    <updated>2021-09-27T09:23:39.240Z</updated>
    
    <content type="html"><![CDATA[<p>天天都在用的Mybatis，为啥调用一个Mapper接口就能执行SQL，你有没有想过这个问题？</p><p>这一切都得从 <code>@MapperScan</code> 这个注解开始说起。打开这个注解定义可以看到：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;MapperScannerRegistrar.class&#125;)</span><br></pre></td></tr></table></figure><p>上面的元注解中重点关注<code>@Import(MapperScannerRegistrar.class)</code>，这是Spring的一个注解，允许导入@Configuration类、 ImportSelector和ImportBeanDefinitionRegistrar实现。很明显<code>MapperScannerRegistrar.class</code> 应该是<code>ImportBeanDefinitionRegistrar</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">"value"</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">"basePackages"</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>)) &#123;</span><br><span class="line">      basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面代码在做一件事，就是初始化<code>ClassPathMapperScanner</code>，最后调用了<code>doScan</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(<span class="string">"No MyBatis mapper was found in '"</span> + Arrays.toString(basePackages) + <span class="string">"' package. Please check your configuration."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先调用了父类的doScan，里面的主要逻辑是查找指定的basePackages下的所有Components，即声明了<code>@Component</code>以及将<code>@Component</code>作为元注解的注解，例如<code>@Repository</code>，<br>感兴趣的可以看看：</p><ul><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents</li><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(org.springframework.core.type.classreading.MetadataReader)</li><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters</li><li>org.springframework.core.type.filter.AnnotationTypeFilter#hasAnnotation</li><li>org.springframework.core.annotation.AnnotationUtils#getAnnotation(java.lang.reflect.AnnotatedElement, java.lang.Class<A>)</A></li></ul><p>接下来调用了<code>processBeanDefinitions</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName() </span><br><span class="line">          + <span class="string">"' and '"</span> + definition.getBeanClassName() + <span class="string">"' mapperInterface"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点看看这两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); </span><br><span class="line">definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br></pre></td></tr></table></figure><p>似乎已经可以看出点蛛丝马迹，这里将Mapper的BeanDefinition的BeanClass替换为了<code>this.mapperFactoryBean.getClass()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MapperFactoryBean&lt;?&gt; mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p>并且将原本的BeanClass添加为了构造函数参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br></pre></td></tr></table></figure><p>熟悉Spring的应该都知道，Spring加载完BeanDefinition后会通过BeanClass来去实例化Bean，这里的BeanClass被替换为了一个FactoryBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addToConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intentionally empty </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">    notNull(<span class="keyword">this</span>.mapperInterface, <span class="string">"Property 'mapperInterface' is required"</span>);</span><br><span class="line"></span><br><span class="line">    Configuration configuration = getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        configuration.addMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error while adding the mapper '"</span> + <span class="keyword">this</span>.mapperInterface + <span class="string">"' to configuration."</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------- mutators --------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the mapper interface of the MyBatis mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperInterface class of the interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperInterface</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the mapper interface of the MyBatis mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> class of the interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If addToConfig is false the mapper will not be added to MyBatis. This means</span></span><br><span class="line"><span class="comment">   * it must have been included in mybatis-config.xml.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * If it is true, the mapper will be added to MyBatis in the case it is not already</span></span><br><span class="line"><span class="comment">   * registered.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * By default addToCofig is true.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> addToConfig</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddToConfig</span><span class="params">(<span class="keyword">boolean</span> addToConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addToConfig = addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the flag for addition into MyBatis config.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true if the mapper will be added to MyBatis in the case it is not already</span></span><br><span class="line"><span class="comment">   * registered.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddToConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到之前那个被注册的构造函数参数应该就是在这被使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 关于这个Bean构造函数的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireConstructor</span><br><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，Spring通过构造函数创建了一个 MapperFactoryBean 对象。接下来Spring去初始化这个Bean，Spring对FactoryBean有特殊处理，实际会调用getObject方法返回具体的Bean。<br>感兴趣的可以看：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</span><br></pre></td></tr></table></figure><p>这下又回到了MapperFactoryBean中，来看看getObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用了父类getSqlSession()方法获得SqlSession，然后调用getMapper，传入了当前实际的Mapper。通过：</p><ul><li>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration)</li><li>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</li></ul><p>可以知道SqlSession实际的类型应该是<code>DefaultSqlSession</code>，看看getMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又调用了<code>configuration</code>的getMapper，configuration初始化可以看看<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>，<br>我们写的SQL就是在这个里面被解析的。到这里已经基本很清晰了。接着看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//configuration中的getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MapperRegistry中的getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是 <code>MapperProxyFactory</code>了，这个是在 <code>org.apache.ibatis.binding.MapperRegistry#addMapper</code>  时会为每个Mapper绑定一个。<br>看newInstance：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就是说最终Mapper注册到BeanFactory中的是一个代理类<code>MapperProxy</code>，我们知道被代理的方法最终都会被转发到代理类的<code>invoke</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">       <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">       <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">   <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果不是Object类的方法，也不是Mapper接口的default（默认）方法，那么调用的是<code>mapperMethod.execute(sqlSession, args)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到这就差不多了吧？后面已经没啥好说了，基本就是通过statement name找到MappedStatement然后去执行sql了。</p><p>另外一个小知识，Mybatis是怎么在插入之后返回自增主键的？答案就在：</p><ul><li>org.apache.ibatis.executor.statement.PreparedStatementHandler#update</li><li>org.apache.ibatis.executor.keygen.KeyGenerator#processAfter</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>Spring代码实在太难看了，一环套一环，各种递归，必须debug才能看清。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天天都在用的Mybatis，为啥调用一个Mapper接口就能执行SQL，你有没有想过这个问题？&lt;/p&gt;
&lt;p&gt;这一切都得从 &lt;code&gt;@MapperScan&lt;/code&gt; 这个注解开始说起。打开这个注解定义可以看到：&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>被Chrome一个bug坑了</title>
    <link href="https://jingzhouzhao.github.io/archives/6e43fa1b.html"/>
    <id>https://jingzhouzhao.github.io/archives/6e43fa1b.html</id>
    <published>2021-09-03T08:58:50.000Z</published>
    <updated>2021-09-27T09:24:40.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://files.catbox.moe/xbwdlv.png" alt></p><p>相信Chrome浏览器开发者工具中的Preview你不陌生，但是就这玩意有一个bug。</p><p>事情是这样的，前端跟我说你接口有bug，返回的数据不正确。听到bug，我反手就是一个你会不会用。</p><a id="more"></a><p>他发来了一个截图：</p><p><img src="https://files.catbox.moe/b7x3tw.png" alt></p><p>我给他返回的json中有一个<code>max</code>字段，值是<code>100000000000000</code> ,正确的应该是<code>99999999999999.99999999999999999999</code>,你先别管为什么是这么个值。</p><p>好了，他拿出证据了，我开始怀疑真的是哪里写的有问题了，一顿查找，发现TMD哪里都没有问题啊，怎么可能，怎么会呢？</p><p>中午的饭都不香了。</p><p>我开始怀疑是网关的问题，网关大佬说没问题。。。。。</p><p>于是拿着请求地址，curl了一下，<code>max:99999999999999.99999999999999999999</code>。卧槽。。。又对了？</p><p>于是我开始怀疑最不可能出问题的浏览器，直到我点开了<code>Response</code> :</p><p><img src="https://files.catbox.moe/kygqzl.png" alt></p><p>。。。。。。</p><p>反手就是给提了一个bug：</p><p><img src="https://files.catbox.moe/l53ij6.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://files.catbox.moe/xbwdlv.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;相信Chrome浏览器开发者工具中的Preview你不陌生，但是就这玩意有一个bug。&lt;/p&gt;
&lt;p&gt;事情是这样的，前端跟我说你接口有bug，返回的数据不正确。听到bug，我反手就是一个你会不会用。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="Chrome" scheme="https://jingzhouzhao.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Lambda应用与浅析</title>
    <link href="https://jingzhouzhao.github.io/archives/d53a1750.html"/>
    <id>https://jingzhouzhao.github.io/archives/d53a1750.html</id>
    <published>2021-08-02T12:47:02.000Z</published>
    <updated>2021-09-27T09:26:09.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在Java8之前创建一个线程的写法（之一）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello inner class!&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>通过查看编译后的生成的Class文件，可以得知new Runnable这块会生成一个匿名类：</p><p><img src="https://files.catbox.moe/e1vlbc.png" alt></p><p>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final class LambdaTest$1 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    LambdaTest$1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;hello inner class!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java8开始一切都开始变得不同，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello inner class!&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>()-&gt;System.out.println(&quot;hello inner class!&quot;)</code>就是今天的主角<strong><em>lambda表达式</em></strong>!</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Lambda表达式，是一种匿名函数，一开始只有函数式编程语言中有此功能，但是现在已经有越来越多的命令式编程语言中也支持了Lambda表达式。</p><blockquote><p>Lambda表达式不是一个新鲜事，最早支持Lambda表达式的是1958发布的LISP语言。在Java中也存在了快7-8年时间（2014年发布的Java8开始支持），目前Java已经都发布16。</p></blockquote><p>Lambda表达式简化匿名内部类的书写，但Lambda表达式并不能取代所有的匿名内部类，只能用来取代<strong>函数接口（Functional Interface）</strong>的简写。</p><p>说到函数接口，那么来看下什么是函数接口，看看最开始的例子里出现的<strong><em>Runnable</em></strong>  ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看另外一个<strong>Comparable</strong> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public int compareTo(T o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现了什么？只有一个[抽象]方法的接口即是函数接口。</p><p><code>@FunctionalInterface</code> 并不是必须的，加上此注解可以让编译器帮你check当前定义的是不是正确的函数接口：</p><p><img src="https://files.catbox.moe/tvelqu.png" alt></p><p>Java8 引入Lambda表达式的同时也定义了很多新的函数接口，适用于大部分场景：</p><p><img src="https://files.catbox.moe/qptsmq.png" alt></p><p>也就是说Java8中的Lambda表达式不可以随意乱写，必须有与其对应的函数接口定义，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a, b) -&gt; a + b;</span><br></pre></td></tr></table></figure><p>如果在JDK中找不到对应的函数接口，我们可以自定义一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface TwoParamsOneResultFunction &#123;</span><br><span class="line"></span><br><span class="line">    Integer get(Integer p1, Integer p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>下面来通过一个实例看看Lambda表达式的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private static boolean sync2Es(List&lt;Long&gt; result, EsIndexEnum esIndexEnum, boolean isAsync) &#123;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;同步&#123;&#125;至ES，idList:&#123;&#125;,isAsync:&#123;&#125;&quot;, JSON.toJSONString(esIndexEnum), JSON.toJSONString(result), isAsync);</span><br><span class="line"></span><br><span class="line">    if (esIndexEnum &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CollectionUtils.isEmpty(result)) &#123;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;es最多支持一次同步3000条，所以需要拆分</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Long&gt;&gt; partition &#x3D; Lists.partition(StreamUtils.safeList(result), AssetsConstant.MAX_BATCH_SYNC_SIZE);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;es支持同步和异步，按需选择</span><br><span class="line"></span><br><span class="line">    EsSyncProcessorInstance instance &#x3D; EsSyncProcessorFactory.getInstance(esIndexEnum.getIndexClass());</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; esFunction &#x3D; getEsSyncFunction(isAsync);</span><br><span class="line"></span><br><span class="line">    boolean esResult &#x3D; StreamUtils.allMatch(StreamUtils.listToList(partition, ids -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        EsResult&lt;BulkMessage&gt; bulkMessageEsResult &#x3D; esFunction.apply(instance, ids);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;es可能失败，重试一次，如果还是不行那估计就是大问题了。</span><br><span class="line"></span><br><span class="line">        if (!bulkMessageEsResult.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(&quot;同步ES失败:&#123;&#125;,重试一次&quot;, JSON.toJSONString(bulkMessageEsResult));</span><br><span class="line"></span><br><span class="line">            bulkMessageEsResult &#x3D; esFunction.apply(instance, StreamUtils.listToList(StreamUtils.safeGetField(bulkMessageEsResult.getValue(), BulkMessage::getFailIds), Long::valueOf));</span><br><span class="line"></span><br><span class="line">            if (!bulkMessageEsResult.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                log.error(&quot;同步ES重试再次失败:&#123;&#125;&quot;, JSON.toJSONString(bulkMessageEsResult));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return bulkMessageEsResult.isSuccess();</span><br><span class="line"></span><br><span class="line">    &#125;), Boolean::booleanValue);</span><br><span class="line"></span><br><span class="line">    if (!esResult) &#123;</span><br><span class="line"></span><br><span class="line">        log.error(&quot;同步到ES存在失败:&#123;&#125;&quot;, JSON.toJSONString(result));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return esResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段代码主要是在做同步数据给ES的逻辑，由于ES提供了多种同步方式，不想将细节暴露给上层，所以做了一些封装。</p><p>先看看这一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; esFunction &#x3D; getEsSyncFunction(isAsync);</span><br></pre></td></tr></table></figure><p>调用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; getEsSyncFunction(boolean isAsync) &#123;</span><br><span class="line"></span><br><span class="line">    return isAsync ? EsSyncProcessorInstance::syncByPrimaryKey : EsSyncProcessorInstance::syncByPrimaryKeyImmediate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中可以看到类似<code>EsSyncProcessorInstance::syncByPrimaryKey</code>这种写法，这个叫方法引用，可以理解为是一种特殊的lambda表达式（语法糖），相当于给一段函数取了一个名字，然后直接引用，看看syncByPrimaryKey：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public EsResult&lt;BulkMessage&gt; syncByPrimaryKey(List&lt;Long&gt; indexPrimaryKeyList) &#123;</span><br><span class="line"></span><br><span class="line">    String method &#x3D; &quot;EsSyncProcessorInstance#syncByPrimaryKey&quot;;</span><br><span class="line"></span><br><span class="line">    if (indexPrimaryKeyList !&#x3D; null &amp;&amp; indexPrimaryKeyList.size() &gt; 3000) &#123;</span><br><span class="line"></span><br><span class="line">        log.warn(&quot;&#123;&#125; allowable size exceeded, size&#x3D;&#123;&#125;, max&#x3D;&#123;&#125;&quot;, new Object[]&#123;method, indexPrimaryKeyList.size(), 3000&#125;);</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        EsSyncLoopQuery query &#x3D; this.newInstanceQuery();</span><br><span class="line"></span><br><span class="line">        query.setIdList(indexPrimaryKeyList);</span><br><span class="line"></span><br><span class="line">        return this.synchronizeToEs(query, this.defaultConfig());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个List<Long> 参数，一个EsResult<BulkMessage>返回值，那为什么适配的函数接口是BiFunction？看看BiFunction：</BulkMessage></Long></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface BiFunction&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里需要两个参数</span><br><span class="line"></span><br><span class="line">    R apply(T t, U u);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于syncByPrimaryKey是一个实例方法，所以还需要一个<strong>实例对象</strong>才能调用，所以<code>EsSyncProcessorInstance::syncByPrimaryKey</code> 相当于(<code>EsSyncProcessorInstance instance,List&lt;Long&gt; ids)-&gt;{...}</code></p><p>再一次验证，lambda表达式不能随意乱写，必须有对应的函数接口对应。</p><p>接下来再来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StreamUtils.listToList(partition, ids -&gt; &#123;</span><br></pre></td></tr></table></figure><p>这是对Java8 Stream+Lambda的一层封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, R&gt; List&lt;R&gt; listToList(List&lt;T&gt; list, Function&lt;T, R&gt; function) &#123;</span><br><span class="line"></span><br><span class="line">        return safeList(list).stream().map(function).filter(Objects::nonNull).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到stream().map需要一个function用来转换数据，而其他的基本都是固定写法，这体现了Lambda的另外一个好处：抽象行为。</p><p><img src="https://files.catbox.moe/akijpg.png" alt></p><p>还有很多用法不一一介绍了。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这么🐂🍺的Lambda表达式Java底层是怎么实现的呢？首先可以确定的是，不是匿名内部类，还是最开始的例子，我们改成lambda表达式后编译看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello lambda&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/ular40.png" alt></p><p>可以看到并没有匿名内部类生成，我们查看下LambdaTest.class字节码(<em>javap -c -p -v LambdaTest.class</em>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;Users&#x2F;zhaojingzhou&#x2F;workspace&#x2F;larry&#x2F;lambda&#x2F;src&#x2F;LambdaTest.class</span><br><span class="line"></span><br><span class="line">  Last modified 2021-8-2; size 1047 bytes</span><br><span class="line"></span><br><span class="line">  MD5 checksum 191cb67c3e5a457eb20b4c8a47f5a5d2</span><br><span class="line"></span><br><span class="line">  Compiled from &quot;LambdaTest.java&quot;</span><br><span class="line"></span><br><span class="line">public class LambdaTest</span><br><span class="line"></span><br><span class="line">  minor version: 0</span><br><span class="line"></span><br><span class="line">  major version: 52</span><br><span class="line"></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line"></span><br><span class="line">   #1 &#x3D; Methodref          #9.#19         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">   #2 &#x3D; Class              #20            &#x2F;&#x2F; java&#x2F;lang&#x2F;Thread</span><br><span class="line"></span><br><span class="line">   #3 &#x3D; InvokeDynamic      #0:#25         &#x2F;&#x2F; #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">   #4 &#x3D; Methodref          #2.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;Thread.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">   #5 &#x3D; Fieldref           #27.#28        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">   #6 &#x3D; String             #29            &#x2F;&#x2F; hello inner class!</span><br><span class="line"></span><br><span class="line">   #7 &#x3D; Methodref          #30.#31        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">   #8 &#x3D; Class              #32            &#x2F;&#x2F; LambdaTest</span><br><span class="line"></span><br><span class="line">   #9 &#x3D; Class              #33            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line"></span><br><span class="line">  #10 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line"></span><br><span class="line">  #11 &#x3D; Utf8               ()V</span><br><span class="line"></span><br><span class="line">  #12 &#x3D; Utf8               Code</span><br><span class="line"></span><br><span class="line">  #13 &#x3D; Utf8               LineNumberTable</span><br><span class="line"></span><br><span class="line">  #14 &#x3D; Utf8               main</span><br><span class="line"></span><br><span class="line">  #15 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">  #16 &#x3D; Utf8               lambda$main$0</span><br><span class="line"></span><br><span class="line">  #17 &#x3D; Utf8               SourceFile</span><br><span class="line"></span><br><span class="line">  #18 &#x3D; Utf8               LambdaTest.java</span><br><span class="line"></span><br><span class="line">  #19 &#x3D; NameAndType        #10:#11        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">  #20 &#x3D; Utf8               java&#x2F;lang&#x2F;Thread</span><br><span class="line"></span><br><span class="line">  #21 &#x3D; Utf8               BootstrapMethods</span><br><span class="line"></span><br><span class="line">  #22 &#x3D; MethodHandle       #6:#34         &#x2F;&#x2F; invokestatic java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #23 &#x3D; MethodType         #11            &#x2F;&#x2F;  ()V</span><br><span class="line"></span><br><span class="line">  #24 &#x3D; MethodHandle       #6:#35         &#x2F;&#x2F; invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #25 &#x3D; NameAndType        #36:#37        &#x2F;&#x2F; run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">  #26 &#x3D; NameAndType        #10:#38        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">  #27 &#x3D; Class              #39            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line"></span><br><span class="line">  #28 &#x3D; NameAndType        #40:#41        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">  #29 &#x3D; Utf8               hello inner class!</span><br><span class="line"></span><br><span class="line">  #30 &#x3D; Class              #42            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line"></span><br><span class="line">  #31 &#x3D; NameAndType        #43:#44        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">  #32 &#x3D; Utf8               LambdaTest</span><br><span class="line"></span><br><span class="line">  #33 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line"></span><br><span class="line">  #34 &#x3D; Methodref          #45.#46        &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #35 &#x3D; Methodref          #8.#47         &#x2F;&#x2F; LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #36 &#x3D; Utf8               run</span><br><span class="line"></span><br><span class="line">  #37 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">  #38 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">  #39 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line"></span><br><span class="line">  #40 &#x3D; Utf8               out</span><br><span class="line"></span><br><span class="line">  #41 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">  #42 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line"></span><br><span class="line">  #43 &#x3D; Utf8               println</span><br><span class="line"></span><br><span class="line">  #44 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">  #45 &#x3D; Class              #48            &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory</span><br><span class="line"></span><br><span class="line">  #46 &#x3D; NameAndType        #49:#53        &#x2F;&#x2F; metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #47 &#x3D; NameAndType        #16:#11        &#x2F;&#x2F; lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #48 &#x3D; Utf8               java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory</span><br><span class="line"></span><br><span class="line">  #49 &#x3D; Utf8               metafactory</span><br><span class="line"></span><br><span class="line">  #50 &#x3D; Class              #55            &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup</span><br><span class="line"></span><br><span class="line">  #51 &#x3D; Utf8               Lookup</span><br><span class="line"></span><br><span class="line">  #52 &#x3D; Utf8               InnerClasses</span><br><span class="line"></span><br><span class="line">  #53 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #54 &#x3D; Class              #56            &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles</span><br><span class="line"></span><br><span class="line">  #55 &#x3D; Utf8               java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup</span><br><span class="line"></span><br><span class="line">  #56 &#x3D; Utf8               java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  public LambdaTest();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line"></span><br><span class="line">         0: aload_0</span><br><span class="line"></span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">         4: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 9: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line"></span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line"></span><br><span class="line">         0: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Thread</span><br><span class="line"></span><br><span class="line">         3: dup</span><br><span class="line"></span><br><span class="line">         4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">         9: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">        12: pop</span><br><span class="line"></span><br><span class="line">        13: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br><span class="line"></span><br><span class="line">        line 19: 13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;2, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line"></span><br><span class="line">         0: getstatic     #5                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">         3: ldc           #6                  &#x2F;&#x2F; String hello inner class!</span><br><span class="line"></span><br><span class="line">         5: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;LambdaTest.java&quot;</span><br><span class="line"></span><br><span class="line">InnerClasses:</span><br><span class="line"></span><br><span class="line">     public static final #51&#x3D; #50 of #54; &#x2F;&#x2F;Lookup&#x3D;class java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup of class java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles</span><br><span class="line"></span><br><span class="line">BootstrapMethods:</span><br><span class="line"></span><br><span class="line">  0: #22 invokestatic java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">    Method arguments:</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br><span class="line"></span><br><span class="line">      #24 invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br></pre></td></tr></table></figure><p>很多信息我们关注一下重点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br></pre></td></tr></table></figure><p>第85行可以看到原lambda表达式被编译成了<code>invokedynamic</code> 字节码，这个是Java中多个调用字节码之一，其它的分别是<code>invokestatic</code>、<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokeinterface</code>。也是Java1.0以后第一个被新增的调用字节码。</p><p>接下来看#3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#3 &#x3D; InvokeDynamic      #0:#25         &#x2F;&#x2F; #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br></pre></td></tr></table></figure><p>#0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line"></span><br><span class="line">  0: #22 invokestatic java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">    Method arguments:</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br><span class="line"></span><br><span class="line">      #24 invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br></pre></td></tr></table></figure><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21" target="_blank" rel="noopener">JVM规范</a>规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定<strong>有且仅有一个</strong>BootstrapMethods属性。BootstrapMethods属性是个变长的表。</p><p>其中根据相关信息会创建一个DynamicCallSite动态调用点，可以看到最终调用的方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line">  private static void lambda$main$0();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;2, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line"></span><br><span class="line">         0: getstatic     #5                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">         3: ldc           #6                  &#x2F;&#x2F; String hello inner class!</span><br><span class="line"></span><br><span class="line">         5: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br></pre></td></tr></table></figure><p>也就是说Java虽然不会对Lambda表达式生成匿名类，但是会生成匿名静态方法。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://segmentfault.com/a/1190000020607546" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020607546</a></p><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p><p><a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method" target="_blank" rel="noopener">https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;在Java8之前创建一个线程的写法（之一）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LambdaTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new Thread(new Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&amp;quot;hello inner class!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty中FastThreadLocal源码解析</title>
    <link href="https://jingzhouzhao.github.io/archives/4b47846d.html"/>
    <id>https://jingzhouzhao.github.io/archives/4b47846d.html</id>
    <published>2021-05-08T02:25:25.000Z</published>
    <updated>2021-09-27T09:23:45.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ThreadLocal</code>一个特殊变体，当从<code>FastThreadLocalThread</code>访问时，可获得更高的访问性能。<br>在内部， <code>FastThreadLocal</code>在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。<br>要利用此线程局部变量，您的线程必须是<code>FastThreadLocalThread</code>或其子类型。 由于这个原因，默认情况下， <code>DefaultThreadFactory</code>创建的所有线程均为<code>FastThreadLocalThread</code> 。<br>请注意，只有在扩展<code>FastThreadLocalThread</code>线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规<code>ThreadLocal</code> 。</p><p>上面这段描述来自<code>FastThreadLocal</code>源码中的文档，从中可以知道<code>FastThreadLocal</code>必须和<code>FastThreadLocalThread</code>或其子类型一起使用才可以达到Fast的效果。</p><a id="more"></a><h2 id="FastThreadLocalThread"><a href="#FastThreadLocalThread" class="headerlink" title="FastThreadLocalThread"></a>FastThreadLocalThread</h2><p>既然必须要和<code>FastThreadLocalThread</code>    一起使用，那就来看看<code>FastThreadLocalThread</code>到底有什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A special &#123;<span class="doctag">@link</span> Thread&#125; that provides fast access to &#123;<span class="doctag">@link</span> FastThreadLocal&#125; variables.</span></span><br><span class="line"><span class="comment"> * 一种特殊的&#123;<span class="doctag">@link</span> Thread&#125;，可以快速访问&#123;<span class="doctag">@link</span> FastThreadLocal&#125;变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// This will be set to true if we have a chance to wrap the Runnable.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> cleanupFastThreadLocals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(FastThreadLocalRunnable.wrap(target));</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>省略了一部分代码，可以看到<code>FastThreadLocalThread</code>继承自<code>Thread</code>，额外多了一个<code>InternalThreadLocalMap threadLocalMap</code>，从doc中可以看出这个变量就是关键。</p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal data structure that stores the thread-local variables for Netty and all &#123;<span class="doctag">@link</span> FastThreadLocal&#125;s.</span></span><br><span class="line"><span class="comment"> * Note that this class is for internal use only and is subject to change at any time.  Use &#123;<span class="doctag">@link</span> FastThreadLocal&#125;</span></span><br><span class="line"><span class="comment"> * unless you know what you are doing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></span><br><span class="line">    Object[] indexedVariables;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> slowGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">        InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">            slowThreadLocalMap.set(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextIndex.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"too many thread-local indexed variables"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if a new thread-local variable has been created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        Object[] lookup = indexedVariables;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">            Object oldValue = lookup[index];</span><br><span class="line">            lookup[index] = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>InternalThreadLocalMap</code>继承自<code>UnpaddedInternalThreadLocalMap</code>，为了好看一点我把父类中的相关代码放到了一起，dubbo借鉴netty代码也是这么干的。</p><h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>最后看看<code>FastThreadLocal</code>是怎么把这几个核心类给串起来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> variablesToRemoveIndex = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value for the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">        <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = initialValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the initial value for this thread-local variable.</span></span><br><span class="line"><span class="comment">     * 这个方法一般会把覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/nxk8yt.png" alt></p><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p><a href="https://github.com/apache/dubbo/pull/1745" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/1745</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;一个特殊变体，当从&lt;code&gt;FastThreadLocalThread&lt;/code&gt;访问时，可获得更高的访问性能。&lt;br&gt;在内部， &lt;code&gt;FastThreadLocal&lt;/code&gt;在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。&lt;br&gt;要利用此线程局部变量，您的线程必须是&lt;code&gt;FastThreadLocalThread&lt;/code&gt;或其子类型。 由于这个原因，默认情况下， &lt;code&gt;DefaultThreadFactory&lt;/code&gt;创建的所有线程均为&lt;code&gt;FastThreadLocalThread&lt;/code&gt; 。&lt;br&gt;请注意，只有在扩展&lt;code&gt;FastThreadLocalThread&lt;/code&gt;线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规&lt;code&gt;ThreadLocal&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;上面这段描述来自&lt;code&gt;FastThreadLocal&lt;/code&gt;源码中的文档，从中可以知道&lt;code&gt;FastThreadLocal&lt;/code&gt;必须和&lt;code&gt;FastThreadLocalThread&lt;/code&gt;或其子类型一起使用才可以达到Fast的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis批量更新的一个小问题</title>
    <link href="https://jingzhouzhao.github.io/archives/e8013d2a.html"/>
    <id>https://jingzhouzhao.github.io/archives/e8013d2a.html</id>
    <published>2021-03-25T09:20:15.000Z</published>
    <updated>2021-09-27T09:24:08.112Z</updated>
    
    <content type="html"><![CDATA[<p>批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateBatch&quot; parameterType&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;item&quot; separator&#x3D;&quot;;&quot; index&#x3D;&quot;index&quot;&gt;</span><br><span class="line">      update test</span><br><span class="line">      &lt;set&gt;</span><br><span class="line">        status &#x3D; #&#123;item.status,jdbcType&#x3D;BIGINT&#125;,</span><br><span class="line">        amount &#x3D; #&#123;item.amount,jdbcType&#x3D;BIGINT&#125;,</span><br><span class="line">        version &#x3D; version+1,</span><br><span class="line">        gmt_modified &#x3D; now(),</span><br><span class="line">      &lt;&#x2F;set&gt;</span><br><span class="line">      &lt;where&gt;</span><br><span class="line">        id &#x3D; #&#123;item.id&#125;</span><br><span class="line">      &lt;&#x2F;where&gt;</span><br><span class="line">    &lt;&#x2F;foreach&gt;</span><br><span class="line">  &lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p>非常简单的update SQL，通过Mybatis foreach 生成多个update SQL同时执行，但是运行时一直报：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;update test</span><br><span class="line">       SET amount &#x3D; -116534270,</span><br><span class="line">        version&#39; at line 10</span><br><span class="line">; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;update test</span><br><span class="line">       SET amount &#x3D; -116534270,</span><br><span class="line">        version&#39; at line 10</span><br></pre></td></tr></table></figure><p>看到这个错误下意识的认为肯定是sql哪里写的不对有语法错误，可是检查了半天没发现问题，而且将报错的sql 通过navicat运行也可以通过。</p><p>后来查到如果批量执行语句需要将database connection url中加上如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowMultiQueries&#x3D;true</span><br></pre></td></tr></table></figure><p>完整的url例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;x.x.x.x:3306&#x2F;xxxx?allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterset&#x3D;utf8mb4</span><br></pre></td></tr></table></figure><p>不得不说MySQL报错信息实在是太模糊了。😓</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
      <category term="Mybatis" scheme="https://jingzhouzhao.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上死锁排查</title>
    <link href="https://jingzhouzhao.github.io/archives/9e47523f.html"/>
    <id>https://jingzhouzhao.github.io/archives/9e47523f.html</id>
    <published>2021-03-23T03:46:15.000Z</published>
    <updated>2021-09-27T09:26:41.058Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>最近又收到了相同的告警，可能不是偶然事件，于是开始排查。<br>首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。</p><a id="more"></a><p>于是向DBA要来了deadlock log，日志内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-03-22 16:02:01 0x7f1cfc289700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 153411874, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 8 lock struct(s), heap size 1136, 23 row lock(s), undo log entries 22</span><br><span class="line">MySQL thread id 8203444, OS thread handle 139762013996800, query id 766107488 updating</span><br><span class="line">update test</span><br><span class="line">SET status &#x3D; 4,</span><br><span class="line">version &#x3D; version+1,</span><br><span class="line">gmt_modified &#x3D; &#39;2021-03-22 16:02:01&#39; </span><br><span class="line">where  id &#x3D; 1</span><br><span class="line">and version&#x3D;14</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411874 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 153411876, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">8 lock struct(s), heap size 1136, 7 row lock(s), undo log entries 6</span><br><span class="line">MySQL thread id 8204162, OS thread handle 139762466330368, query id 766107489  updating</span><br><span class="line">update test</span><br><span class="line">         SET approval_status &#x3D; 5,</span><br><span class="line">                biz_date &#x3D; &#39;2021-02-23 00:00:00&#39;,</span><br><span class="line">                modified_id &#x3D; 123,</span><br><span class="line">                modified_name &#x3D; &#39;xxx&#39;,</span><br><span class="line">                contact_company_id &#x3D; 456,</span><br><span class="line">                contact_company_n</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411876 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411876 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 28 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br></pre></td></tr></table></figure><p>上面日志只保留了关键部分，表名等也进行了脱敏。<br>可以看到两个事务都在等待PRIMARY也就是主键索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96;</span><br></pre></td></tr></table></figure><p>然后再结合日志中的SQL和代码，发现问题的原因如下:</p><p>一共涉及3个系统，分别是S、C、F，在S系统中有一个业务操作完成后会给C，F发消息，C收到S的消息处理完成后也会给F发一个消息，如图所示:</p><p><img src="https://i.loli.net/2021/03/23/cqBePdigLzNIUhF.png" alt="9b1b7abc8bdf0a3113e751fce4700924.png"></p><p>在F中几乎同时开启了两个事务，并且两个消息在F中涉及的记录是相同的，id分别是1，2，表为test。<br>于是出现了事务一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test set status &#x3D; 4 ...... where id&#x3D;1</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test set status &#x3D; 4 ...... where id&#x3D;2</span><br></pre></td></tr></table></figure><p>事务二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test SET approval_status &#x3D; 5 ...... where id &#x3D;2</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test SET approval_status &#x3D; 5 ...... where id &#x3D;1</span><br></pre></td></tr></table></figure><p>事务一先持有id=1的锁，事务二持有id=2的锁，事务一尝试获取id=2的锁，事务二尝试获取id=1的锁，所以死锁了。最后MySQL回滚了事务二。</p><p>发生这种情况是由于产品和系统设计不合理导致的，目前正在重构中。</p><p>如果下次再发生死锁直接看deadlock log吧，没必要浪费时间翻代码看业务日志了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近又收到了相同的告警，可能不是偶然事件，于是开始排查。&lt;br&gt;首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
      <category term="Deadlock" scheme="https://jingzhouzhao.github.io/tags/Deadlock/"/>
    
  </entry>
  
  <entry>
    <title>关闭代码块移动</title>
    <link href="https://jingzhouzhao.github.io/archives/7f244d3f.html"/>
    <id>https://jingzhouzhao.github.io/archives/7f244d3f.html</id>
    <published>2020-08-25T07:22:10.000Z</published>
    <updated>2020-08-25T07:26:32.886Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Editor –&gt; General -&gt; Enable Drag’n’Drop functionality in Editor</span><br></pre></td></tr></table></figure><p>关闭即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>利用mybatis标签替换硬编码</title>
    <link href="https://jingzhouzhao.github.io/archives/ad1a887a.html"/>
    <id>https://jingzhouzhao.github.io/archives/ad1a887a.html</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-13T03:39:22.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>利用mybatis标签替换硬编码</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中偶尔看到这样的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"querySqlString"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       1=1</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"fundsOrderIdList != null and fundsOrderIdList.size()&gt;0"</span>&gt;</span></span><br><span class="line">           and funds_order_id IN</span><br><span class="line">           <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"fundsOrderIdList"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">               #&#123;id&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码中有个<code>1=1</code>很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。</p><a id="more"></a><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>在很久以前，充满智慧的程序员为了解决动态条件拼接的问题，发明了<code>1=1</code>这个写法，对应的还有<code>1=0</code>的写法，我们来看看这个写法在以前是怎么解决问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">"select * from car_table where 1=1"</span></span><br><span class="line"><span class="keyword">for</span>(Condtion condition:conditions)&#123;</span><br><span class="line">    <span class="comment">/**假如没有1=1，第一个条件直接拼接上and语法就错误了</span></span><br><span class="line"><span class="comment">    *还得做出额外判断才行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sql = sql + <span class="string">" and "</span> + condition.field + <span class="string">" = "</span> + condition.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实很巧妙，而且也没有性能问题，不信我给你举个🌰:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> channel_code = <span class="string">'50008'</span>;</span><br></pre></td></tr></table></figure><p>这是一条很简单的SQL，其中就有<code>1=1</code>的写法，我们来看看MySQL查询优化器优化后实际执行的SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> channel_code = <span class="string">'50008'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>;</span><br><span class="line">实际执行的SQL:</span><br><span class="line"><span class="comment">/* select#1 */</span> <span class="keyword">select</span> 此处省略很多<span class="keyword">column</span> <span class="keyword">from</span> <span class="string">`online_paychannel`</span>.<span class="string">`pay_channel_with_bank`</span> <span class="keyword">where</span> (<span class="string">`online_paychannel`</span>.<span class="string">`pay_channel_with_bank`</span>.<span class="string">`channel_code`</span> = <span class="number">50008</span>)</span><br></pre></td></tr></table></figure><p>可以看到<code>1=1</code>已经被优化掉了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然这种写法没啥大问题，但是代码是给人看的。如果不了解这种写法，乍一眼看过去肯定有点懵。</p><p>而且我们现在使用的Mybatis提供的<code>&lt;where&gt;</code>标签本身就会帮我们做优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPrefix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!prefixApplied) &#123;</span><br><span class="line">        prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">            <span class="comment">//此处会移除一些前缀  </span></span><br><span class="line">            <span class="keyword">if</span> (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">              sql.delete(<span class="number">0</span>, toRemove.trim().length());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sql.insert(<span class="number">0</span>, <span class="string">" "</span>);</span><br><span class="line">          sql.insert(<span class="number">0</span>, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WhereSqlNode</code>中定义的<code>prefixesToOverride</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">"AND "</span>,<span class="string">"OR "</span>,<span class="string">"AND\n"</span>, <span class="string">"OR\n"</span>, <span class="string">"AND\r"</span>, <span class="string">"OR\r"</span>, <span class="string">"AND\t"</span>, <span class="string">"OR\t"</span>);</span><br></pre></td></tr></table></figure><p>所以使用了<code>&lt;where&gt;</code>标签后可以放心大胆的去掉<code>1=1</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建议&quot;&gt;&lt;a href=&quot;#建议&quot; class=&quot;headerlink&quot; title=&quot;建议&quot;&gt;&lt;/a&gt;建议&lt;/h2&gt;&lt;p&gt;利用mybatis标签替换硬编码&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目中偶尔看到这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sql&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;querySqlString&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;where&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       1=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fundsOrderIdList != null and fundsOrderIdList.size()&amp;gt;0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           and funds_order_id IN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;collection&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fundsOrderIdList&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;index&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;open&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;(&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;close&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;separator&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               #&amp;#123;id&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码中有个&lt;code&gt;1=1&lt;/code&gt;很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>命令收藏</title>
    <link href="https://jingzhouzhao.github.io/archives/afa41a9c.html"/>
    <id>https://jingzhouzhao.github.io/archives/afa41a9c.html</id>
    <published>2020-07-22T02:45:53.000Z</published>
    <updated>2021-07-05T08:55:11.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h4 id="关闭SPI-获取根目录写权限"><a href="#关闭SPI-获取根目录写权限" class="headerlink" title="关闭SPI(获取根目录写权限)"></a>关闭SPI(获取根目录写权限)</h4><ul><li>重启 <code>command+R</code> 进入恢复界面</li><li>实用工具 - 终端 输入：<code>csrutil disable</code></li><li>重启：<code>reboot</code></li><li>打开终端，挂载根目录：<code>sudo mount -uw /</code><a id="more"></a><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:9999</span><br></pre></td></tr></table></figure><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><h4 id="更新app"><a href="#更新app" class="headerlink" title="更新app"></a>更新app</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cu -a -f</span><br></pre></td></tr></table></figure><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><h4 id="保存堆快照"><a href="#保存堆快照" class="headerlink" title="保存堆快照"></a>保存堆快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h2&gt;&lt;h4 id=&quot;关闭SPI-获取根目录写权限&quot;&gt;&lt;a href=&quot;#关闭SPI-获取根目录写权限&quot; class=&quot;headerlink&quot; title=&quot;关闭SPI(获取根目录写权限)&quot;&gt;&lt;/a&gt;关闭SPI(获取根目录写权限)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;重启 &lt;code&gt;command+R&lt;/code&gt; 进入恢复界面&lt;/li&gt;
&lt;li&gt;实用工具 - 终端 输入：&lt;code&gt;csrutil disable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启：&lt;code&gt;reboot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开终端，挂载根目录：&lt;code&gt;sudo mount -uw /&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>常见集群方式</title>
    <link href="https://jingzhouzhao.github.io/archives/6a6e8ff1.html"/>
    <id>https://jingzhouzhao.github.io/archives/6a6e8ff1.html</id>
    <published>2020-06-16T05:45:53.000Z</published>
    <updated>2020-06-16T05:47:23.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从（master-slave）"><a href="#主从（master-slave）" class="headerlink" title="主从（master-slave）"></a>主从（master-slave）</h3><p>写master，同步到slave 。slave可用于读。常见mysql，redis。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>在主从的基础上，添加了master宕机时，slave自动切换为master。</p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>集群内每个节点都是分片。通过分布式一致性协议沟通。</p><p>例如redis，通过Gossip 协议，在集群内同步，各个分片的哈希槽信息。</p><p>便于重定向请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主从（master-slave）&quot;&gt;&lt;a href=&quot;#主从（master-slave）&quot; class=&quot;headerlink&quot; title=&quot;主从（master-slave）&quot;&gt;&lt;/a&gt;主从（master-slave）&lt;/h3&gt;&lt;p&gt;写master，同步到sla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ RMQ_SYS_TRANS_HALF_TOPIC 爆掉的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/cfa05355.html"/>
    <id>https://jingzhouzhao.github.io/archives/cfa05355.html</id>
    <published>2020-06-05T05:22:44.000Z</published>
    <updated>2021-04-01T02:05:00.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>SaaS项目东郭反应，项目中发的事务消息一直在<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：<img src="https://files.catbox.moe/gdp5ap.png" alt></p><p>这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了<code>TRANS_CHECK_MAXTIME_TOPIC</code>中。</p><p>不正常的是<code>REAL_TOPIC</code>变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。</p><a id="more"></a><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><h4 id="一、排查"><a href="#一、排查" class="headerlink" title="一、排查"></a>一、排查</h4><p>一开始我们以为是Producer的问题，因为得到的反馈是这个消息没有被“消费”，所以我们开始排查Producer所在的项目。发现并没有什么问题。后来我们观察到上述日志中有一个DELAY=3，结合在网上查询的<a href="http://mail-archives.apache.org/mod_mbox/rocketmq-dev/201910.mbox/%3C157129868332.7323.16435164322004213562.gitbox@gitbox.apache.org%3E" target="_blank" rel="noopener">资料</a>，认为可能是触发了RocketMQ的一个问题，就是事务消息进行了延迟发送。我们以为快接近真相了，我们开始查找Producer是否在发送事务消息时设置了DELAY参数。很快我们就失望了，Producer没有任何地方设置了DELAY参数。</p><h4 id="二、翻阅源码"><a href="#二、翻阅源码" class="headerlink" title="二、翻阅源码"></a>二、翻阅源码</h4><p>我们回头去看上面那个日志，发现<code>RECONSUME_TIME=1</code>并且<code>RETRY_TOPIC</code>也不为空，这说明这个消息肯定是被消费者消费到了，但是由于某种原因消费失败了，触发了重试。于是我们开始看RocketMQ重试相关源码。我们首先找到了DELAY=3这个参数的来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的消费者中设置了ConsumeConcurrentlyContext 延时级别</span></span><br><span class="line">context.setDelayLevelWhenNextConsume(getDelayLevelWhenNextConsume(reconsumeTimes));</span><br><span class="line"><span class="comment">//可以看到这个delayLevel最终是会被发送到broker</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap topic with namespace before sending back message.</span></span><br><span class="line">  msg.setTopic(<span class="keyword">this</span>.defaultMQPushConsumer.withNamespace(msg.getTopic()));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"sendMessageBack exception, group: "</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">" msg: "</span> + msg.toString(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找到对应broker版本(4.6.0)的源码一步步找到了这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.CommitLog#putMessage</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line"><span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">    || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">  <span class="comment">// Delay Delivery</span></span><br><span class="line">  <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">      msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">    queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">    msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">    msg.setTopic(topic);</span><br><span class="line">    msg.setQueueId(queueId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照之前日志里的参数，<code>sysFlag=8,delay=3</code>，我们认为很可能走了这段逻辑，然后触发了事务消息进行了延迟发送的问题。继续看了延时消息发送的逻辑，没有找到问题，而且这也解释不了为什么<code>REAL_TOPIC</code>变成了``RMQ_SYS_TRANS_HALF_TOPIC`</p><h4 id="三、真相"><a href="#三、真相" class="headerlink" title="三、真相"></a>三、真相</h4><p>上面还提到了一个<code>RETRY_TOPIC</code>，这个在之前的排查过程中没有发现有什么地方设置，于是我们搜索了一把，发现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(MessageExt msg, <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String brokerAddr = (<span class="keyword">null</span> != brokerName) ? <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</span><br><span class="line">            : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class="number">5000</span>, getMaxReconsumeTimes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"sendMessageBack Exception, "</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</span><br><span class="line"></span><br><span class="line">        Message newMsg = <span class="keyword">new</span> Message(MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span><br><span class="line"></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msg);</span><br><span class="line">        MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">        newMsg.setFlag(msg.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(newMsg, msg.getProperties());</span><br><span class="line">       <span class="comment">//这里设置了RETRY_TOPIC</span></span><br><span class="line">        MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span><br><span class="line">        MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class="number">1</span>));</span><br><span class="line">        MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span><br><span class="line">       </span><br><span class="line">        newMsg.setDelayTimeLevel(<span class="number">3</span> + msg.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQPushConsumer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显是个异常流程，那么到底是什么导致了这个异常流程呢？既然知道是在消费的时候出了异常，于是我们找到对应的消费者日志，发现如下错误：</p><p><img src="https://files.catbox.moe/42fapz.png" alt></p><p>这里Broker返回的错误是<code>MESSAGE_ILIEGAL</code>，在回过头去看重试相关代码，有了之前的经验这次很快就定位到了可能报这个错误的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一处：org.apache.rocketmq.store.DefaultMessageStore#putMessage </span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line"> log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//第二处：org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend(long, java.nio.ByteBuffer, int, org.apache.rocketmq.store.MessageExtBrokerInner)</span></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">  log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br></pre></td></tr></table></figure><p>果断找运维要了<code>store.log</code>，发现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN SendMessageThread_1 - putMessage message topic length too long 149</span><br></pre></td></tr></table></figure><p>所以应该就是第一处的问题了。至此问题的原因基本找到了，但还有以下问题：</p><ol><li><p>为什么TOPIC会超长？</p><p>重试的消息TOPIC规则为%RETRY%+consumerGroup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup())</span><br></pre></td></tr></table></figure><p>而我们的consumerGroup的规则为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group + <span class="string">"_"</span> + getTopic() + <span class="string">"_"</span> + getTags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题的consumer的tags为：<code>SAAS_PURCHASE_PURCHASE_ORDER_UPDATE||SAAS_PURCHASE_PURCHASE_ORDER_OPEN_RECEVIED||SAAS_PURCHASE_PURCHASE_ORDER_COMPLETED_RECEVIED</code></p><p>所以最终拼出来的TOPIC超出了长度。</p></li><li><p>为什么走了Catch里面的流程就会导致HALF队列爆掉？</p><p>这是由于我们使用的RocketMQ-client版本为<code>4.5.0</code>，这个版本Catch里的代码有个bug，没有清除掉原始消息的事务消息标志<code>TRANS_MSG=true</code>。所以这个消息发出去后在broker端又会走事务消息的流程，并且还是带延时的。这会导致真实的TOPIC丢掉。</p><p>下面用一张图来说明一下：</p><p><img src="https://files.catbox.moe/ssraef.png" alt></p><p>事务消息消费失败，topic转为<code>%RETRY%xxxx</code>发送到broker，由于事务消息标志没有被清除，于是topic转成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。又由于delay参数没有被清除，topic最后被转为了<code>schedule_topic_xxxx</code>。等到schedule执行时，消息会发到<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中。由于不是Producer发的事务消息，所以拿不到LocalTransactionState。只能等待事务消息回查。</p><p>这时刚好又碰到我们的LocalTransactionListener的一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">  Object msg = HessianUtils.decode(messageExt.getBody());</span><br><span class="line">  String topic = messageExt.getTopic();</span><br><span class="line">  String tag = messageExt.getTags();</span><br><span class="line">  <span class="comment">//由于拿着rmq_sys_trans_half_topic来获取handler所以肯定获取不到。</span></span><br><span class="line">  LocalTransactionHandler localTransacationHandler = getLocalTransacationHandler(topic, tag);</span><br><span class="line"></span><br><span class="line">  String msgId = messageExt.getMsgId();</span><br><span class="line">  <span class="keyword">if</span>( localTransacationHandler == <span class="keyword">null</span> )&#123;</span><br><span class="line">    logger.error(<span class="string">"localTransacationHandler is empty should never happened! msgId=&#123;&#125;, arg=&#123;&#125;"</span>, msgId, JSON.toJSONString(msg));</span><br><span class="line">    <span class="comment">//于是这个地方会返回COMMIT_MESSAGE</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> checkResult = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkResult = localTransacationHandler.localTransactionCheck(msgId, msg);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">"localTransacationCheck failed! msgId=&#123;&#125;, arg=&#123;&#125;"</span>, msgId, JSON.toJSONString(msg), e);</span><br><span class="line">    checkResult = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> checkResult ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broker收到<code>COMMIT_MESSAGE</code>后会将消息写往REAL_TOPIC中。而此时REAL_TOPIC早已变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。就这样，<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉了。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>首先我们将handler为空时返回<code>COMMIT_MESSAGE</code>，改为了<code>ROLLBACK_MESSAGE</code>。</p></li><li><p>升级stone中RocketMQ为4.6.1，可以看到在Catch代码中多了一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageAccessor.clearProperty(newMsg, &quot;TRAN_MSG&quot;);</span><br></pre></td></tr></table></figure></li><li><p>有问题的consumer将tag拆分</p><p>第一步和第二步只能解决<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉的问题。但是topic超长还是会有问题。所以目前暂时是将consumer的tag拆开。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;SaaS项目东郭反应，项目中发的事务消息一直在&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：&lt;img src=&quot;https://files.catbox.moe/gdp5ap.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了&lt;code&gt;TRANS_CHECK_MAXTIME_TOPIC&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;不正常的是&lt;code&gt;REAL_TOPIC&lt;/code&gt;变成了&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="RocketMQ" scheme="https://jingzhouzhao.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>读取Jar中指定目录下的所有文件</title>
    <link href="https://jingzhouzhao.github.io/archives/f728629b.html"/>
    <id>https://jingzhouzhao.github.io/archives/f728629b.html</id>
    <published>2020-03-19T03:47:54.000Z</published>
    <updated>2020-03-19T05:46:01.558Z</updated>
    
    <content type="html"><![CDATA[<p>读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。</p><a id="more"></a><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>首先要读取Jar中的目录下的文件，得先搞清楚Jar中的目录结构，例如常见的SpringBoot打包后的Jar中目录如下：</p><p><img src="/archives/f728629b/1.png" alt="1"></p><p>假如我们要读取的目录是<code>BOOT-INF/classes/processes</code>（对应源文件目录是<code>resources/processes</code>）</p><p><img src="/archives/f728629b/2.png" alt="2"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前Jar文件路径</span></span><br><span class="line">URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">""</span>);</span><br><span class="line">    String jarPath = url.toString().substring(<span class="number">0</span>, url.toString().indexOf(<span class="string">"!/"</span>) + <span class="number">2</span>);</span><br><span class="line">    log.info(<span class="string">"jarPath:&#123;&#125;"</span>, jarPath);</span><br><span class="line">    URL jarURL = <span class="keyword">new</span> URL(jarPath);</span><br><span class="line">    JarURLConnection jarCon = (JarURLConnection) jarURL.openConnection();</span><br><span class="line">    JarFile jarFile = jarCon.getJarFile();</span><br><span class="line"><span class="comment">//获取Jar下所有文件</span></span><br><span class="line">    Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">        JarEntry jarEntry = entries.nextElement();</span><br><span class="line">      <span class="comment">//获取文件路径</span></span><br><span class="line">        String innerPath = jarEntry.getName();</span><br><span class="line">        log.info(<span class="string">"jarEntry Name:&#123;&#125;"</span>, innerPath);</span><br><span class="line">      <span class="comment">//判断是否需要处理的目录下的文件，PROCESSES=BOOT-INF/classes/processes</span></span><br><span class="line">        <span class="keyword">if</span> (innerPath.startsWith(PROCESSES) &amp;&amp; !jarEntry.isDirectory()) &#123;</span><br><span class="line">          <span class="comment">//获取到文件流</span></span><br><span class="line">            InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(innerPath);</span><br><span class="line">          <span class="comment">//doSomething</span></span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式优缺点：无第三方库依赖，用的都是JDK 相关API。但是只能在jar模式下运行，本地调试会出错。</p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>如果有使用到Spring，那么不管是打成Jar运行还是本地运行，获取指定目录中的文件就很简单了。主要是利用了Spring 的<code>ResourcePatternResolver</code>，详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    List&lt;Resource&gt; resourceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = Arrays.asLIst("**.bpmn20.xml","**.bpmn")</span></span><br><span class="line">    <span class="keyword">for</span> (String suffix : PROCESS_DEFINITION_LOCATION_SUFFIXES) &#123;</span><br><span class="line">      <span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = classpath://processes/</span></span><br><span class="line">        <span class="comment">//拼接路径pattern</span></span><br><span class="line">        String path = PROCESS_DEFINITION_LOCATION_PREFIX + suffix;</span><br><span class="line">      <span class="comment">//通过ResourcePatternResolver获取资源文件,</span></span><br><span class="line">        <span class="comment">//resourceLoader = @Autowired ResourcePatternResolver resourceLoader</span></span><br><span class="line">        Resource[] resources = resourceLoader.getResources(path);</span><br><span class="line">        <span class="keyword">if</span> (resources != <span class="keyword">null</span> &amp;&amp; resources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            resourceList.addAll(Arrays.asList(resources));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过resource.getInputStream()即可获取文件流</span></span><br><span class="line"><span class="comment">//doSomething</span></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>此方式优缺点，依赖了Spring框架，但是对运行环境没有要求。</p><p>总结：</p><p>推荐使用第二种方式，毕竟现在基本上都会使用到Spring。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>tk.mybatis与Activiti共存问题解决</title>
    <link href="https://jingzhouzhao.github.io/archives/7008e148.html"/>
    <id>https://jingzhouzhao.github.io/archives/7008e148.html</id>
    <published>2020-03-05T12:53:07.000Z</published>
    <updated>2020-03-05T13:03:39.084Z</updated>
    
    <content type="html"><![CDATA[<p>由于tk.mybatis依赖了persistence-api，会让Activiti装配JpaProcessEngineAutoConfiguration，因为其@conditonalOnclass(name = “javax.persistence.EntityManagerFactory”)。</p><p>但实际没有使用JPA，导致启动报错。如果排除persistence-api，又会导致tk.mybatis报错。</p><p>参考了一番其它的人做法，无论是各种排除还是添加依赖都无效。</p><p>最终自己的解决方案是：</p><p>首先排除activiti jpa的自动装配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude&#x3D;&#123;JpaProcessEngineAutoConfiguration.class&#125;)。</span><br></pre></td></tr></table></figure><p>然后找到activiti中的<code>DataSourceProcessEngineAutoConfiguration.class</code> 复制出源码，在自己的项目中添加一个同名文件（不同名也行）。然后粘贴内容到新建的文件中。最后删掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnMissionClass(name &#x3D; &quot;javax.persistence.EntityManagerFactory&quot;)</span><br></pre></td></tr></table></figure><p>Ok,搞定！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于tk.mybatis依赖了persistence-api，会让Activiti装配JpaProcessEngineAutoConfiguration，因为其@conditonalOnclass(name = “javax.persistence.EntityManage
      
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Activiti" scheme="https://jingzhouzhao.github.io/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>被隔离的第7天</title>
    <link href="https://jingzhouzhao.github.io/archives/3eda1a9.html"/>
    <id>https://jingzhouzhao.github.io/archives/3eda1a9.html</id>
    <published>2020-03-03T05:22:11.000Z</published>
    <updated>2020-03-03T05:28:00.747Z</updated>
    
    <content type="html"><![CDATA[<p>被隔离的第7天，每天接到无数个部门的电话，量体温，报情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;被隔离的第7天，每天接到无数个部门的电话，量体温，报情况。&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://jingzhouzhao.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>更换电脑后hexo deploy访问出现404的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/32745de6.html"/>
    <id>https://jingzhouzhao.github.io/archives/32745de6.html</id>
    <published>2019-10-16T10:49:53.000Z</published>
    <updated>2019-10-16T11:14:24.615Z</updated>
    
    <content type="html"><![CDATA[<p>更换电脑后重新拉下hexo相关sources，安装完成hexo-cli以及hexo-deployer-git和其他node_modules。</p><p>执行hexo clean &amp;&amp; hexo g </p><p>然后执行hexo d。</p><a id="more"></a><p>完成后发现访问出现404，提示<strong>There isn’t a GitHub Pages site here.</strong></p><p>并且github发了大量警告邮件，有得没得，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are attempting to use a Jekyll theme, &quot;icarus&quot;, which is not supported by GitHub Pages.</span><br></pre></td></tr></table></figure><p>定位问题：</p><ol><li>查看github pages对应repository，发现里面的文件完全不正确，不是hexo g生成的文件。而变成了博客对应的源文件。</li><li>查看文件是否正确生成，public目录下正确生成。</li><li>通过上面两个步骤，说明问题出在deploy。</li></ol><p>解决问题：</p><p>删除<code>.deploy_git</code>，重新<code>hexo d</code>，一切恢复正常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更换电脑后重新拉下hexo相关sources，安装完成hexo-cli以及hexo-deployer-git和其他node_modules。&lt;/p&gt;
&lt;p&gt;执行hexo clean &amp;amp;&amp;amp; hexo g &lt;/p&gt;
&lt;p&gt;然后执行hexo d。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>PriorityQueue解析</title>
    <link href="https://jingzhouzhao.github.io/archives/f50feeee.html"/>
    <id>https://jingzhouzhao.github.io/archives/f50feeee.html</id>
    <published>2019-10-10T02:13:00.000Z</published>
    <updated>2019-10-16T09:05:40.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载至github：<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md</a></p></blockquote><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><a id="more"></a><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p><code>leftNo = parentNo*2+1</code></p><p><code>rightNo = parentNo*2+2</code></p><p><code>parentNo = (nodeNo-1)/2</code></p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftUp()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></p><p>代码也就非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftDown()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    <span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载至github：&lt;a href=&quot;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PriorityQueue&quot;&gt;&lt;a href=&quot;#PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue&quot;&gt;&lt;/a&gt;PriorityQueue&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerlink&quot; title=&quot;总体介绍&quot;&gt;&lt;/a&gt;总体介绍&lt;/h1&gt;&lt;p&gt;前面以Java &lt;em&gt;ArrayDeque&lt;/em&gt;为例讲解了&lt;em&gt;Stack&lt;/em&gt;和&lt;em&gt;Queue&lt;/em&gt;，其实还有一种特殊的队列叫做&lt;em&gt;PriorityQueue&lt;/em&gt;，即优先队列。&lt;strong&gt;优先队列的作用是能保证每次取出的元素都是队列中权值最小的&lt;/strong&gt;（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，&lt;strong&gt;元素大小的评判可以通过元素本身的自然顺序（&lt;em&gt;natural ordering&lt;/em&gt;），也可以通过构造时传入的比较器&lt;/strong&gt;（&lt;em&gt;Comparator&lt;/em&gt;，类似于C++的仿函数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker-alpine镜像导致的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/f3674cca.html"/>
    <id>https://jingzhouzhao.github.io/archives/f3674cca.html</id>
    <published>2019-09-26T05:04:26.000Z</published>
    <updated>2019-10-16T09:05:40.003Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。</p><a id="more"></a><p>通过查找日志发现以下异常堆栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="keyword">null</span></span><br><span class="line">        at sun.awt.X11FontManager.getDefaultPlatformFont(X11FontManager.java:<span class="number">779</span>)</span><br><span class="line">        at sun.font.SunFontManager$<span class="number">2</span>.run(SunFontManager.java:<span class="number">433</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:<span class="number">376</span>)</span><br><span class="line">        at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:<span class="number">32</span>)</span><br><span class="line">        at sun.reflect.GeneratedConstructorAccessor62.newInstance(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">        at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">526</span>)</span><br><span class="line">        at java.lang.Class.newInstance(Class.java:<span class="number">383</span>)</span><br><span class="line">        at sun.font.FontManagerFactory$<span class="number">1</span>.run(FontManagerFactory.java:<span class="number">83</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:<span class="number">74</span>)</span><br><span class="line">        at java.awt.Font.getFont2D(Font.java:<span class="number">490</span>)</span><br><span class="line">        at java.awt.Font.access$<span class="number">000</span>(Font.java:<span class="number">224</span>)</span><br><span class="line">        at java.awt.Font$FontAccessImpl.getFont2D(Font.java:<span class="number">228</span>)</span><br><span class="line">        at sun.font.FontUtilities.getFont2D(FontUtilities.java:<span class="number">180</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:<span class="number">645</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:<span class="number">806</span>)</span><br><span class="line">        at sun.java2d.pipe.GlyphListPipe.drawString(GlyphListPipe.java:<span class="number">50</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.drawString(SunGraphics2D.java:<span class="number">2887</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>结合源码发现，应该是无法获取到字体导致的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphics.setFont(new Font(&quot;Default&quot;, Font.PLAIN, fsize));</span><br></pre></td></tr></table></figure><p>由于代码没有做出过变更，所以毫无疑问，应该是环境的问题了。</p><p>于是我进入Dokcer容器查看相关字体：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it containerId bash</span><br><span class="line">fc-list</span><br></pre></td></tr></table></figure><p>发现无任何内容输出。经过一番查找，解决办法如下：</p><ol><li><p>进入容器安装字体（只能临时解决，当重新构建后，字体会丢失）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>修改Dockerfile 在构建镜像时安装字体（会影响构建速度，安装字体比较慢）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>更改基础镜像（推荐）</p><p>我这边出问题的容器是基于<code>tomcat:8.0-jre7-alpine</code>构建的，alpine tag的镜像比较小，比较干净。</p><p>我到docker hub上找到了类似的镜像，<code>slim</code> tag的。</p><p>修改Dockerfile，将<code>FROM tomcat:8.0-jre7-alpine</code> 改为 <code>FROM tomcat:8.0-jre7-slim</code>即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker随记" scheme="https://jingzhouzhao.github.io/categories/Docker%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://jingzhouzhao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>为什么苹果不自己制造芯片</title>
    <link href="https://jingzhouzhao.github.io/archives/52360944.html"/>
    <id>https://jingzhouzhao.github.io/archives/52360944.html</id>
    <published>2019-09-20T02:01:43.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？</p><a id="more"></a><p>原来业内习惯把半导体行业的公司分为三类：</p><p>fabless（无晶圆芯片设计厂）：这样的公司只设计芯片，不自己制造芯片。最大的fabless企业有高通、博通、AMD、联发科、搭上人工智能这波热点最近火的不行的Nvidia等等。国内的fabless企业有收购了展讯和锐迪科的清华紫光、华为海思等。<br>Foundry（代工厂）：这样的公司专门为别人制造芯片。最大的Foundry企业有台积电（TSMC）、GlobalFoundry、UMC等。国内最大的是中芯国际。随着工艺进步到20nm以下，从平面晶体管向三维FinFET演化，新一代工艺所需要的投资越来越大，已经只有少数几个玩家能玩得起了（台积电、三星、Intel）。国内的中芯国际跟台积电有几代的差距。中芯国际目前商用的最先进工艺是28nm，台积电16nm已经大规模商用，7nm也马上就要用起来。<br>IDM（制造垂直整合）：这样的公司既设计芯片，也自己制造芯片。最大的有Intel和三星。</p><p>这样做的好处是，分担风险，苹果不用花费巨大投资建立生产线，因此轻资产，灵活性高，可以对市场快速反应，活力足。</p><p>再说另外一个问题，为什么主流的手机处理器厂商中很少见到英特尔呢？<br>首先提一下CPU的简单构成：ALU（算术逻辑单元）、控制单元、寄存器<br>控制单元通过时钟控制着指令执行的节奏，将指令加载存放在寄存器、并通过ALU计算。<br>这里提到了指令，指令基本上分为两类：RISC（精简指令集） 、CISC （复杂指令集），指令越复杂意味着能耗越高，试想一下，在目前手机电池技术还未突破的情况下，手机CPU会上CISC吗？<br>上面说的两个指令集的典型代表就是ARM和x86，ARM是目前主流的手机CPU架构，也就是精简指令。而x86才是英特尔等厂商的强项。<br>也许是英特尔出于战略考虑放弃了移动处理器这块蛋糕，或者说英特尔没有意料到这块蛋糕这么大。不过，目前App背后对应的还是各种Server，Server离不开x86。</p><p>参考资料：<br><a href="https://www.zhihu.com/question/68283951/answer/262481048" target="_blank" rel="noopener">https://www.zhihu.com/question/68283951/answer/262481048</a><br><a href="https://www.zhihu.com/question/20148756" target="_blank" rel="noopener">https://www.zhihu.com/question/20148756</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>golang写文件异常invalid argument</title>
    <link href="https://jingzhouzhao.github.io/archives/848ae75e.html"/>
    <id>https://jingzhouzhao.github.io/archives/848ae75e.html</id>
    <published>2019-09-11T07:10:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">defer</span> dst.Close()</span><br><span class="line">n, err := dst.Write(buffer.Buffer[<span class="number">0</span>:n])</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是一段很简单的代码，但是在频繁调用的时候报错了了:<code>invalid argument</code></p><p>这个错误着实太误导人了，让我以为是使用的姿势不对，后来发现没有问题，于是开始debug，后来在下面一段代码中发现了真正的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFile</span><span class="params">(name *<span class="keyword">uint16</span>, access <span class="keyword">uint32</span>, mode <span class="keyword">uint32</span>, sa *SecurityAttributes, createmode <span class="keyword">uint32</span>, attrs <span class="keyword">uint32</span>, templatefile <span class="keyword">int32</span>)</span> <span class="params">(handle Handle, err error)</span></span> &#123;</span><br><span class="line">r0, _, e1 := Syscall9(procCreateFileW.Addr(), <span class="number">7</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(name)), <span class="keyword">uintptr</span>(access), <span class="keyword">uintptr</span>(mode), <span class="keyword">uintptr</span>(unsafe.Pointer(sa)), <span class="keyword">uintptr</span>(createmode), <span class="keyword">uintptr</span>(attrs), <span class="keyword">uintptr</span>(templatefile), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">handle = Handle(r0)</span><br><span class="line"><span class="keyword">if</span> handle == InvalidHandle &#123;</span><br><span class="line"><span class="keyword">if</span> e1 != <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">err = errnoErr(e1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = EINVAL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出了真正的原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; errnoErr(e1)&#x2F;&#x2F;这个地方给出了真正的错误：ERROR_SHARING_VIOLATION (32)</span><br></pre></td></tr></table></figure><p>查询微软<a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-文档，" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-文档，</a></p><p>这个错误是因为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The process cannot access the file because it is being used by another process.</span><br></pre></td></tr></table></figure><p>也就是说，在OpenFile一个文件的时候，之前使用的这个文件的file descriptor 并真正没有释放，所以出错了。</p><p>而Golang上层的错误并没有给出明确的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dst, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, &lt;span class=&quot;number&quot;&gt;0644&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; dst.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n, err := dst.Write(buffer.Buffer[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:n])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://jingzhouzhao.github.io/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://jingzhouzhao.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>跟着B站学Golang(admin-ep-saga)</title>
    <link href="https://jingzhouzhao.github.io/archives/f11de5dd.html"/>
    <id>https://jingzhouzhao.github.io/archives/f11de5dd.html</id>
    <published>2019-09-05T08:50:12.000Z</published>
    <updated>2019-10-16T09:05:40.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文完全出于学习的目的，如有异议，请联系删除。</p></blockquote><p>之前XL事件流出的优秀代码太多了，这次选择的是一个好像与具体业务无关的模块(admin-ep-saga)来进行学习。</p><a id="more"></a><p>首先看看目录结构：</p><p><img src="/archives/f11de5dd/1.png" alt="目录结构"></p><p>这么多先看哪一个呢？在不知道具体每个包是干什么的情况下，只好一个一个的看了。</p><p>先看看<code>api</code>下有些什么：</p><p><img src="/archives/f11de5dd/2.png" alt="api"></p><p>不得不说这个目录的结构相当规范呀，虽然我没有点开具体文件，但是仅仅从目录名和文件名就能猜出这个目录下是干什么的：</p><p>应该是使用了grpc框架和protobuf协议定义的接口。这个暂时先放一边，我需要先找到<strong>程序入口</strong>，这样才能一步一步的学习优秀代码是如何编写的。</p><p>接下来打开<code>cmd</code>:</p><p><img src="/archives/f11de5dd/3.png" alt="cmd"></p><p>这个目录下有三个文件：</p><ol><li><code>BUILD</code>看着应该是用来做构建用的，这不是我这次学习的重点，先跳过。</li><li><code>saga-admin-test.toml</code> 我打开看了一眼，是一个配置文件，从名字可以看出应该是测试用的配置项，后面还会碰到。</li><li><code>main.go</code> 如果不出意外，这个应该就是<strong>程序入口</strong>了，运气还不错，第二个目录就找到了入口。</li></ol><p>接下来详细的看看main.go做了些什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里我忽略了一些包导入，以及一些常量</span></span><br><span class="line"><span class="comment">因为如果每个导入的包都要看的话，会越陷越深。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line">    <span class="comment">//初始化配置</span></span><br><span class="line"><span class="keyword">if</span> err := conf.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"conf.Init() error(%v)"</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化Log</span></span><br><span class="line">log.Init(conf.Conf.Log)</span><br><span class="line"><span class="keyword">defer</span> log.Close()</span><br><span class="line">log.Info(<span class="string">"saga-admin start"</span>)</span><br><span class="line"><span class="comment">//启动一个服务</span></span><br><span class="line">s := service.New()</span><br><span class="line">http.Init(s)</span><br><span class="line">    <span class="comment">//启动一个grpc服务</span></span><br><span class="line">grpcsvr, err := grpc.New(<span class="literal">nil</span>, s.Wechat())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建一个长度为1的os.Signal类型的channel</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">//通知</span></span><br><span class="line">signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//从前面创建的channel中读取signal</span></span><br><span class="line">si := &lt;-c</span><br><span class="line">log.Info(<span class="string">"saga-admin get a signal %s"</span>, si.String())</span><br><span class="line"><span class="keyword">switch</span> si &#123;</span><br><span class="line">        <span class="comment">//如果是SIGQUIT、SIGTERM、SIGINT则关闭相关服务，然后退出</span></span><br><span class="line"><span class="keyword">case</span> syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:</span><br><span class="line">grpcsvr.Shutdown(context.Background())</span><br><span class="line">log.Info(<span class="string">"saga-admin exit"</span>)</span><br><span class="line">s.Close()</span><br><span class="line">time.Sleep(_durationForClosingServer * time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略的看了一下代码后，带着疑问，一行一行的来分析，首先第一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure><p>作为Golang小白，我知道这个应该是使用在<code>flag.StringVar</code>这样的代码后面，定义需要获取的命令行参数。</p><p>但是<code>flag.Parse()</code>作为第一行代码前面并没有<code>flag.StringVar</code>类似这样的代码呀，然后我想到了Golang中<code>init</code>函数的作用。于是我开始找<code>main.go</code>中导入的其他包中有没有定义init函数，果不其然，在<code>saga/conf/conf.go</code>中我找到了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个命令行参数，用来接收配置文件路径</span></span><br><span class="line">flag.StringVar(&amp;confPath, <span class="string">"conf"</span>, <span class="string">""</span>, <span class="string">"config path"</span>)</span><br><span class="line">    <span class="comment">//这个reload后面再讲</span></span><br><span class="line">reload = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>main.go</code>来看下面几行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := conf.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(<span class="string">"conf.Init() error(%v)"</span>, err)</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略错误判断以及日志打印，我们可以看到这几行中最关键的代码就是<code>conf.Init()</code>，这个代码做了些什么事情呢？接下来进入<code>saga/conf/conf.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//判断如果配置文件的路径为空，则执行configCenter()方法</span></span><br><span class="line"><span class="keyword">if</span> confPath == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> configCenter()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果配置文件路径不为空通过toml.DecodeFile(confPath, &amp;Conf)解析配置到&amp;Conf中</span></span><br><span class="line"><span class="keyword">if</span> _, err = toml.DecodeFile(confPath, &amp;Conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"toml.DecodeFile(%s) err(%+v)"</span>, confPath, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//单独解析TeamInfo相关配置</span></span><br><span class="line">Conf = parseTeamInfo(Conf)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> confPath == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> configCenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数名可以看出，当没有手动指定配置文件路径是，走配置中心解析配置。<code>configCenter</code>我们先放一放，我们接着往下看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err = toml.DecodeFile(confPath, &amp;Conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"toml.DecodeFile(%s) err(%+v)"</span>, confPath, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟之前一样，我们忽略错误和日志处理，可以看到这几行关键代码是<code>toml.DecodeFile(confPath, &amp;Conf)</code>，</p><p><code>toml</code>这个看着是不是很眼熟，之前在<code>cmd</code>包下我们看到过一个这个格式的文件<code>saga-admin-test.toml</code>，这是一个由GitHub联合创始人Tom Preston-Werner 搞出的极简配置文件格式。各个语言都有相关实现，BZ这里使用的是<code>github.com/BurntSushi/toml</code>这个库。</p><p>总而言之，这几行代码无非就是解析配置文件。</p><p>继续往下看:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conf = parseTeamInfo(Conf)</span><br></pre></td></tr></table></figure><p>单独用了一个方法来解析<code>TeamInfo</code>说明toml标准的DecodeFile解析不了，我们来看看这个方法做了什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个方法做的事情比较简单，直接采用注释的方法讲解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseTeamInfo</span><span class="params">(c *Config)</span> *<span class="title">Config</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strings.Fields，我们都知道这个是根据字符串中的空格或者一些个特殊符号来拆分字符串为Array的方法。</span></span><br><span class="line"><span class="comment">我们来看看之前提到的saga-admin-test.toml中c.Property.Department 定义的是什么：</span></span><br><span class="line"><span class="comment">[property.department]</span></span><br><span class="line"><span class="comment">        label = "主站 直播 bplus 开放平台 创作中心 商业产品 数据中心 视频云 游戏 火鸟"</span></span><br><span class="line"><span class="comment">        value = "mainsite live bplus openplatform creative advertising datacenter videocloud game firebird"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DeLabel := strings.Fields(c.Property.Department.Label)</span><br><span class="line">DeValue := strings.Fields(c.Property.Department.Value)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(DeLabel); i++ &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">所以这几行代码，很显而易见了，就是将上述的label 和value组合成key-value的形式然后append到另外一个(DeInfo)Array中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">info := &amp;model.PairKey&#123;</span><br><span class="line">Label: DeLabel[i],</span><br><span class="line">Value: DeValue[i],</span><br><span class="line">&#125;</span><br><span class="line">c.Property.DeInfo = <span class="built_in">append</span>(c.Property.DeInfo, info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面几行代码同上，就不在赘述</span></span><br><span class="line">buLabel := strings.Fields(c.Property.Business.Label)</span><br><span class="line">buValue := strings.Fields(c.Property.Business.Value)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(buLabel); i++ &#123;</span><br><span class="line"></span><br><span class="line">info := &amp;model.PairKey&#123;</span><br><span class="line">Label: buLabel[i],</span><br><span class="line">Value: buValue[i],</span><br><span class="line">&#125;</span><br><span class="line">c.Property.BuInfo = <span class="built_in">append</span>(c.Property.BuInfo, info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说，上面的<code>Business</code>和<code>Department</code>处理过程一样，为啥不将这个过程提取成一个函数呢？来自小白的疑问。</p><p>还记得我们之前跳过一个函数<code>configCenter()</code>吗？接下来我们一起来看看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configCenter</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里的conf应该是BZ一个公共组件，这里做的就是创建一个配置中心的client</span></span><br><span class="line"><span class="keyword">if</span> client, err = conf.New(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里调用了load函数</span></span><br><span class="line"><span class="keyword">if</span> err = load(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里应该是添加了一个配置中心的监听</span></span><br><span class="line">client.WatchAll()</span><br><span class="line">    <span class="comment">//起一个goroute</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//获取事件，如果配置中心的配置存在修改重新调用load函数</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> client.Event() &#123;</span><br><span class="line">log.Info(<span class="string">"config reload"</span>)</span><br><span class="line"><span class="keyword">if</span> load() != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"config reload error (%v)"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//load成功往reload chan写入一个数据，这里有个疑问，等后面再说</span></span><br><span class="line">reload &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略其它代码，可以看到上面实现配置中心配置加载的应该是load函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一组局部变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">s       <span class="keyword">string</span></span><br><span class="line">ok      <span class="keyword">bool</span></span><br><span class="line">tmpConf *Config</span><br><span class="line">)</span><br><span class="line">    <span class="comment">//通过配置中心的client获取配置，这里的_configkey是常量："saga-admin.toml"</span></span><br><span class="line"><span class="keyword">if</span> s, ok = client.Value(_configKey); !ok &#123;</span><br><span class="line">err = errors.Errorf(<span class="string">"load config center error [%s]"</span>, _configKey)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//跟之前一样通过toml解析配置</span></span><br><span class="line"><span class="keyword">if</span> _, err = toml.Decode(s, &amp;tmpConf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.Wrapf(err, <span class="string">"could not decode config err(%+v)"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//跟之前一样单独解析TeamInfo</span></span><br><span class="line">Conf = parseTeamInfo(tmpConf)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们差不多刚刚看完<code>main.go</code>中<code>conf.Init()</code>的调用，接下来回到<code>main.go</code>，继续往下看：</p><p>我们跳过Log的初始化，直接看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用/saga/service中的New函数</span></span><br><span class="line">s := service.New()</span><br><span class="line"><span class="comment">//调用/saga/http中的Init函数</span></span><br><span class="line">http.Init(s)</span><br></pre></td></tr></table></figure><p>跳转到<code>New</code>函数中，我们看看做了些什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(s *Service)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">err error</span><br><span class="line">)</span><br><span class="line">s = &amp;Service&#123;</span><br><span class="line">dao:  dao.New(),</span><br><span class="line">cron: cron.New(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncProject.CheckCron, s.collectprojectproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.Git.CheckCron, s.alertProjectPipelineProc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCron, s.syncdataproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCronAll, s.syncalldataproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCronWeek, s.syncweekdataproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">s.cron.Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// init gitlab client</span></span><br><span class="line">s.gitlab = gitlab.New(conf.Conf.Property.Gitlab.API, conf.Conf.Property.Gitlab.Token)</span><br><span class="line"><span class="comment">// init online gitlab client</span></span><br><span class="line">s.git = gitlab.New(conf.Conf.Property.Git.API, conf.Conf.Property.Git.Token)</span><br><span class="line"><span class="comment">// init wechat client</span></span><br><span class="line">s.wechat = wechat.New(s.dao)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码大部分都是在做定时任务的创建，<code>cron</code>使用的是<code>&quot;github.com/robfig/cron&quot;</code>这个库，我们挑一个看看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncProject.CheckCron, s.collectprojectproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>conf.Conf.Property.SyncProject.CheckCron</code> 是配置中的cron表达式，在<code>saga-admin-test.toml</code>中看到是</p><p><code>* */15 * * * ?</code>也就是说这个任务每15分钟执行一次。</p><p><code>s.collectprojectproc</code> 是要执行的任务，接下来看看这个任务做了什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">collectprojectproc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">    <span class="comment">//可以看到实际调用的是CollectProject，这里的context.TODO()表示context还未实现，这里仅仅用作占位，没有实际意义</span></span><br><span class="line"><span class="keyword">if</span> err = s.CollectProject(context.TODO()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"s.CollectProject err (%+v)"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">CollectProject</span><span class="params">(c context.Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是一组局部变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">projects []*gitlab.Project</span><br><span class="line">total    = <span class="number">0</span></span><br><span class="line">page     = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">"Collect Project start"</span>)</span><br><span class="line">    <span class="comment">//这里出现了一个magic number，1000</span></span><br><span class="line"><span class="keyword">for</span> page &lt;= <span class="number">1000</span> &#123;</span><br><span class="line"><span class="comment">//调用gitlab接口获取指定页码的项目列表，这里的s.gitlab是在service.New()中实例化的。这里有一个疑问。</span></span><br><span class="line"><span class="keyword">if</span> projects, err = s.gitlab.ListProjects(page); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num := <span class="built_in">len</span>(projects)</span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">total = total + num</span><br><span class="line"><span class="comment">//将获取到的项目保存到db中，这个insertDB就不展开讲了，这里面做的大概就是saveOrUpdate的事情。</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> projects &#123;</span><br><span class="line"><span class="keyword">if</span> err = s.insertDB(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = page + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"Collect Project end, find %d projects"</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service.New()</code>中其他的cron也差不多是做着类似的事情，由于太多，就不在这里一一展开。刚刚说到</p><p><code>s.gitlab.ListProjects(page);</code>我有一个疑问，是什么呢？我们看这里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.cron.Start()</span><br><span class="line"><span class="comment">// init gitlab client</span></span><br><span class="line">s.gitlab = gitlab.New(conf.Conf.Property.Gitlab.API, conf.Conf.Property.Gitlab.Token)</span><br><span class="line"><span class="comment">// init online gitlab client</span></span><br><span class="line">s.git = gitlab.New(conf.Conf.Property.Git.API, conf.Conf.Property.Git.Token)</span><br><span class="line"><span class="comment">// init wechat client</span></span><br><span class="line">s.wechat = wechat.New(s.dao)</span><br></pre></td></tr></table></figure><p>可以发现cron的start是在gitlab、git、wechat实例化之前，而cron相关的任务中又依赖了这些client，那有没有这么一种可能：这个程序启动的时候正好碰上cron触发，而gitlab，wechat这些client还没有实例化，所以有没有可能出现panic？当然了，这个可能性很小。</p><p>让我们再次回到main.go中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个http服务</span></span><br><span class="line">http.Init(s)</span><br></pre></td></tr></table></figure><p>进入<code>Init</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init init</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(s *service.Service)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这个srv很重要，这是在上面service.New()最后返回的实例，在后面经常用到</span></span><br><span class="line">srv = s</span><br><span class="line">    <span class="comment">//这个permit是go-common/library/net/http/blademaster 中的组件，应该是用来做接口认证的</span></span><br><span class="line">authSvc = permit.New2(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//下面就是启动http engine了，这个engine就是上面提到的这个blademaster</span></span><br><span class="line">engine := bm.DefaultServer(conf.Conf.BM)</span><br><span class="line">engine.Ping(ping)</span><br><span class="line">initRouter(engine)</span><br><span class="line"><span class="keyword">if</span> err := engine.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"engine.Start error(%v)"</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个http服务是依赖的BZ公共的组件，就不继续深入了，我怕出不来了。我们看看<code>initRouter</code>中定义的Router，由于太长，我只选择开始一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version := e.Group(<span class="string">"/ep/admin/saga/v1"</span>, authSvc.Permit2(<span class="string">""</span>))</span><br><span class="line">&#123;</span><br><span class="line">project := version.Group(<span class="string">"/projects"</span>)</span><br><span class="line">&#123;</span><br><span class="line">project.GET(<span class="string">"/favorite"</span>, favoriteProjects)</span><br><span class="line">project.POST(<span class="string">"/favorite/edit"</span>, editFavorite)</span><br><span class="line">project.GET(<span class="string">"/common"</span>, queryCommonProjects)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是很常见的url-mapping了，这里的<code>favoriteProjects</code>、<code>editFavorite</code>、<code>queryCommonProjects</code> 都是定义在当前<code>http</code>包下的函数，我们选择<code>favoriteProjects</code>看下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoriteProjects</span><span class="params">(ctx *bm.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">req      = &amp;model.Pagination&#123;&#125;</span><br><span class="line">err      error</span><br><span class="line">userName <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">    <span class="comment">//这里应该是解析请求参数到req变量中</span></span><br><span class="line"><span class="keyword">if</span> err = ctx.Bind(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="literal">nil</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里是调用函数获取当前用户名</span></span><br><span class="line"><span class="keyword">if</span> userName, err = getUsername(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="literal">nil</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//我们看到这里最终回到了srv上，调用了实际的处理方法。这里的FavoriteProjects实际就是通过db查询当前用户收藏的项目，我们就不继续深入了。</span></span><br><span class="line">ctx.JSON(srv.FavoriteProjects(ctx, req, userName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的流程大概是这样的，首先在<code>http</code>包中将参数等一些信息进行解析，最后调用到了<code>service</code>中的方法。这个就很像Java中流行的写法：从<code>Controller</code>到<code>Service</code>，符合<code>MVC</code>分层的思想。</p><p>最后还有一个grpc，我大概看了下，应该是用来企业微信发消息的。</p><p>总结：</p><p>这应该是用来做gitlab ci告警之类的project，可以看到这个project层次很分明，代码看过去一目了然。</p><p>最后，之前还有一个疑问，就是<code>reload</code>这个变量，在初始化时是有长度的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>长度为10，在每次配置文件修改后，goroute watch到event之后会往这个channel写入一个<code>true</code>，但是看完整个代码之后，并没有看到有地方从这个channel取出数据（也有可能是我漏看了），也就是说当修改10次之后，这个地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>就会阻塞，从而导致这个goroute无响应？</p><p>码字不易，且转且珍惜。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文完全出于学习的目的，如有异议，请联系删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前XL事件流出的优秀代码太多了，这次选择的是一个好像与具体业务无关的模块(admin-ep-saga)来进行学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://jingzhouzhao.github.io/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://jingzhouzhao.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
