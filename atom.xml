<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>larry&#39;s blog</title>
  
  <subtitle>赵荆州的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qmbb.top/"/>
  <updated>2019-10-16T09:05:40.007Z</updated>
  <id>https://qmbb.top/</id>
  
  <author>
    <name>赵荆州</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PriorityQueue解析</title>
    <link href="https://qmbb.top/archives/f50feeee.html"/>
    <id>https://qmbb.top/archives/f50feeee.html</id>
    <published>2019-10-10T02:13:00.000Z</published>
    <updated>2019-10-16T09:05:40.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载至github：<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md</a></p></blockquote><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><a id="more"></a><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p><code>leftNo = parentNo*2+1</code></p><p><code>rightNo = parentNo*2+2</code></p><p><code>parentNo = (nodeNo-1)/2</code></p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//offer(E e)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<span class="hljs-comment">//不允许放入null元素</span></span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="hljs-keyword">int</span> i = size;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="hljs-number">1</span>);<span class="hljs-comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="hljs-number">0</span>] = e;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="hljs-comment">//调整</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//siftUp()</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></p><p>代码也就非常简洁：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//peek()</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"><br>代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="hljs-number">0</span>];<span class="hljs-comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)</span><br><span class="line">        siftDown(<span class="hljs-number">0</span>, x);<span class="hljs-comment">//调整</span></span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//siftDown()</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    <span class="hljs-comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="hljs-comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></p><p>具体代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//remove(Object o)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> s = --size;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s == i) <span class="hljs-comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="hljs-keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="hljs-comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载至github：&lt;a href=&quot;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PriorityQueue&quot;&gt;&lt;a href=&quot;#PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue&quot;&gt;&lt;/a&gt;PriorityQueue&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerlink&quot; title=&quot;总体介绍&quot;&gt;&lt;/a&gt;总体介绍&lt;/h1&gt;&lt;p&gt;前面以Java &lt;em&gt;ArrayDeque&lt;/em&gt;为例讲解了&lt;em&gt;Stack&lt;/em&gt;和&lt;em&gt;Queue&lt;/em&gt;，其实还有一种特殊的队列叫做&lt;em&gt;PriorityQueue&lt;/em&gt;，即优先队列。&lt;strong&gt;优先队列的作用是能保证每次取出的元素都是队列中权值最小的&lt;/strong&gt;（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，&lt;strong&gt;元素大小的评判可以通过元素本身的自然顺序（&lt;em&gt;natural ordering&lt;/em&gt;），也可以通过构造时传入的比较器&lt;/strong&gt;（&lt;em&gt;Comparator&lt;/em&gt;，类似于C++的仿函数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://qmbb.top/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://qmbb.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker-alpine镜像导致的问题</title>
    <link href="https://qmbb.top/archives/f3674cca.html"/>
    <id>https://qmbb.top/archives/f3674cca.html</id>
    <published>2019-09-26T05:04:26.000Z</published>
    <updated>2019-10-16T09:05:40.003Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。</p><a id="more"></a><p>通过查找日志发现以下异常堆栈：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="hljs-keyword">null</span></span><br><span class="line">        at sun.awt.X11FontManager.getDefaultPlatformFont(X11FontManager.java:<span class="hljs-number">779</span>)</span><br><span class="line">        at sun.font.SunFontManager$<span class="hljs-number">2</span>.run(SunFontManager.java:<span class="hljs-number">433</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:<span class="hljs-number">376</span>)</span><br><span class="line">        at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:<span class="hljs-number">32</span>)</span><br><span class="line">        at sun.reflect.GeneratedConstructorAccessor62.newInstance(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="hljs-number">45</span>)</span><br><span class="line">        at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="hljs-number">526</span>)</span><br><span class="line">        at java.lang.Class.newInstance(Class.java:<span class="hljs-number">383</span>)</span><br><span class="line">        at sun.font.FontManagerFactory$<span class="hljs-number">1</span>.run(FontManagerFactory.java:<span class="hljs-number">83</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:<span class="hljs-number">74</span>)</span><br><span class="line">        at java.awt.Font.getFont2D(Font.java:<span class="hljs-number">490</span>)</span><br><span class="line">        at java.awt.Font.access$<span class="hljs-number">000</span>(Font.java:<span class="hljs-number">224</span>)</span><br><span class="line">        at java.awt.Font$FontAccessImpl.getFont2D(Font.java:<span class="hljs-number">228</span>)</span><br><span class="line">        at sun.font.FontUtilities.getFont2D(FontUtilities.java:<span class="hljs-number">180</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:<span class="hljs-number">645</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:<span class="hljs-number">806</span>)</span><br><span class="line">        at sun.java2d.pipe.GlyphListPipe.drawString(GlyphListPipe.java:<span class="hljs-number">50</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.drawString(SunGraphics2D.java:<span class="hljs-number">2887</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>结合源码发现，应该是无法获取到字体导致的异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphics.setFont(new Font(&quot;Default&quot;, Font.PLAIN, fsize));</span><br></pre></td></tr></table></figure><p>由于代码没有做出过变更，所以毫无疑问，应该是环境的问题了。</p><p>于是我进入Dokcer容器查看相关字体：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it containerId bash</span><br><span class="line">fc-list</span><br></pre></td></tr></table></figure><p>发现无任何内容输出。经过一番查找，解决办法如下：</p><ol><li><p>进入容器安装字体（只能临时解决，当重新构建后，字体会丢失）</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>修改Dockerfile 在构建镜像时安装字体（会影响构建速度，安装字体比较慢）</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>更改基础镜像（推荐）</p><p>我这边出问题的容器是基于<code>tomcat:8.0-jre7-alpine</code>构建的，alpine tag的镜像比较小，比较干净。</p><p>我到docker hub上找到了类似的镜像，<code>slim</code> tag的。</p><p>修改Dockerfile，将<code>FROM tomcat:8.0-jre7-alpine</code> 改为 <code>FROM tomcat:8.0-jre7-slim</code>即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker随记" scheme="https://qmbb.top/categories/Docker%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://qmbb.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>为什么苹果不自己制造芯片</title>
    <link href="https://qmbb.top/archives/52360944.html"/>
    <id>https://qmbb.top/archives/52360944.html</id>
    <published>2019-09-20T02:01:43.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？</p><a id="more"></a><p>原来业内习惯把半导体行业的公司分为三类：</p><p>fabless（无晶圆芯片设计厂）：这样的公司只设计芯片，不自己制造芯片。最大的fabless企业有高通、博通、AMD、联发科、搭上人工智能这波热点最近火的不行的Nvidia等等。国内的fabless企业有收购了展讯和锐迪科的清华紫光、华为海思等。<br>Foundry（代工厂）：这样的公司专门为别人制造芯片。最大的Foundry企业有台积电（TSMC）、GlobalFoundry、UMC等。国内最大的是中芯国际。随着工艺进步到20nm以下，从平面晶体管向三维FinFET演化，新一代工艺所需要的投资越来越大，已经只有少数几个玩家能玩得起了（台积电、三星、Intel）。国内的中芯国际跟台积电有几代的差距。中芯国际目前商用的最先进工艺是28nm，台积电16nm已经大规模商用，7nm也马上就要用起来。<br>IDM（制造垂直整合）：这样的公司既设计芯片，也自己制造芯片。最大的有Intel和三星。</p><p>这样做的好处是，分担风险，苹果不用花费巨大投资建立生产线，因此轻资产，灵活性高，可以对市场快速反应，活力足。</p><p>再说另外一个问题，为什么主流的手机处理器厂商中很少见到英特尔呢？<br>首先提一下CPU的简单构成：ALU（算术逻辑单元）、控制单元、寄存器<br>控制单元通过时钟控制着指令执行的节奏，将指令加载存放在寄存器、并通过ALU计算。<br>这里提到了指令，指令基本上分为两类：RISC（精简指令集） 、CISC （复杂指令集），指令越复杂意味着能耗越高，试想一下，在目前手机电池技术还未突破的情况下，手机CPU会上CISC吗？<br>上面说的两个指令集的典型代表就是ARM和x86，ARM是目前主流的手机CPU架构，也就是精简指令。而x86才是英特尔等厂商的强项。<br>也许是英特尔出于战略考虑放弃了移动处理器这块蛋糕，或者说英特尔没有意料到这块蛋糕这么大。不过，目前App背后对应的还是各种Server，Server离不开x86。</p><p>参考资料：<br><a href="https://www.zhihu.com/question/68283951/answer/262481048" target="_blank" rel="noopener">https://www.zhihu.com/question/68283951/answer/262481048</a><br><a href="https://www.zhihu.com/question/20148756" target="_blank" rel="noopener">https://www.zhihu.com/question/20148756</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://qmbb.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>golang写文件异常invalid argument</title>
    <link href="https://qmbb.top/archives/848ae75e.html"/>
    <id>https://qmbb.top/archives/848ae75e.html</id>
    <published>2019-09-11T07:10:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="hljs-number">0644</span>)</span><br><span class="line"><span class="hljs-keyword">defer</span> dst.Close()</span><br><span class="line">n, err := dst.Write(buffer.Buffer[<span class="hljs-number">0</span>:n])</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是一段很简单的代码，但是在频繁调用的时候报错了了:<code>invalid argument</code></p><p>这个错误着实太误导人了，让我以为是使用的姿势不对，后来发现没有问题，于是开始debug，后来在下面一段代码中发现了真正的问题：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateFile</span><span class="hljs-params">(name *<span class="hljs-keyword">uint16</span>, access <span class="hljs-keyword">uint32</span>, mode <span class="hljs-keyword">uint32</span>, sa *SecurityAttributes, createmode <span class="hljs-keyword">uint32</span>, attrs <span class="hljs-keyword">uint32</span>, templatefile <span class="hljs-keyword">int32</span>)</span> <span class="hljs-params">(handle Handle, err error)</span></span> &#123;</span><br><span class="line">r0, _, e1 := Syscall9(procCreateFileW.Addr(), <span class="hljs-number">7</span>, <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(name)), <span class="hljs-keyword">uintptr</span>(access), <span class="hljs-keyword">uintptr</span>(mode), <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(sa)), <span class="hljs-keyword">uintptr</span>(createmode), <span class="hljs-keyword">uintptr</span>(attrs), <span class="hljs-keyword">uintptr</span>(templatefile), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span><br><span class="line">handle = Handle(r0)</span><br><span class="line"><span class="hljs-keyword">if</span> handle == InvalidHandle &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> e1 != <span class="hljs-number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">err = errnoErr(e1)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">err = EINVAL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出了真正的原因：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = errnoErr(e1)//这个地方给出了真正的错误：ERROR_SHARING_VIOLATION (32)</span><br></pre></td></tr></table></figure><p>查询微软<a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-文档，" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-文档，</a></p><p>这个错误是因为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The process cannot access the file because it is being used by another process.</span><br></pre></td></tr></table></figure><p>也就是说，在OpenFile一个文件的时候，之前使用的这个文件的file descriptor 并真正没有释放，所以出错了。</p><p>而Golang上层的错误并没有给出明确的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight go hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dst, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, &lt;span class=&quot;hljs-number&quot;&gt;0644&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;defer&lt;/span&gt; dst.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n, err := dst.Write(buffer.Buffer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:n])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://qmbb.top/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://qmbb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>跟着B站学Golang(admin-ep-saga)</title>
    <link href="https://qmbb.top/archives/f11de5dd.html"/>
    <id>https://qmbb.top/archives/f11de5dd.html</id>
    <published>2019-09-05T08:50:12.000Z</published>
    <updated>2019-10-16T09:05:40.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文完全出于学习的目的，如有异议，请联系删除。</p></blockquote><p>之前XL事件流出的优秀代码太多了，这次选择的是一个好像与具体业务无关的模块(admin-ep-saga)来进行学习。</p><a id="more"></a><p>首先看看目录结构：</p><p><img src="/archives/f11de5dd/1.png" alt="目录结构"></p><p>这么多先看哪一个呢？在不知道具体每个包是干什么的情况下，只好一个一个的看了。</p><p>先看看<code>api</code>下有些什么：</p><p><img src="/archives/f11de5dd/2.png" alt="api"></p><p>不得不说这个目录的结构相当规范呀，虽然我没有点开具体文件，但是仅仅从目录名和文件名就能猜出这个目录下是干什么的：</p><p>应该是使用了grpc框架和protobuf协议定义的接口。这个暂时先放一边，我需要先找到<strong>程序入口</strong>，这样才能一步一步的学习优秀代码是如何编写的。</p><p>接下来打开<code>cmd</code>:</p><p><img src="/archives/f11de5dd/3.png" alt="cmd"></p><p>这个目录下有三个文件：</p><ol><li><code>BUILD</code>看着应该是用来做构建用的，这不是我这次学习的重点，先跳过。</li><li><code>saga-admin-test.toml</code> 我打开看了一眼，是一个配置文件，从名字可以看出应该是测试用的配置项，后面还会碰到。</li><li><code>main.go</code> 如果不出意外，这个应该就是<strong>程序入口</strong>了，运气还不错，第二个目录就找到了入口。</li></ol><p>接下来详细的看看main.go做了些什么事情：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">这里我忽略了一些包导入，以及一些常量</span></span><br><span class="line"><span class="hljs-comment">因为如果每个导入的包都要看的话，会越陷越深。</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line">    <span class="hljs-comment">//初始化配置</span></span><br><span class="line"><span class="hljs-keyword">if</span> err := conf.Init(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="hljs-string">"conf.Init() error(%v)"</span>, err)</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//初始化Log</span></span><br><span class="line">log.Init(conf.Conf.Log)</span><br><span class="line"><span class="hljs-keyword">defer</span> log.Close()</span><br><span class="line">log.Info(<span class="hljs-string">"saga-admin start"</span>)</span><br><span class="line"><span class="hljs-comment">//启动一个服务</span></span><br><span class="line">s := service.New()</span><br><span class="line">http.Init(s)</span><br><span class="line">    <span class="hljs-comment">//启动一个grpc服务</span></span><br><span class="line">grpcsvr, err := grpc.New(<span class="hljs-literal">nil</span>, s.Wechat())</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//创建一个长度为1的os.Signal类型的channel</span></span><br><span class="line">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-comment">//通知</span></span><br><span class="line">signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"><span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//从前面创建的channel中读取signal</span></span><br><span class="line">si := &lt;-c</span><br><span class="line">log.Info(<span class="hljs-string">"saga-admin get a signal %s"</span>, si.String())</span><br><span class="line"><span class="hljs-keyword">switch</span> si &#123;</span><br><span class="line">        <span class="hljs-comment">//如果是SIGQUIT、SIGTERM、SIGINT则关闭相关服务，然后退出</span></span><br><span class="line"><span class="hljs-keyword">case</span> syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:</span><br><span class="line">grpcsvr.Shutdown(context.Background())</span><br><span class="line">log.Info(<span class="hljs-string">"saga-admin exit"</span>)</span><br><span class="line">s.Close()</span><br><span class="line">time.Sleep(_durationForClosingServer * time.Second)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line"><span class="hljs-keyword">case</span> syscall.SIGHUP:</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略的看了一下代码后，带着疑问，一行一行的来分析，首先第一行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure><p>作为Golang小白，我知道这个应该是使用在<code>flag.StringVar</code>这样的代码后面，定义需要获取的命令行参数。</p><p>但是<code>flag.Parse()</code>作为第一行代码前面并没有<code>flag.StringVar</code>类似这样的代码呀，然后我想到了Golang中<code>init</code>函数的作用。于是我开始找<code>main.go</code>中导入的其他包中有没有定义init函数，果不其然，在<code>saga/conf/conf.go</code>中我找到了：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//定义一个命令行参数，用来接收配置文件路径</span></span><br><span class="line">flag.StringVar(&amp;confPath, <span class="hljs-string">"conf"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"config path"</span>)</span><br><span class="line">    <span class="hljs-comment">//这个reload后面再讲</span></span><br><span class="line">reload = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>, <span class="hljs-number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>main.go</code>来看下面几行代码：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> err := conf.Init(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">    log.Error(<span class="hljs-string">"conf.Init() error(%v)"</span>, err)</span><br><span class="line">    <span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略错误判断以及日志打印，我们可以看到这几行中最关键的代码就是<code>conf.Init()</code>，这个代码做了些什么事情呢？接下来进入<code>saga/conf/conf.go</code>：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//判断如果配置文件的路径为空，则执行configCenter()方法</span></span><br><span class="line"><span class="hljs-keyword">if</span> confPath == <span class="hljs-string">""</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> configCenter()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//如果配置文件路径不为空通过toml.DecodeFile(confPath, &amp;Conf)解析配置到&amp;Conf中</span></span><br><span class="line"><span class="hljs-keyword">if</span> _, err = toml.DecodeFile(confPath, &amp;Conf); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="hljs-string">"toml.DecodeFile(%s) err(%+v)"</span>, confPath, err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//单独解析TeamInfo相关配置</span></span><br><span class="line">Conf = parseTeamInfo(Conf)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> confPath == <span class="hljs-string">""</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> configCenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数名可以看出，当没有手动指定配置文件路径是，走配置中心解析配置。<code>configCenter</code>我们先放一放，我们接着往下看：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> _, err = toml.DecodeFile(confPath, &amp;Conf); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="hljs-string">"toml.DecodeFile(%s) err(%+v)"</span>, confPath, err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟之前一样，我们忽略错误和日志处理，可以看到这几行关键代码是<code>toml.DecodeFile(confPath, &amp;Conf)</code>，</p><p><code>toml</code>这个看着是不是很眼熟，之前在<code>cmd</code>包下我们看到过一个这个格式的文件<code>saga-admin-test.toml</code>，这是一个由GitHub联合创始人Tom Preston-Werner 搞出的极简配置文件格式。各个语言都有相关实现，BZ这里使用的是<code>github.com/BurntSushi/toml</code>这个库。</p><p>总而言之，这几行代码无非就是解析配置文件。</p><p>继续往下看:</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conf = parseTeamInfo(Conf)</span><br></pre></td></tr></table></figure><p>单独用了一个方法来解析<code>TeamInfo</code>说明toml标准的DecodeFile解析不了，我们来看看这个方法做了什么事情：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">这个方法做的事情比较简单，直接采用注释的方法讲解</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseTeamInfo</span><span class="hljs-params">(c *Config)</span> *<span class="hljs-title">Config</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">strings.Fields，我们都知道这个是根据字符串中的空格或者一些个特殊符号来拆分字符串为Array的方法。</span></span><br><span class="line"><span class="hljs-comment">我们来看看之前提到的saga-admin-test.toml中c.Property.Department 定义的是什么：</span></span><br><span class="line"><span class="hljs-comment">[property.department]</span></span><br><span class="line"><span class="hljs-comment">        label = "主站 直播 bplus 开放平台 创作中心 商业产品 数据中心 视频云 游戏 火鸟"</span></span><br><span class="line"><span class="hljs-comment">        value = "mainsite live bplus openplatform creative advertising datacenter videocloud game firebird"</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">DeLabel := strings.Fields(c.Property.Department.Label)</span><br><span class="line">DeValue := strings.Fields(c.Property.Department.Value)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(DeLabel); i++ &#123;</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">所以这几行代码，很显而易见了，就是将上述的label 和value组合成key-value的形式然后append到另外一个(DeInfo)Array中</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">info := &amp;model.PairKey&#123;</span><br><span class="line">Label: DeLabel[i],</span><br><span class="line">Value: DeValue[i],</span><br><span class="line">&#125;</span><br><span class="line">c.Property.DeInfo = <span class="hljs-built_in">append</span>(c.Property.DeInfo, info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//下面几行代码同上，就不在赘述</span></span><br><span class="line">buLabel := strings.Fields(c.Property.Business.Label)</span><br><span class="line">buValue := strings.Fields(c.Property.Business.Value)</span><br><span class="line"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(buLabel); i++ &#123;</span><br><span class="line"></span><br><span class="line">info := &amp;model.PairKey&#123;</span><br><span class="line">Label: buLabel[i],</span><br><span class="line">Value: buValue[i],</span><br><span class="line">&#125;</span><br><span class="line">c.Property.BuInfo = <span class="hljs-built_in">append</span>(c.Property.BuInfo, info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说，上面的<code>Business</code>和<code>Department</code>处理过程一样，为啥不将这个过程提取成一个函数呢？来自小白的疑问。</p><p>还记得我们之前跳过一个函数<code>configCenter()</code>吗？接下来我们一起来看看：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">configCenter</span><span class="hljs-params">()</span> <span class="hljs-params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//这里的conf应该是BZ一个公共组件，这里做的就是创建一个配置中心的client</span></span><br><span class="line"><span class="hljs-keyword">if</span> client, err = conf.New(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//这里调用了load函数</span></span><br><span class="line"><span class="hljs-keyword">if</span> err = load(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//这里应该是添加了一个配置中心的监听</span></span><br><span class="line">client.WatchAll()</span><br><span class="line">    <span class="hljs-comment">//起一个goroute</span></span><br><span class="line"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-comment">//获取事件，如果配置中心的配置存在修改重新调用load函数</span></span><br><span class="line"><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> client.Event() &#123;</span><br><span class="line">log.Info(<span class="hljs-string">"config reload"</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> load() != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="hljs-string">"config reload error (%v)"</span>, err)</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//load成功往reload chan写入一个数据，这里有个疑问，等后面再说</span></span><br><span class="line">reload &lt;- <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略其它代码，可以看到上面实现配置中心配置加载的应该是load函数：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> <span class="hljs-params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//定义一组局部变量</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">s       <span class="hljs-keyword">string</span></span><br><span class="line">ok      <span class="hljs-keyword">bool</span></span><br><span class="line">tmpConf *Config</span><br><span class="line">)</span><br><span class="line">    <span class="hljs-comment">//通过配置中心的client获取配置，这里的_configkey是常量："saga-admin.toml"</span></span><br><span class="line"><span class="hljs-keyword">if</span> s, ok = client.Value(_configKey); !ok &#123;</span><br><span class="line">err = errors.Errorf(<span class="hljs-string">"load config center error [%s]"</span>, _configKey)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//跟之前一样通过toml解析配置</span></span><br><span class="line"><span class="hljs-keyword">if</span> _, err = toml.Decode(s, &amp;tmpConf); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">err = errors.Wrapf(err, <span class="hljs-string">"could not decode config err(%+v)"</span>, err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//跟之前一样单独解析TeamInfo</span></span><br><span class="line">Conf = parseTeamInfo(tmpConf)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们差不多刚刚看完<code>main.go</code>中<code>conf.Init()</code>的调用，接下来回到<code>main.go</code>，继续往下看：</p><p>我们跳过Log的初始化，直接看：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//调用/saga/service中的New函数</span></span><br><span class="line">s := service.New()</span><br><span class="line"><span class="hljs-comment">//调用/saga/http中的Init函数</span></span><br><span class="line">http.Init(s)</span><br></pre></td></tr></table></figure><p>跳转到<code>New</code>函数中，我们看看做了些什么：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> <span class="hljs-params">(s *Service)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">err error</span><br><span class="line">)</span><br><span class="line">s = &amp;Service&#123;</span><br><span class="line">dao:  dao.New(),</span><br><span class="line">cron: cron.New(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncProject.CheckCron, s.collectprojectproc); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.Git.CheckCron, s.alertProjectPipelineProc); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCron, s.syncdataproc); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCronAll, s.syncalldataproc); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCronWeek, s.syncweekdataproc); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">s.cron.Start()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// init gitlab client</span></span><br><span class="line">s.gitlab = gitlab.New(conf.Conf.Property.Gitlab.API, conf.Conf.Property.Gitlab.Token)</span><br><span class="line"><span class="hljs-comment">// init online gitlab client</span></span><br><span class="line">s.git = gitlab.New(conf.Conf.Property.Git.API, conf.Conf.Property.Git.Token)</span><br><span class="line"><span class="hljs-comment">// init wechat client</span></span><br><span class="line">s.wechat = wechat.New(s.dao)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码大部分都是在做定时任务的创建，<code>cron</code>使用的是<code>&quot;github.com/robfig/cron&quot;</code>这个库，我们挑一个看看：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncProject.CheckCron, s.collectprojectproc); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>conf.Conf.Property.SyncProject.CheckCron</code> 是配置中的cron表达式，在<code>saga-admin-test.toml</code>中看到是</p><p><code>* */15 * * * ?</code>也就是说这个任务每15分钟执行一次。</p><p><code>s.collectprojectproc</code> 是要执行的任务，接下来看看这个任务做了什么事情：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Service)</span> <span class="hljs-title">collectprojectproc</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> err error</span><br><span class="line">    <span class="hljs-comment">//可以看到实际调用的是CollectProject，这里的context.TODO()表示context还未实现，这里仅仅用作占位，没有实际意义</span></span><br><span class="line"><span class="hljs-keyword">if</span> err = s.CollectProject(context.TODO()); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="hljs-string">"s.CollectProject err (%+v)"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Service)</span> <span class="hljs-title">CollectProject</span><span class="hljs-params">(c context.Context)</span> <span class="hljs-params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//这是一组局部变量</span></span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">projects []*gitlab.Project</span><br><span class="line">total    = <span class="hljs-number">0</span></span><br><span class="line">page     = <span class="hljs-number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">log.Info(<span class="hljs-string">"Collect Project start"</span>)</span><br><span class="line">    <span class="hljs-comment">//这里出现了一个magic number，1000</span></span><br><span class="line"><span class="hljs-keyword">for</span> page &lt;= <span class="hljs-number">1000</span> &#123;</span><br><span class="line"><span class="hljs-comment">//调用gitlab接口获取指定页码的项目列表，这里的s.gitlab是在service.New()中实例化的。这里有一个疑问。</span></span><br><span class="line"><span class="hljs-keyword">if</span> projects, err = s.gitlab.ListProjects(page); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num := <span class="hljs-built_in">len</span>(projects)</span><br><span class="line"><span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">0</span> &#123;</span><br><span class="line"><span class="hljs-keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">total = total + num</span><br><span class="line"><span class="hljs-comment">//将获取到的项目保存到db中，这个insertDB就不展开讲了，这里面做的大概就是saveOrUpdate的事情。</span></span><br><span class="line"><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> projects &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> err = s.insertDB(p); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = page + <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="hljs-string">"Collect Project end, find %d projects"</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service.New()</code>中其他的cron也差不多是做着类似的事情，由于太多，就不在这里一一展开。刚刚说到</p><p><code>s.gitlab.ListProjects(page);</code>我有一个疑问，是什么呢？我们看这里：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.cron.Start()</span><br><span class="line"><span class="hljs-comment">// init gitlab client</span></span><br><span class="line">s.gitlab = gitlab.New(conf.Conf.Property.Gitlab.API, conf.Conf.Property.Gitlab.Token)</span><br><span class="line"><span class="hljs-comment">// init online gitlab client</span></span><br><span class="line">s.git = gitlab.New(conf.Conf.Property.Git.API, conf.Conf.Property.Git.Token)</span><br><span class="line"><span class="hljs-comment">// init wechat client</span></span><br><span class="line">s.wechat = wechat.New(s.dao)</span><br></pre></td></tr></table></figure><p>可以发现cron的start是在gitlab、git、wechat实例化之前，而cron相关的任务中又依赖了这些client，那有没有这么一种可能：这个程序启动的时候正好碰上cron触发，而gitlab，wechat这些client还没有实例化，所以有没有可能出现panic？当然了，这个可能性很小。</p><p>让我们再次回到main.go中：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//初始化一个http服务</span></span><br><span class="line">http.Init(s)</span><br></pre></td></tr></table></figure><p>进入<code>Init</code>:</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Init init</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">(s *service.Service)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">//这个srv很重要，这是在上面service.New()最后返回的实例，在后面经常用到</span></span><br><span class="line">srv = s</span><br><span class="line">    <span class="hljs-comment">//这个permit是go-common/library/net/http/blademaster 中的组件，应该是用来做接口认证的</span></span><br><span class="line">authSvc = permit.New2(<span class="hljs-literal">nil</span>)</span><br><span class="line"><span class="hljs-comment">//下面就是启动http engine了，这个engine就是上面提到的这个blademaster</span></span><br><span class="line">engine := bm.DefaultServer(conf.Conf.BM)</span><br><span class="line">engine.Ping(ping)</span><br><span class="line">initRouter(engine)</span><br><span class="line"><span class="hljs-keyword">if</span> err := engine.Start(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="hljs-string">"engine.Start error(%v)"</span>, err)</span><br><span class="line"><span class="hljs-built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个http服务是依赖的BZ公共的组件，就不继续深入了，我怕出不来了。我们看看<code>initRouter</code>中定义的Router，由于太长，我只选择开始一段：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version := e.Group(<span class="hljs-string">"/ep/admin/saga/v1"</span>, authSvc.Permit2(<span class="hljs-string">""</span>))</span><br><span class="line">&#123;</span><br><span class="line">project := version.Group(<span class="hljs-string">"/projects"</span>)</span><br><span class="line">&#123;</span><br><span class="line">project.GET(<span class="hljs-string">"/favorite"</span>, favoriteProjects)</span><br><span class="line">project.POST(<span class="hljs-string">"/favorite/edit"</span>, editFavorite)</span><br><span class="line">project.GET(<span class="hljs-string">"/common"</span>, queryCommonProjects)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是很常见的url-mapping了，这里的<code>favoriteProjects</code>、<code>editFavorite</code>、<code>queryCommonProjects</code> 都是定义在当前<code>http</code>包下的函数，我们选择<code>favoriteProjects</code>看下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">favoriteProjects</span><span class="hljs-params">(ctx *bm.Context)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> (</span><br><span class="line">req      = &amp;model.Pagination&#123;&#125;</span><br><span class="line">err      error</span><br><span class="line">userName <span class="hljs-keyword">string</span></span><br><span class="line">)</span><br><span class="line">    <span class="hljs-comment">//这里应该是解析请求参数到req变量中</span></span><br><span class="line"><span class="hljs-keyword">if</span> err = ctx.Bind(req); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="hljs-literal">nil</span>, err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//这里是调用函数获取当前用户名</span></span><br><span class="line"><span class="hljs-keyword">if</span> userName, err = getUsername(ctx); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="hljs-literal">nil</span>, err)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//我们看到这里最终回到了srv上，调用了实际的处理方法。这里的FavoriteProjects实际就是通过db查询当前用户收藏的项目，我们就不继续深入了。</span></span><br><span class="line">ctx.JSON(srv.FavoriteProjects(ctx, req, userName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的流程大概是这样的，首先在<code>http</code>包中将参数等一些信息进行解析，最后调用到了<code>service</code>中的方法。这个就很像Java中流行的写法：从<code>Controller</code>到<code>Service</code>，符合<code>MVC</code>分层的思想。</p><p>最后还有一个grpc，我大概看了下，应该是用来企业微信发消息的。</p><p>总结：</p><p>这应该是用来做gitlab ci告警之类的project，可以看到这个project层次很分明，代码看过去一目了然。</p><p>最后，之前还有一个疑问，就是<code>reload</code>这个变量，在初始化时是有长度的：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>, <span class="hljs-number">10</span>)</span><br></pre></td></tr></table></figure><p>长度为10，在每次配置文件修改后，goroute watch到event之后会往这个channel写入一个<code>true</code>，但是看完整个代码之后，并没有看到有地方从这个channel取出数据（也有可能是我漏看了），也就是说当修改10次之后，这个地方：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload &lt;- <span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>就会阻塞，从而导致这个goroute无响应？</p><p>码字不易，且转且珍惜。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文完全出于学习的目的，如有异议，请联系删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前XL事件流出的优秀代码太多了，这次选择的是一个好像与具体业务无关的模块(admin-ep-saga)来进行学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://qmbb.top/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://qmbb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一张图说明Golang的并发模型MPG</title>
    <link href="https://qmbb.top/archives/79f4a57c.html"/>
    <id>https://qmbb.top/archives/79f4a57c.html</id>
    <published>2019-09-04T03:10:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 天生支持并发，Goroutine是Go 最吸引人的地方，采用的是CSP并发通信模型。到底Go是怎么支持高并发的呢？这里就需要说一说Golang 的MPG模型。</p><a id="more"></a><ol><li><strong>M</strong> 代表着一个内核线程 ，一个M就是一个内核线程，goroutine就是跑在M之上的</li><li><strong>P</strong> 代表着(Processor)处理器， 它的主要用途就是用来执行goroutine的，所以它也维护了一个可运行的goroutine队列，和自由的goroutine队列，里面存储了所有需要它来执行的goroutine。</li><li><strong>G</strong> 代表着goroutine 实际的数据结构，并维护者goroutine 需要的栈、程序计数器以及它所在的M等信息。</li><li><strong>Sched</strong> 代表着一个调度器 它维护有存储空闲的M队列和空闲的P队列，可运行的G队列，自由的G队列以及调度器的一些状态信息等。</li></ol><p>一张图就可以说明MPG模型：</p><p><img src="/archives/79f4a57c/1.jpg" alt="MPG"></p><p>图中的“土拨鼠”代表的就是<strong>M</strong>，“推车”代表的是<strong>P</strong>，“木块”代表的就是<strong>G</strong>。在这张图外还存在一个特殊的”土拨鼠“这个”土拨鼠“就是”包工头“<strong>Sched</strong>。</p><p><img src="/archives/79f4a57c/2.png" alt="Sched"></p><p>从图中我们可以看到“土拨鼠“不停地将“木块“搬运到“推车“上，然后推去烧。在这个过程中可能出现“土拨鼠“因为累坏了，而处理的速度变慢的情况，这个时候“包工头“就出现了，“包工头“非常体贴的将这个“土拨鼠“的“推车“交给其他“土拨鼠“去处理。如果一个“土拨鼠“的“推车“里面的“木块“装的太多，“包工头“也会让其它的“土拨鼠“去帮忙拿出一些来。当“包工头“发现现有的“土拨鼠“已经忙不过来的时候，就回去找一些新的“土拨鼠“过来，并给他们配发“推车“。直到所有的“木块“都烧完为止。</p><p>上面说到的几种情况：</p><ol><li>“土拨鼠”累坏了，形容的是IO等耗时的操作。</li><li>其他“土拨鼠”帮忙，形容的是工作窃取算法（work stealing），这个算法在很多语言中都有应用，例如Java中的Fork/Foin。</li></ol><p>在Golang中土拨鼠默认的数量是CPU的核数，土拨鼠通过CSP模型沟通。</p><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/22352969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22352969</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 天生支持并发，Goroutine是Go 最吸引人的地方，采用的是CSP并发通信模型。到底Go是怎么支持高并发的呢？这里就需要说一说Golang 的MPG模型。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://qmbb.top/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://qmbb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go Module 引入本地自定义包</title>
    <link href="https://qmbb.top/archives/c8d527a1.html"/>
    <id>https://qmbb.top/archives/c8d527a1.html</id>
    <published>2019-09-04T02:20:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载至 <a href="http://www.r9it.com/20190611/go-mod-use-dev-package.html#1-启用-go-module" target="_blank" rel="noopener">小一辈无产阶级码农</a></p></blockquote><p>最近由于项目要求，需要对 <code>IPFS</code> 源码进行修改，由于自己在此之前没有接触过 Go 语言，在使用 <code>go mod</code> 导入本地自己开发的工具包的时候折腾了好久才搞定。 记录一下，以备后期查阅。 Go 语言的 Module 新特性是在 go1.11 的发布之后才支持的，这是 Go 语言新的一套依赖管理系统。</p><a id="more"></a><p>文章导读</p><ul><li><a href="#1-启用-Go-Module">1. 启用 Go Module</a></li><li><a href="#2-创建-Go-Module">2. 创建 Go Module</a></li><li><a href="#3-Go-Module-版本规则">3. Go Module 版本规则</a></li><li><a href="#4-引入本地依赖包">4. 引入本地依赖包</a></li><li><a href="#5-使用-replace-将远程包替换为本地包服务">5. 使用 replace 将远程包替换为本地包服务</a></li></ul><h1 id="1-启用-Go-Module"><a href="#1-启用-Go-Module" class="headerlink" title="1. 启用 Go Module"></a>1. 启用 Go Module</h1><p>首先在默认情况下，<code>$GOPATH</code> 默认情况下是不支持 go mudules 的，当你执行 <code>go mod init</code> 的时候会遇到如下错误：</p><blockquote><p>go: modules disabled inside GOPATH/src by GO111MODULE=auto; see ‘go help modules’</p></blockquote><p>我们需要在执行 <code>go mod</code> 命令之前，导出 <code>GO111MODULE</code> 环境变量，你可以直接临时一次性导出， 为了后面方便，建议直接在 <code>~/.bashrc</code> 文件中导出， 在文件末尾加入：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure><p>Bash</p><p>从这也表明了 go 将来是要利用 modules 机制去消灭 <code>$GOPATH</code> 的。</p><h1 id="2-创建-Go-Module"><a href="#2-创建-Go-Module" class="headerlink" title="2. 创建 Go Module"></a>2. 创建 Go Module</h1><p>我们现在 <code>$GOPATH</code> 下面先创建一个项目，并初始化 module</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $GOPATH/src/gitee.com/rockyang/testmod -p</span><br><span class="line">cd $GOPATH/src/gitee.com/rockyang/test-gomod</span><br><span class="line">go mod init gitee.com/rockyang/test-gomod</span><br><span class="line">go: creating new go.mod: module gitee.com/rockyang/testmod</span><br></pre></td></tr></table></figure><p>Bash</p><p>这时，我们新建的项目已经成为了一个 module 了，我们可以在项目中随便写几个函数导出测试。</p><p>Note: 我这里使用的是<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>做项目托管，没有使用 github，国内码云确实比 github 快得多。</p><p>接下来你可以选择把项目推送到远程仓库，如果你的仓库是公开的话，别人就是可以直接使用 <code>go get</code> 命令去下载你的项目了。</p><p>如果是私有项目只想给内部使用，则你可以参考我的这篇博客的做法。<a href="http://www.r9it.com/21090611/go-mod-use-private-package.html" target="_blank" rel="noopener">Go Module 使用私有仓库作为项目依赖包</a></p><h1 id="3-Go-Module-版本规则"><a href="#3-Go-Module-版本规则" class="headerlink" title="3. Go Module 版本规则"></a>3. Go Module 版本规则</h1><p>go modules 是一个版本化依赖管理系统，版本需要遵循一些规则，打开一个 <code>go.mod</code> 文件，你会发现类似下面的依赖规则：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">github.com/filecoin-project/go-leb128 v0.0.0-20190212224330-8d79a5489543</span><br><span class="line">github.com/golang/mock v1.2.0 // indirect</span><br><span class="line">github.com/ipfs/go-bitswap v0.0.2</span><br><span class="line">github.com/libp2p/go-stream-muxer v0.0.1</span><br><span class="line">github.com/minio/blake2b-simd v0.0.0-20160723061019-3f5f724cb5b1</span><br><span class="line">gotest.tools v2.2.0+incompatible // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Bash</p><p>依赖规则由两个部分组成，前面一部分是包路径，后面一部分表示的是版本号。 你会发现有两种版本号，一种是我们很熟悉的 git 标签，比如 <code>v0.0.2</code>，另一种就比较复杂一些，它是：<strong>版本号 + 时间戳 +hash</strong> 比如：<code>v0.0.0-20190212224330-8d79a5489543</code>，它其实是精准的对应着一个 <code>git log</code> 记录，后面的哈希是去提交哈希的前 12 位。</p><p>比如我当前的提交记录是这样的：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> git log </span><br><span class="line">commit 4c55783279db32be4f02e193713d5a862b96db85 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: yangjian &lt;yangjian102621@gmail.com&gt;</span><br><span class="line">Date:   Mon Jun 10 18:34:14 2019 +0800</span><br></pre></td></tr></table></figure><p>Bash</p><p>则我的最新版本号应该为 <code>v0.0.0-20190610103414-4c55783279db</code></p><h1 id="4-引入本地依赖包"><a href="#4-引入本地依赖包" class="headerlink" title="4. 引入本地依赖包"></a>4. 引入本地依赖包</h1><p>前面铺垫了这么多，接下来回到我们的主题，我该怎样使用我们自己开发的工具包呢？ 假设我们有一个新的项目 <code>testmod-demo</code>，现在想要在新的项目中使用 testmod 中的工具包，那么首先我们需要使用 <code>go mod</code> 初始化该项目：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd testmod-demo</span><br><span class="line">go mod init gitee.com/rockyang/testmod-demo</span><br></pre></td></tr></table></figure><p>Bash</p><p>初始化之后会在当前项目根目录生成一个 <code>go.mod</code>，接下来我们有两种方式去引入 testmod 包，一种是直接修改 <code>go.mod</code> 文件，在 require 配置中添加上</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitee.com/rockyang/testmod v0.0.0-20190610103414-4c55783279db</span><br></pre></td></tr></table></figure><p>Bash</p><p>或者使用 <code>go mod edit</code> 命令修改依赖</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require="gitee.com/rockyang/testmod@v0.0.0-20190610103414-4c55783279db"</span><br><span class="line">go mod tidy # 整理依赖包</span><br></pre></td></tr></table></figure><p>Bash</p><h1 id="5-使用-replace-将远程包替换为本地包服务"><a href="#5-使用-replace-将远程包替换为本地包服务" class="headerlink" title="5. 使用 replace 将远程包替换为本地包服务"></a>5. 使用 replace 将远程包替换为本地包服务</h1><p>这时如果你执行 <code>go build</code> 的时候会报错，提示找不到 <code>gitee.com/rockyang/testmod</code>，是因为你没有把仓库推送到远程，所以无法下载。 go module 提供了另外一个方案, 使用 replace, 编辑 go.mod 文件，在最后面添加：<code>replace gitee.com/rockyang/testmod =&gt; /gopath/src/gitee.com/rockyang/testmod</code></p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module gitee.com/rockyang/testmod-demo</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gin-gonic/gin v1.3.0</span><br><span class="line">gitee.com/rockyang/testmod@v0.0.0-20190610103414-4c55783279db</span><br><span class="line">    golang.org/x/net v0.0.0-20190320064053-1272bf9dcd53 // indirect</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace gitee.com/rockyang/testmod =&gt; /gopath/src/gitee.com/rockyang/testmod</span><br></pre></td></tr></table></figure><p>Bash</p><blockquote><p>这里的 /gopath/src/gitee.com/rockyang/testmod 是本地的包路径</p></blockquote><p>然后再执行 <code>go build</code> 你会看到你想要的结果。</p><hr><p>以上为原作者原文，转载这篇文章的原因是因为Golang1.13发布了，看到了其中一个新特新<a href="https://tip.golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules" target="_blank" rel="noopener"><code>GOPRIVATE</code></a> 可以搭配 <a href="https://tip.golang.org/cmd/go/#hdr-Module_downloading_and_verification" target="_blank" rel="noopener"><code>GOPROXY</code></a> 对私有模块更细粒度的控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章转载至 &lt;a href=&quot;http://www.r9it.com/20190611/go-mod-use-dev-package.html#1-启用-go-module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小一辈无产阶级码农&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近由于项目要求，需要对 &lt;code&gt;IPFS&lt;/code&gt; 源码进行修改，由于自己在此之前没有接触过 Go 语言，在使用 &lt;code&gt;go mod&lt;/code&gt; 导入本地自己开发的工具包的时候折腾了好久才搞定。 记录一下，以备后期查阅。 Go 语言的 Module 新特性是在 go1.11 的发布之后才支持的，这是 Go 语言新的一套依赖管理系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://qmbb.top/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://qmbb.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Python实现图像文字识别</title>
    <link href="https://qmbb.top/archives/99680cca.html"/>
    <id>https://qmbb.top/archives/99680cca.html</id>
    <published>2019-09-03T08:46:36.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>使用的实际是tesseract这个OCR引擎。如果识别的有中文，需要添加中文的<a href="https://github.com/tesseract-ocr/tessdata/raw/4.00/chi_sim.traineddata" target="_blank" rel="noopener">chi_sim.traineddata</a>。</p><p>我这里使用的是windows，下载是<a href="http://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe" target="_blank" rel="noopener">Windows Installer made with MinGW-w64</a>，在安装过程中注意有个选项，展开可以看到各种语言的数据，勾上chi_sim.traineddata即可。</p><a id="more"></a><p>我这里使用的是Python3.7，首先安装必备的依赖</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pillow</span><br></pre></td></tr></table></figure><p>我使用的Pycharm，直接Alt+Enter导入。</p><p>完整的代码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pytesseract</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image = Image.open(&quot;../pic/c.png&quot;)</span><br><span class="line">code = pytesseract.image_to_string(image,lang=&quot;chi_sim&quot;,config=&quot;-psm 6&quot;)</span><br><span class="line">print(code)</span><br></pre></td></tr></table></figure><p>直接运行可能会报错，会提示<code>tesseract</code>识别不了，我看到其他人都是直接修改pytesseract源文件</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract_cmd = &apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos;</span><br></pre></td></tr></table></figure><p>我这里的做法是将<code>C:\Program Files (x86)\Tesseract-OCR\</code>添加到环境变量PATH中。</p><p>有可能不会生效，需要重启Pycharm。</p><p>OCR识别不是100%准确，我这里测试的结果是，可能会多或者少一些字符。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/github_33304260/article/details/79155154" target="_blank" rel="noopener">https://blog.csdn.net/github_33304260/article/details/79155154</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用的实际是tesseract这个OCR引擎。如果识别的有中文，需要添加中文的&lt;a href=&quot;https://github.com/tesseract-ocr/tessdata/raw/4.00/chi_sim.traineddata&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chi_sim.traineddata&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我这里使用的是windows，下载是&lt;a href=&quot;http://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows Installer made with MinGW-w64&lt;/a&gt;，在安装过程中注意有个选项，展开可以看到各种语言的数据，勾上chi_sim.traineddata即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Python随记" scheme="https://qmbb.top/categories/Python%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://qmbb.top/tags/Python/"/>
    
      <category term="OCR" scheme="https://qmbb.top/tags/OCR/"/>
    
  </entry>
  
  <entry>
    <title>Python中的一些语法糖</title>
    <link href="https://qmbb.top/archives/d5c5a3fa.html"/>
    <id>https://qmbb.top/archives/d5c5a3fa.html</id>
    <published>2019-09-03T02:14:31.000Z</published>
    <updated>2019-10-16T09:05:40.009Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>三元运算符</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a if a&gt;b else b</span><br></pre></td></tr></table></figure><p>在Java中的写法为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a&gt;b ? a : b</span><br></pre></td></tr></table></figure><p>而Golang则是不支持</p><a id="more"></a></li><li><p>循环</p><p>Python中常用的while、for</p><p>Java中支持while、do…while、for、foreach</p><p>Golang 万能的for，for range in</p><p>​    语句</p><p>Python还支持循环else，while …else 、for …else ,表示循环正常结束后执行的代码块。</p></li><li><p>切片(slice)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;abcdefg&quot;</span><br><span class="line">print(str1[0])</span><br><span class="line">print(str1[0:3])</span><br></pre></td></tr></table></figure><p>Golang类似，Java中没有切片的概念</p></li><li><p>复制运算</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;a&apos;*5) # aaaaa</span><br><span class="line">b = [1]</span><br><span class="line">print(b*5) # [1, 1, 1, 1, 1]</span><br><span class="line"></span><br><span class="line">复制运算不支持字典dict</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;三元运算符&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c = a if a&amp;gt;b else b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Java中的写法为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c = a&amp;gt;b ? a : b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而Golang则是不支持&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Python随记" scheme="https://qmbb.top/categories/Python%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://qmbb.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker多主机容器间ping不通的问题</title>
    <link href="https://qmbb.top/archives/d7132b2f.html"/>
    <id>https://qmbb.top/archives/d7132b2f.html</id>
    <published>2019-08-28T02:54:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前记录过一个因为内核版本过低导致Docker overlay网络不通的问题。后来又遇到一个由于粗心导致的网络不通的问题。</p></blockquote><p>问题的现象是这样的，创建了overlay网络后，同一台主机上的容器间可以ping通。而不同主机上的容器ping的结果是：</p><a id="more"></a><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING zookeeper (10.0.0.3) 56(84) bytes of data.</span><br><span class="line">From 85789ac6e6a8 (10.0.0.8) icmp_seq=1 Destination Host Unreachable</span><br><span class="line">From 85789ac6e6a8 (10.0.0.8) icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 85789ac6e6a8 (10.0.0.8) icmp_seq=3 Destination Host Unreachable</span><br></pre></td></tr></table></figure><p>Google一通之后，未找到满意答案，觉得很是奇怪，灵光一现查看 etcd 上的节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl ls /docker/nodes</span><br></pre></td></tr></table></figure><p>发现只有一个：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/docker/nodes/10.208.10.14:2375</span><br></pre></td></tr></table></figure><p>后来想起来了原来在启动docker的时候，使用的命令忘了改 <strong>–cluster-advertise</strong></p><p>–cluster-advertise：告知集群当前的连接地址</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://10.208.10.14:2379 --cluster-advertise=当前host:2375 &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前记录过一个因为内核版本过低导致Docker overlay网络不通的问题。后来又遇到一个由于粗心导致的网络不通的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题的现象是这样的，创建了overlay网络后，同一台主机上的容器间可以ping通。而不同主机上的容器ping的结果是：&lt;/p&gt;
    
    </summary>
    
      <category term="Docker随记" scheme="https://qmbb.top/categories/Docker%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://qmbb.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用overlay网络遇到的问题</title>
    <link href="https://qmbb.top/archives/1c99e54f.html"/>
    <id>https://qmbb.top/archives/1c99e54f.html</id>
    <published>2019-08-27T03:04:18.000Z</published>
    <updated>2019-10-16T09:05:40.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般我们使用Overlay网络都是涉及到多台主机中的Docker容器通信问题。</p></blockquote><p>Docker Overlay 一切准备就绪后，使用docker-compose 启动容器。</p><p>在一个业务服务的容器日志里面发现无法连接的Zookeeper，错误是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.NoRouteToHostException: No route to host</span><br></pre></td></tr></table></figure><a id="more"></a><p>在容器中尝试ping 10.0.0.3 容器，发现不通：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PING zookeeper (10.0.0.3) 56(84) bytes of data.</span><br><span class="line">From 85789ac6e6a8 (10.0.0.8) icmp_seq=1 Destination Host Unreachable</span><br><span class="line">From 85789ac6e6a8 (10.0.0.8) icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 85789ac6e6a8 (10.0.0.8) icmp_seq=3 Destination Host Unreachable</span><br></pre></td></tr></table></figure><p>刚开始查询了一些资料后，以为是防火墙(CentOS7)问题，于是查看了防火墙状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>结果防火墙压根没开：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not running</span><br></pre></td></tr></table></figure><p>由于之前没有详细查看docker overlay网络的使用限制，一直以为只要docker的版本保持在1.9.1+就可以了。后来又查了下，发现还有一个限制：内核版本大于等于3.16。于是赶紧查看了下内核版本：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -r</span><br><span class="line">3.10.0-514.10.2.el7.x86_64</span><br></pre></td></tr></table></figure><p>果然内核版本低了，于是开始升级内核。</p><p>导入elrepo的key，然后安装elrepo的yum源：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><p>列出可用的内核相关包：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available</span><br></pre></td></tr></table></figure><p><img src="/archives/1c99e54f/1.png" alt></p><p>lt为长期维护版本，mt为稳定版本，可以看到最新的稳定版本为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.2.10-1.el7.elrepo</span><br></pre></td></tr></table></figure><p>开始升级内核（以后可以直接执行这句）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y --enablerepo=elrepo-kernel install kernel-ml.x86_64 kernel-ml-devel.x86_64</span><br></pre></td></tr></table></figure><p>升级完后需要重启一下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>再次查看内核：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">3.10.0-514.10.2.el7.x86_64</span><br></pre></td></tr></table></figure><p>WTF，为什么还是老的?原来是启动的时候还是默认选择了老的内核，这里需要重新设置一下启动时的默认内核：</p><p>首先查看当前都有哪些启动项：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/grub2/grub.cfg |grep menuentry</span><br><span class="line"></span><br><span class="line">menuentry &apos;CentOS Linux (5.2.10-1.el7.elrepo.x86_64) 7 (Core)&apos; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &apos;gnulinux-3.10.0-514.6.2.el7.x86_64-advanced-07151862-c2b9-45dc-bf7a-af8d2a6fa6c1&apos; &#123;</span><br><span class="line">menuentry &apos;CentOS Linux (3.10.0-514.10.2.el7.x86_64) 7 (Core)&apos; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &apos;gnulinux-3.10.0-514.6.2.el7.x86_64-advanced-07151862-c2b9-45dc-bf7a-af8d2a6fa6c1&apos; &#123;</span><br></pre></td></tr></table></figure><p>设置默认选项（需要升级为root用户）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default &apos;CentOS Linux (5.2.10-1.el7.elrepo.x86_64) 7 (Core)&apos;</span><br></pre></td></tr></table></figure><p>再次重启，重启后查看内核：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">5.2.10-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure><p>OK，内核成功升级，再次启动Docker试试（别忘了启动服务发现，我这里是ETCD）:</p><p>ETCD启动:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcd --name docker-node3 --initial-advertise-peer-urls http://10.208.10.17:2380 --listen-peer-urls http://10.208.10.17:2380 --listen-client-urls http://10.208.10.17:2379,http://127.0.0.1:2379 --advertise-client-urls http://10.208.10.17:2379 --initial-cluster-token etcd-cluster --initial-cluster docker-node1=http://10.208.10.14:2380,docker-node2=http://10.208.10.16:2380,docker-node3=http://10.208.10.17:2380 --initial-cluster-state new &amp;</span><br></pre></td></tr></table></figure><p>Docker 启动：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://10.208.10.14:2379 --cluster-advertise=10.208.10.14:2375 &amp;</span><br></pre></td></tr></table></figure><p>当所有主机都完成上述操作时，发现容器间总算可以互通了。</p><p>其他问题：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error locating sandbox id c43437e6300a0c6ea20d2d9f95bbe318e557d1eedfa585ab5218345eeef32a36: sandbox c43437e6300a0c6ea20d2d9f95bbe318e557d1eedfa585ab5218345eeef32a36 not found</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not get network sandbox (oper true): failed get network namespace &quot;&quot;</span><br></pre></td></tr></table></figure><p>最好删除之前创建的network和container，否则可能出现其他问题。</p><p>不同主机上的容器间使用hostname或者container name通信好像有问题，可以使用docker swarm来解决。</p><p>参考资料：</p><p><a href="https://www.centos.bz/2017/08/upgrade-centos-7-6-kernel-to-4-12-4/" target="_blank" rel="noopener">https://www.centos.bz/2017/08/upgrade-centos-7-6-kernel-to-4-12-4/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一般我们使用Overlay网络都是涉及到多台主机中的Docker容器通信问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker Overlay 一切准备就绪后，使用docker-compose 启动容器。&lt;/p&gt;
&lt;p&gt;在一个业务服务的容器日志里面发现无法连接的Zookeeper，错误是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.net.NoRouteToHostException: No route to host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Docker随记" scheme="https://qmbb.top/categories/Docker%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://qmbb.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>深入开源框架底层之ASM</title>
    <link href="https://qmbb.top/archives/58ee9111.html"/>
    <id>https://qmbb.top/archives/58ee9111.html</id>
    <published>2019-08-22T01:18:55.000Z</published>
    <updated>2019-10-16T09:05:40.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-ASM-？"><a href="#什么是-ASM-？" class="headerlink" title="什么是 ASM ？"></a>什么是 ASM ？</h3><p>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p><a id="more"></a><h3 id="为什么要动态生成-Java-类？"><a href="#为什么要动态生成-Java-类？" class="headerlink" title="为什么要动态生成 Java 类？"></a>为什么要动态生成 Java 类？</h3><p>想象一下，如果开源框架要求你添加各种Java类来实现诸如log、cache、transaction等功能，我想这个开源框架你肯定不会用吧。动态生成类可以减少对你代码的侵入，提高使用者的效率。</p><h3 id="为什么选择ASM？"><a href="#为什么选择ASM？" class="headerlink" title="为什么选择ASM？"></a>为什么选择ASM？</h3><p>最直接的改造 Java 类的方法莫过于直接改写 class 文件。Java 规范详细说明了 class 文件的格式，直接编辑字节码确实可以改变 Java 类的行为。直到今天，还有一些 Java 高手们使用最原始的工具，如 UltraEdit 这样的编辑器对 class 文件动手术。是的，这是最直接的方法，但是要求使用者对 Java class 文件的格式了熟于心：小心地推算出想改造的函数相对文件首部的偏移量，同时重新计算 class 文件的校验码以通过 Java 虚拟机的安全机制。</p><p>可以发现，直接操作class文件是比较麻烦的，就跟为什么我们都选择使用框架一样，框架屏蔽了底层的复杂性。ASM就是操作class的一把利器。</p><h3 id="使用-ASM-编程"><a href="#使用-ASM-编程" class="headerlink" title="使用 ASM 编程"></a>使用 ASM 编程</h3><p>ASM提供了两种API：</p><ol><li>CoreAPI（ClassVisitor 、MethodVisitor等）</li><li>TreeAPI（ClassNode，MethodNode等）</li></ol><p>区别是CoreAPI基于事件模型，定义了Class中各个元素的Visitor，不需要加载整个Class到内存中。而TreeAPI以Tree结构将Class整个结构读取到内存中。从使用角度来说TreeAPI更为简单。</p><p>以下示例采用的是CoreAPI方式。</p><p>添加Maven：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ow2.asm&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;asm&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用的相对比较稳定，使用比较多的版本5.0.4。</p><p>首先说明一下，修改Class有多种方式，例如直接修改当前Class，或者生成Class的子类，从而达到增强的效果。</p><p>下面的示例就是通过生成指定Class的子类，从而达到增强的效果，好处是对原有Class无侵入，并且可以实现多态的效果。</p><p>首先定义一个我们要增强的类：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.zjz;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zhaojz created at 2019-08-22 10:49</span><br><span class="line"> */</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public void studying() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(this.name+&quot;正在学习...&quot;);</span><br><span class="line">        Thread.sleep(new Random().nextInt(5000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来首先定义一个ClassReader：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassReader classReader = new ClassReader(&quot;com.zjz.Student&quot;);</span><br></pre></td></tr></table></figure><p>然后再定义一个ClassWriter:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br></pre></td></tr></table></figure><p>ClassWriter.COMPUTE_MAXS 表示自动计算局部变量和操作数栈大小。更多其它选项可参考：<a href="https://asm.ow2.io/asm4-guide.pdf" target="_blank" rel="noopener">asm.ow2.io</a></p><p>接下来开始正式访问Class：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//通过ClassVisitor访问Class（匿名类的方式，可以自行定义为一个独立的类）</span><br><span class="line">//ASM5为JVM字节码指令操作码</span><br><span class="line">ClassVisitor classVisitor = new ClassVisitor(Opcodes.ASM5, classWriter) &#123;</span><br><span class="line">//声明一个全局变量，表示增强后生成的子类的父类</span><br><span class="line">   String enhancedSuperName;</span><br><span class="line">   @Override</span><br><span class="line">   public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;</span><br><span class="line">   //拼接需要生成的子类的类名：Student$EnhancedByASM</span><br><span class="line">   String enhancedName = name+&quot;$EnhancedByASM&quot;;</span><br><span class="line">   //将Student设置为父类</span><br><span class="line">   enhancedSuperName = name;</span><br><span class="line">   super.visit(version, access, enhancedName, signature, enhancedSuperName, interfaces);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) &#123;</span><br><span class="line">    //这里是演示字段访问</span><br><span class="line">    System.out.println(&quot;Field:&quot; + name);</span><br><span class="line">    return super.visitField(access, name, desc, signature, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">    System.out.println(&quot;Method:&quot; + name);</span><br><span class="line">    MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    MethodVisitor wrappedMv = mv;</span><br><span class="line">    //判断当前读取的方法</span><br><span class="line">    if (name.equals(&quot;studying&quot;)) &#123;</span><br><span class="line">    //如果是studying方法，则包装一个方法的Visitor</span><br><span class="line">    wrappedMv = new StudentStudyingMethodVisitor(Opcodes.ASM5, mv);</span><br><span class="line">    &#125;else if(name.equals(&quot;&lt;init&gt;&quot;))&#123;</span><br><span class="line">    //如果是构造方法，处理子类中父类的构造函数调用</span><br><span class="line">    wrappedMv = new StudentEnhancedConstructorMethodVisitor(Opcodes.ASM5, mv,enhancedSuperName);</span><br><span class="line">    &#125;</span><br><span class="line">    return wrappedMv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来重点看看MethodVisitor：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//Studying方法的Visitor</span><br><span class="line">static class StudentStudyingMethodVisitor extends MethodVisitor&#123;</span><br><span class="line"></span><br><span class="line">    public StudentStudyingMethodVisitor(int i, MethodVisitor methodVisitor) &#123;</span><br><span class="line">    super(i, methodVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//MethodVisitor 中定义了不同的visitXXX()方法，代表的不同的访问阶段。</span><br><span class="line">//visitCode表示刚刚进入方法。</span><br><span class="line">    @Override</span><br><span class="line">    public void visitCode() &#123;</span><br><span class="line">    //添加一行System.currentTimeMillis()调用</span><br><span class="line">        visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false);</span><br><span class="line">        //并且将其存储在局部变量表内位置为1的地方</span><br><span class="line">        visitVarInsn(Opcodes.LSTORE, 1);</span><br><span class="line">        //上面两个的作用就是在Studying方法的第一行添加 long start = System.currentTimeMillis()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//visitInsn 表示访问进入了方法内部</span><br><span class="line">    @Override</span><br><span class="line">    public void visitInsn(int opcode) &#123;</span><br><span class="line">    //通过opcode可以得知当前访问到了哪一步，如果是&gt;=Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN 表明方法即将退出</span><br><span class="line">        if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN))&#123;</span><br><span class="line">        //加载局部变量表中位置为1的数据，也就是start的数据，并传入给下面的方法</span><br><span class="line">            visitVarInsn(Opcodes.LLOAD, 1);</span><br><span class="line">            //然后调用自定义的一个工具方法，用来输出耗时</span><br><span class="line">            visitMethodInsn(Opcodes.INVOKESTATIC, &quot;com/zjz/Before&quot;, &quot;end&quot;, &quot;(J)V&quot;, false);</span><br><span class="line">        &#125;</span><br><span class="line">        super.visitInsn(opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class StudentEnhancedConstructorMethodVisitor extends MethodVisitor&#123;</span><br><span class="line">//定义一个全局变量记录父类名称</span><br><span class="line">    private String superClassName;</span><br><span class="line">    public StudentEnhancedConstructorMethodVisitor(int i, MethodVisitor methodVisitor,String superClassName) &#123;</span><br><span class="line">        super(i, methodVisitor);</span><br><span class="line">        this.superClassName = superClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean b) &#123;</span><br><span class="line">    //当开始初始化构造函数时，先访问父类构造函数,类似源码中的super()</span><br><span class="line">        if (opcode==Opcodes.INVOKESPECIAL &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))&#123;</span><br><span class="line">        owner = superClassName;</span><br><span class="line">        &#125;</span><br><span class="line">        super.visitMethodInsn(opcode, owner, name, desc, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时ClassVisitor还没有数据的输入，只定义了数据的输出 new ClassVisitor(Opcodes.ASM5, classWriter)，所以还需要：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br></pre></td></tr></table></figure><p>到此就完成了Class的读取，访问修改，输出的过程。</p><p>细心的观众就会发现了，输出到哪里了？怎么样访问新生成的类呢？所以我们需要定义一个ClassLoader来加载我们生成的Class：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static class StudentClassLoader extends ClassLoader&#123;</span><br><span class="line">       public Class defineClassFromClassFile(String className,byte[] classFile) throws ClassFormatError&#123;</span><br><span class="line">           return defineClass(className, classFile, 0, classFile.length);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后通过ClassWriter获取新生成的类的字节数组，并加载到JVM中：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = classWriter.toByteArray();</span><br><span class="line">Class subStudent = classLoader.defineClassFromClassFile(&quot;com.zjz.Student$EnhancedByASM&quot;, data);</span><br></pre></td></tr></table></figure><p>到此就完成了一个class的生成，上面的代码完成的是一个很简单的事情：记录学习时间。</p><p>总结一下：</p><p>ASM CoreAPI 核心的三个东西就是ClassReader、Visitor、ClassWriter，通过责任链模式将其链接起来。</p><p>Visitor通过访问者模式进行方法、字段等等属性的访问，如果需要修改一个方法和字段，只需要将其原本的Visitor给Wrap一下即可。</p><p>关于如何进行代码的hook需要理解JVM相关字节码指令，以及ASM的相关OpCode。</p><h3 id="ASM-Bytecode-Outline-2017"><a href="#ASM-Bytecode-Outline-2017" class="headerlink" title="ASM Bytecode Outline 2017"></a>ASM Bytecode Outline 2017</h3><p>但是那么多指令、OpCode、符号怎么记得住呢？比如上面代码中的：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false);</span><br><span class="line">visitVarInsn(Opcodes.LSTORE, 1);</span><br></pre></td></tr></table></figure><p>Opcodes.INVOKESTATIC  、Opcodes.LSTORE、()J，是不是看着就晕？其实除了熟能生巧外，还可以使用工具。</p><p>如果你使用的是IDEA，那么可以安装上ASM Bytecode Outline 2017插件。然后在源文件上右键选择Show Bytecode Outline，你将会看到如下视图：</p><p><img src="/archives/58ee9111/1.png" alt></p><p>切换的ASMified视图，你会看到跟我们上面写的一样的代码，直接Copy过来使用即可。</p><p>查看示例完整源代码：<a href="https://github.com/jingzhouzhao/asm_demo" target="_blank" rel="noopener">asm_demo</a></p><p>参考资料：</p><p><a href="https://asm.ow2.io/" target="_blank" rel="noopener">https://asm.ow2.io/</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html</a></p><p><a href="https://juejin.im/post/5b549bcbe51d45169c1c8b66" target="_blank" rel="noopener">https://juejin.im/post/5b549bcbe51d45169c1c8b66</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-ASM-？&quot;&gt;&lt;a href=&quot;#什么是-ASM-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 ASM ？&quot;&gt;&lt;/a&gt;什么是 ASM ？&lt;/h3&gt;&lt;p&gt;ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://qmbb.top/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://qmbb.top/tags/Java/"/>
    
      <category term="ASM" scheme="https://qmbb.top/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>区块链、比特币学习笔记</title>
    <link href="https://qmbb.top/archives/df4f5590.html"/>
    <id>https://qmbb.top/archives/df4f5590.html</id>
    <published>2019-08-20T02:52:49.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>学习区块链、比特币需要先搞明白hash、非对称加密、BASE64/58。<br>比特币中一个重要的概念就是UTXO（未花费输出），你有多少个比特币就是根据这个得来的。<br><a id="more"></a><br>挖矿得来的比特币称为coinbase，这个也是会产生一笔交易的，但是这个交易没有输入，只有输出。<br>比特币会产生分叉，有可能是临时分叉，因为两个人同时计算出了Nonce，同时打包了区块，这时就要看哪一个链条增长的更长，当超过6个区块时，另外一个区块就作废，所有的交易就失效。所以别人给你转比特币时，需要等待至少6个区块的确认，否者你会人财两空。<br>比特币也会产生硬分叉，就是同时存在两个链条，这个与临时分叉不同，这两个分叉谁也不能干掉谁，比如新的分叉BCC，BCH。产生硬分叉的原因其实是人为的，因为现在维护比特币的是core 团队，core团队提出的一些意见（隔离见证、闪电网络），得不到旷工团队的认可，或者说是利益问题。于是就产生了结构不同的区块，这样就分叉了。<br>挖矿（pow）的过程其实是计算一道题:<br>目标值=最大目标值/难度值</p><p>通过调整难度值来调整目标值的计算难度</p><p>需用通过hash运算，以及随机改变的Nonce来计算出一个hash值，使这个值小于目标值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习区块链、比特币需要先搞明白hash、非对称加密、BASE64/58。&lt;br&gt;比特币中一个重要的概念就是UTXO（未花费输出），你有多少个比特币就是根据这个得来的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://qmbb.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>从字节码来说明i++与++i到底有什么不同</title>
    <link href="https://qmbb.top/archives/ade4c276.html"/>
    <id>https://qmbb.top/archives/ade4c276.html</id>
    <published>2019-08-20T02:24:49.000Z</published>
    <updated>2019-10-16T09:05:40.008Z</updated>
    
    <content type="html"><![CDATA[<p>看字节码之前需要先了解相关概念，如栈帧、操作数栈、局部变量表。<br>栈帧是JVM中很重要的一个概念，因为JVM是基于栈的架构。一个方法的调用其实就是栈帧入栈出栈的过程。栈顶栈帧就是当前方法调用。<br>一个栈帧中包含：</p><ol><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法返回地址<a id="more"></a>这里i++、 ++i涉及到的就是局部变量表和操作数栈。具体信息可参考：《Java虚拟机规范》<a href="https://zhuanlan.zhihu.com/p/45354152" target="_blank" rel="noopener"> </a></li></ol><p>局部变量表存储的是方法的参数以及内部定义的变量的值，操作数栈也是一个栈结构，用来执行方法中的指令。</p><p>好了，来看一个代码片段：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Scratch &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i=0,j=0,m=0;</span><br><span class="line">        j = i++;</span><br><span class="line">        m = ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了不产生其他多过信息，这里只写了关键代码。<br>首先可以通过<code>javac</code> 将源码编译成class：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac scratch.java</span><br></pre></td></tr></table></figure></p><p>执行完成后将看到Scratch.class 文件，通过javap命令查看字节码：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c Scratch &gt; scratch.txt</span><br></pre></td></tr></table></figure></p><p>为了方便查看将结果输出到了scratch.txt，打开此文件将看到如下信息：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;scratch.java&quot;</span><br><span class="line">class Scratch &#123;</span><br><span class="line">  Scratch();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_0</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iconst_0</span><br><span class="line">       5: istore_3</span><br><span class="line">       6: iload_1</span><br><span class="line">       7: iinc          1, 1</span><br><span class="line">      10: istore_2</span><br><span class="line">      11: iinc          1, 1</span><br><span class="line">      14: iload_1</span><br><span class="line">      15: istore_3</span><br><span class="line">      16: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关注main方法 0-5，可以发现对应的是：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i=0,j=0,m=0;</span><br></pre></td></tr></table></figure></p><p>主要是声明变量并初始化为0。我们可以发现下划线后面跟了一个数字，这里应该代表的是变量在局部变量表中的位置。<br>i：1<br>j：2<br>m：3</p><p>再关注main方法：6、7、10：<br><code>iload_1</code> 表示将局部变量表中位置1的数据放入操作数栈中(这里对应的是i，此时i的值为0)然后pop出来赋值给j。然后再将i自增<code>iinc</code>。最后<code>istore_2</code>存储j到局部变量表中。<br>操作完成后i=1，j=1。<br>最后关注main方法：11、14、15：<br><code>iinc</code>首先自增i，然后<code>iload_1</code>将局部变量表中位置1的数据放入操作数栈中(这里对应的是i，此时i的值为2)然后pop出来赋值给m。最后<code>istore_3</code>存储m到局部变量表中。<br>操作完成后i=2，j=1，m=2。</p><p>这就是为什么大家都说，i++是先赋值后自增，而++i是先自增后赋值的原因。</p><p>这里要说明的是，如果是单独的i++、++i是没有什么区别的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看字节码之前需要先了解相关概念，如栈帧、操作数栈、局部变量表。&lt;br&gt;栈帧是JVM中很重要的一个概念，因为JVM是基于栈的架构。一个方法的调用其实就是栈帧入栈出栈的过程。栈顶栈帧就是当前方法调用。&lt;br&gt;一个栈帧中包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;局部变量表&lt;/li&gt;
&lt;li&gt;操作数栈&lt;/li&gt;
&lt;li&gt;动态链接&lt;/li&gt;
&lt;li&gt;方法返回地址&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://qmbb.top/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://qmbb.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer-随记</title>
    <link href="https://qmbb.top/archives/5e0e6b4c.html"/>
    <id>https://qmbb.top/archives/5e0e6b4c.html</id>
    <published>2019-08-20T01:54:49.000Z</published>
    <updated>2019-10-16T09:05:40.006Z</updated>
    
    <content type="html"><![CDATA[<p>常见误区：Lock（乐观锁，自旋锁）一定比Synchronized好。这个说法是不正确的。自旋锁适合锁竞争不是很激烈的情况下使用，因为其使用了死循环，比较消耗CPU资源。Synchronized在JDK1.5后进行了优化，通过锁升级(偏向锁-&gt;轻量级锁(通常是自旋)-&gt;重量级锁) 提升了性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见误区：Lock（乐观锁，自旋锁）一定比Synchronized好。这个说法是不正确的。自旋锁适合锁竞争不是很激烈的情况下使用，因为其使用了死循环，比较消耗CPU资源。Synchronized在JDK1.5后进行了优化，通过锁升级(偏向锁-&amp;gt;轻量级锁(通常是自旋)-
      
    
    </summary>
    
      <category term="Java随记" scheme="https://qmbb.top/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://qmbb.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mongodb 备份数据</title>
    <link href="https://qmbb.top/archives/5c2c1bbd.html"/>
    <id>https://qmbb.top/archives/5c2c1bbd.html</id>
    <published>2019-08-15T02:29:49.000Z</published>
    <updated>2019-10-16T09:05:40.011Z</updated>
    
    <content type="html"><![CDATA[<p>备份[部分]数据为dump，然后从collection中将已备份数据删除。</p><pre><code>./mongodump  -d trans -c test -h 192.168.190.128 -u trans -p 123456 -o /data/backup</code></pre><p>-h:指明数据库宿主机的IP</p><p>-u:指明数据库的用户名<br><a id="more"></a><br>-p:指明数据库的密码</p><p>-d:指明数据库的名字</p><p>-c:指明collection的名字</p><p>-o:指明到要导出的文件名</p><p>-q:指明导出数据的过滤条件</p><h3 id="恢复备份的数据"><a href="#恢复备份的数据" class="headerlink" title="恢复备份的数据"></a>恢复备份的数据</h3><pre><code>./bin/mongorestore -h host -d test --drop data/backup/test/</code></pre><p>-h:指明数据库宿主机的IP</p><p>-u:指明数据库的用户名</p><p>-p:指明数据库的密码</p><p>-d:指明数据库的名字</p><p>–drop 为先删除collection中的数据再恢复</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;备份[部分]数据为dump，然后从collection中将已备份数据删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./mongodump  -d trans -c test -h 192.168.190.128 -u trans -p 123456 -o /data/backup
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;-h:指明数据库宿主机的IP&lt;/p&gt;
&lt;p&gt;-u:指明数据库的用户名&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://qmbb.top/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="MongodDB" scheme="https://qmbb.top/tags/MongodDB/"/>
    
  </entry>
  
  <entry>
    <title>各种加密方式的问题</title>
    <link href="https://qmbb.top/archives/d7f22001.html"/>
    <id>https://qmbb.top/archives/d7f22001.html</id>
    <published>2019-08-14T02:41:49.000Z</published>
    <updated>2019-10-16T09:05:40.008Z</updated>
    
    <content type="html"><![CDATA[<p>对称加密最大的问题就是密钥的传输问题。<br>于是乎出现了非对称加密。公钥完全公开，谁都可以使用。<br>非对称加密最大的问题就是身份确认的问题。<br>怎么能确认是不是正确的人使用公钥加密的信息呢。<br>于是乎出现了数字签名，使用对方公钥的人，用自己的私钥签名，然后对方用签名的人的公钥解密。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对称加密最大的问题就是密钥的传输问题。&lt;br&gt;于是乎出现了非对称加密。公钥完全公开，谁都可以使用。&lt;br&gt;非对称加密最大的问题就是身份确认的问题。&lt;br&gt;怎么能确认是不是正确的人使用公钥加密的信息呢。&lt;br&gt;于是乎出现了数字签名，使用对方公钥的人，用自己的私钥签名，然后对方
      
    
    </summary>
    
      <category term="Java随记" scheme="https://qmbb.top/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>mongodb13亿数据清理记录</title>
    <link href="https://qmbb.top/archives/7fbe8b08.html"/>
    <id>https://qmbb.top/archives/7fbe8b08.html</id>
    <published>2019-08-09T09:23:49.000Z</published>
    <updated>2019-10-16T09:05:40.011Z</updated>
    
    <content type="html"><![CDATA[<p>mongodb上一个collection数据已经膨胀到13亿，也就最近一两个月的数据重要一点。于是考虑清除一下这个collection。<br>于是：<br>第一步：<br>先将原表备份<br><a id="more"></a><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.renameCollection(&quot;test_bak&quot;)</span><br></pre></td></tr></table></figure></p><p>然后根据时间删除数据<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test_bak.remove(&#123;&quot;createtime&quot;:&#123;&quot;$lte&quot;:ISODate(&quot;2019-06-09T00:00:00.000Z&quot;)&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>将两个月前的数据全部清掉。<br>执行到这一步发现，现实很残酷，基本上命令是卡死状态。<br>查看collection上的索引：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test_bak.getIndexes()</span><br></pre></td></tr></table></figure></p><p>发现createtime没有索引，于是乎加上：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test_bak.createIndex(&#123;&quot;createtime&quot;:-1&#125;)</span><br></pre></td></tr></table></figure></p><p>加索引这一步也要执行很久，慢慢等吧。<br>等到索引添加成功再次执行删除数据的命令即可，也将执行很久。<br>通过：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test_bak.count()</span><br></pre></td></tr></table></figure></p><p>查看还剩多少数据。<br>由于test_bak已经没有新的数据写入，还需要将最近两个月的数据同步到test中，于是：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test_bak.find(&#123;&quot;createtime&quot;:&#123;&quot;$gte&quot;:ISODate(&quot;2019-06-09T00:00:00.000Z&quot;)&#125;&#125;).forEach(function(x)&#123;</span><br><span class="line">    db.test.insert(x);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>等待慢慢执行吧…..</p><p>以上为实操分享。</p><p>所在在一开始就应该设置，无用的数据自动清理掉。<br>也就没有后面头疼的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mongodb上一个collection数据已经膨胀到13亿，也就最近一两个月的数据重要一点。于是考虑清除一下这个collection。&lt;br&gt;于是：&lt;br&gt;第一步：&lt;br&gt;先将原表备份&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://qmbb.top/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="MongodDB" scheme="https://qmbb.top/tags/MongodDB/"/>
    
  </entry>
  
  <entry>
    <title>linux 大文件无法清空</title>
    <link href="https://qmbb.top/archives/5cc761d2.html"/>
    <id>https://qmbb.top/archives/5cc761d2.html</id>
    <published>2019-07-26T09:11:49.000Z</published>
    <updated>2019-10-16T09:05:40.011Z</updated>
    
    <content type="html"><![CDATA[<p>linux 清空一个大文件（上G的）一般有这么几种方法：</p><ol><li>cat /dev/null &gt; nohup.log</li><li>cp /dev/null &gt; nohup.log</li><li>echo “”  &gt; nohup.log<a id="more"></a>但是今天在尝试这几个命令的时候发现始终无法清空。</li></ol><p>最终发现问题在nohup.log的生成命令那里：<br>nohup xxx &gt; nohup.out &amp;<br>问题就在 &gt; ，需要使用 &gt;&gt; 追加模式才能使用上述三个命令清空。<br>正确方式：<br>nohup xxx &gt;&gt; nohup.out &amp;</p><p>其实，应该将nohup.out进行拆分。或者不输入到nohup.out。因为毕竟程序里面已经使用了log库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux 清空一个大文件（上G的）一般有这么几种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cat /dev/null &amp;gt; nohup.log&lt;/li&gt;
&lt;li&gt;cp /dev/null &amp;gt; nohup.log&lt;/li&gt;
&lt;li&gt;echo “”  &amp;gt; nohup.log&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://qmbb.top/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="linux" scheme="https://qmbb.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Golang常用的第三方包</title>
    <link href="https://qmbb.top/archives/4c4ac8cd.html"/>
    <id>https://qmbb.top/archives/4c4ac8cd.html</id>
    <published>2019-07-19T09:20:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql Driver<br><code>go get -u github.com/go-sql-driver/mysql</code></p><p>SQL Library<br><code>go get github.com/jmoiron/sqlx</code><br><a id="more"></a><br>Redis Library<br><code>go get github.com/gomodule/redigo/redis</code></p><p>Kafka Library<br><code>go get github.com/Shopify/sarama</code></p><p>Etcd Library<br><code>go get go.etcd.io/etcd/client</code></p><p>TOML Library</p><p><code>go get github.com/BurntSushi/toml</code></p><p>toml一个比yaml更简洁更方便的一种配置文件格式</p><p>未完待续…</p><p>2019/08/19</p><p>最近发现github上一个库整理的比较全，可以参考：<br><a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">https://github.com/avelino/awesome-go</a><br>对应中文版：<br><a href="https://github.com/jobbole/awesome-go-cn" target="_blank" rel="noopener">https://github.com/jobbole/awesome-go-cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql Driver&lt;br&gt;&lt;code&gt;go get -u github.com/go-sql-driver/mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SQL Library&lt;br&gt;&lt;code&gt;go get github.com/jmoiron/sqlx&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://qmbb.top/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://qmbb.top/tags/Golang/"/>
    
  </entry>
  
</feed>
