<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵荆州的个人博客</title>
  
  
  <link href="https://jingzhouzhao.github.io/atom.xml" rel="self"/>
  
  <link href="https://jingzhouzhao.github.io/"/>
  <updated>2022-03-03T09:54:02.094Z</updated>
  <id>https://jingzhouzhao.github.io/</id>
  
  <author>
    <name>太阳当空赵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo调用超时那些事儿</title>
    <link href="https://jingzhouzhao.github.io/archives/ae3bdc00.html"/>
    <id>https://jingzhouzhao.github.io/archives/ae3bdc00.html</id>
    <published>2022-02-25T06:50:58.000Z</published>
    <updated>2022-03-03T09:54:02.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实之前很早就看过dubbo源码中关于超时这部分的处理逻辑，但是没有记录下来，最近在某脉上看到有人问了这个问题，想着再回顾一下。</p></blockquote><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>从dubbo的请求开始，看看dubbo（2.6.6）在超时这块是怎么处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeChannel#request(java.lang.Object, <span class="keyword">int</span>) </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">&quot;Failed to send request &quot;</span> + request + <span class="string">&quot;, cause: The channel &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; is closed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create request.</span></span><br><span class="line">        Request req = <span class="keyword">new</span> Request();</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">        req.setData(request);</span><br><span class="line">        DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.send(req);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            future.cancel();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="DefaultFuture"><a href="#DefaultFuture" class="headerlink" title="DefaultFuture"></a>DefaultFuture</h3><p>从返回值ResponseFuture类型可以看出，这是一个异步方法（不等同于Dubbo的异步调用）。那么调用超时的关键可以从ResponseFuture来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeoutInMillis)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这是一个接口，从request方法可以得知实现类是DefaultFuture，从构造函数入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// put into waiting map.</span></span><br><span class="line">        FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">        CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得知每一个DefaultFuture都有一个id，并且等于requestId，timeout是从url中获取的配置，没有时默认1000ms。</p><p>从代码的注释可以看到FUTURES这个map应该就是关键，是一个waiting map。</p><p>DefaultFuture中还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">           <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">               future.doReceived(response);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;The timeout response finally returned at &quot;</span></span><br><span class="line">                       + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                       + <span class="string">&quot;, response &quot;</span> + response</span><br><span class="line">                       + (channel == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, channel: &quot;</span> + channel.getLocalAddress()</span><br><span class="line">                       + <span class="string">&quot; -&gt; &quot;</span> + channel.getRemoteAddress()));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           CHANNELS.remove(response.getId());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到调用的地方为：</p><p>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#received</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">//省略一些代码        </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                handleResponse(channel, (Response) message);</span><br><span class="line">        <span class="comment">//省略一些代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeHandler#handleResponse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">            DefaultFuture.received(channel, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到DefaultFuture.received，可以看到通过Response id从FUTURES中拿了一个DefaultFuture出来，然后调用了doReceived方法，也就是说Response id和Request id 相同。结下来看看doReceived做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = res;</span><br><span class="line">            <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">                done.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCallback(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先是加锁，然后通过唤醒了阻塞在Condition上的线程。看看什么地方会阻塞在done这个条件上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            timeout = Constants.DEFAULT_TIMEOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">                    done.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>是get方法，get方法确实在request请求后被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Result) currentClient.request(inv, timeout).get()</span><br></pre></td></tr></table></figure><p>可以看到get方法的大致逻辑为，先获取锁，然后循环判断isDone，并阻塞等到条件，当条件超时，如果任务完成，或者超过timeout结束循环，接着判断isDone，如果超时抛出TimeoutException。并且通过sent（request请求时间）是否&gt;0（）来判断是clientSide还是serverSide超时。</p><p>isDone逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> response != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果是正常Response，也有可能是超时的现象，可以看到get方法最后调用了一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">returnFromResponse</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = response;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;response cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.getResult();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, res.getErrorMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="TIMEOUT-SIDE"><a href="#TIMEOUT-SIDE" class="headerlink" title="TIMEOUT SIDE"></a>TIMEOUT SIDE</h3><p>SERVER_TIMEOUT（服务端超时）： 这个就是正常的我们消费端请求一个RPC接口，服务端由于性能等一些原因处理时间超过了timeout配置时间。</p><p>CLIENT_TIMEOUT：我们可以看到是通过sent这个来判断是否clientTimeout，那么这个sent什么时候改变呢？就在发送请求的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">            ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.sent(exchangeChannel, message);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            Request request = (Request) message;</span><br><span class="line">            <span class="comment">//这里会设置sent</span></span><br><span class="line">            DefaultFuture.sent(channel, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) exception;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RemotingException) exception;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel.getLocalAddress(), channel.getRemoteAddress(),</span><br><span class="line">                        exception.getMessage(), exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说handler.sent一旦调用成功返回，那么就不算clientSide Timeout了。那么CLIENT_TIMEOUT大概率就是由于client端网络，系统等原因超时。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;其实之前很早就看过dubbo源码中关于超时这部分的处理逻辑，但是没有记录下来，最近在某脉上看到有人问了这个问题，想着再回顾一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;从dubbo的请求开始，看看dubbo（2.6.6）在超时这块是怎么处理的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeChannel#request(java.lang.Object, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ResponseFuture &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object request, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; timeout)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; RemotingException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (closed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RemotingException(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getLocalAddress(), &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;Failed to send request &amp;quot;&lt;/span&gt; + request + &lt;span class=&quot;string&quot;&gt;&amp;quot;, cause: The channel &amp;quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&amp;quot; is closed!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// create request.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Request req = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Request();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        req.setVersion(Version.getProtocolVersion());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        req.setTwoWay(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        req.setData(request);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DefaultFuture future = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DefaultFuture(channel, req, timeout);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            channel.send(req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RemotingException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            future.cancel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; future;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
    <category term="Dubbo" scheme="https://jingzhouzhao.github.io/tags/Dubbo/"/>
    
    <category term="RPC" scheme="https://jingzhouzhao.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Java双亲委派机制的妙用</title>
    <link href="https://jingzhouzhao.github.io/archives/27ffa58c.html"/>
    <id>https://jingzhouzhao.github.io/archives/27ffa58c.html</id>
    <published>2022-02-09T09:33:21.000Z</published>
    <updated>2022-02-22T07:31:09.008Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中看到一段通过easyexcel导出动态表头的实现，开始我以为是easyexcel官方的实现，其中有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将动态表头上传至ThreadLocal</span></span><br><span class="line">saveToThreadLocal(clz, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">saveToThreadLocal</span><span class="params">(Class&lt;T&gt; clz, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        Map&lt;Class,List&lt;String&gt;&gt; paramMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        paramMap.put(clz, result);</span><br><span class="line">        ThreadLocalUtil.FIELD_CACHE_MAP.set(paramMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>其中result是通过接口拿到的用户表头配置，我看到有这么个东西:<code>ThreadLocalUtil</code>，以为是easyexcel的实现，到github查找了一番，结果什么也没有发现。<br>idea点进去查看了一下，发现是内部的一个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;Class,List&lt;String&gt;&gt;&gt; FIELD_CACHE_MAP = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SoftReference&lt;FieldCache&gt;&gt; CACHE = <span class="keyword">new</span> ThreadLocal();&#125;</span><br></pre></td></tr></table></figure><p>同时还发现了以下几个文件：<br><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/jqsaj8j3tv-1644455538154.png"></p><p>一开始我的想法是，这几个文件应该是easyexcel预留的扩展，只需要继承某些父类，重写几个方法就行了。但是这样一来，肯定需要有什么地方配置，类似SPI一样。<br>于是我通过上面的文件名在项目中查找，结果什么也没有找到。也就是说上面几个文件跟easyexcel并没有产生什么联系。那为什么通过这几个文件就能实现导出动态表头呢？<br>没办法，只能debug了，这时我发现在easyexcel包中也有一个<code>ExcelHeadProperty</code>，跟上面说的那个文件并不是同一个。在idea中导航到的是easyexcel中的class，但是实际执行的却不是。</p><p>仔细一看，发现这两个文件除了内容不一样，包名是完全一样的:<code>com.alibaba.excel.metadata.property</code>，这时我想到了Java的双亲委派机制。而项目又并不是直接依赖的easyexcel，是通过间接依赖进来的。<br>所以被改写过的ExcelHeadProperty 先于easyexcel本身的文件被加载，等到加载easyexcel中的相同class时，发现已经被加载过了。不在加载了。</p><p>然后我又在项目中加了一个相同的文件，简单修改了一下，发现项目中的class加载优先级更高，class又一次被改写了：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/ouijzqwan9-1644455655792.png"></p><p>不得不说，妙啊！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在项目中看到一段通过easyexcel导出动态表头的实现，开始我以为是easyexcel官方的实现，其中有这样一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将动态表头上传至ThreadLocal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;saveToThreadLocal(clz, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;saveToThreadLocal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;T&amp;gt; clz, List&amp;lt;String&amp;gt; result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Map&amp;lt;Class,List&amp;lt;String&amp;gt;&amp;gt; paramMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paramMap.put(clz, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ThreadLocalUtil.FIELD_CACHE_MAP.set(paramMap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
    <category term="双亲委派" scheme="https://jingzhouzhao.github.io/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>同事问了我一个关于RocketMQ的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/92571797.html"/>
    <id>https://jingzhouzhao.github.io/archives/92571797.html</id>
    <published>2022-01-14T05:42:36.000Z</published>
    <updated>2022-02-22T07:31:09.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>同事突然问我：RocketMQ的一个消息，多次消费重试，消息的msgId会不会变？哪怕已经进了DLQ。</p></blockquote><p>刚开始出于经验，我说不会变。因为我之前每次排查问题的时候，用同一个msgId都能找到多次重试消费的日志。后来为了更加确定，我卷了一下源码，我看的是4.6.1，一是因为公司用的这个版本，二是我上次卷的就是这个版本。。。</p><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>既然跟重试有关，那就从客户端消费失败的逻辑开始，看看能不能找到蛛丝马迹，下面是消费失败将消息发回broker的代码：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService</span><br><span class="line"><span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">                <span class="comment">//消费失败ackIndex=-1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                        msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                        msgBackFailed.add(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，消费失败会调用<code>sendMessageBack</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#sendMessageBack</span><br><span class="line">org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#sendMessageBack</span><br><span class="line">org.apache.rocketmq.client.impl.MQClientAPIImpl#consumerSendMessageBack</span><br><span class="line"> ConsumerSendMsgBackRequestHeader requestHeader = <span class="keyword">new</span> ConsumerSendMsgBackRequestHeader();</span><br><span class="line">        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);</span><br><span class="line"></span><br><span class="line">        requestHeader.setGroup(consumerGroup);</span><br><span class="line">        requestHeader.setOriginTopic(msg.getTopic());</span><br><span class="line">        requestHeader.setOffset(msg.getCommitLogOffset());</span><br><span class="line">        <span class="comment">//这个是延迟级别对应broker的那16个task，是可以通过ConsumeConcurrentlyContext 设置的，默认是按Broker的策略</span></span><br><span class="line">        requestHeader.setDelayLevel(delayLevel);</span><br><span class="line">        requestHeader.setOriginMsgId(msg.getMsgId());</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);</span><br><span class="line"></span><br><span class="line">        RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class="keyword">this</span>.clientConfig.isVipChannelEnabled(), addr),</span><br><span class="line">            request, timeoutMillis);</span><br></pre></td></tr></table></figure><p>可以看到给Broker发了一个RequestCode.CONSUMER_SEND_MSG_BACK，然后附带了一些offset，originMsgId等信息，开始我以为跟这个originMsgId有关，因为他这里把原始的msgId发回去了呀，所以msgId就不会变，然而事实不是这样的。继续看到broker处理部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncConsumerSendMsgBack</span></span><br><span class="line">        String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">        MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line"></span><br><span class="line">        MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(newTopic);</span><br><span class="line">        </span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">        MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line">        CompletableFuture&lt;PutMessageResult&gt; putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().asyncPutMessage(msgInner);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于代码太长，省略了一些。可以看到上面说的request中的originMsgId并没有用，而是通过offset直接定位到消息直接拿的msgId（如果不是第一次那么是从Properties中取的PROPERTY_ORIGIN_MESSAGE_ID）。但是这个跟msgId也没有关系呀，这个时候我猜测，是不是在提交到commitlog的时候将msgId重置为了originMsgId，继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.CommitLog#putMessage</span></span><br><span class="line">   <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                    msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">                queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">                msg.setTopic(topic);</span><br><span class="line">                msg.setQueueId(queueId);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"> result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br></pre></td></tr></table></figure><p>由于重试需要延迟处理，所以消息又被投递到了SCHEDULE_TOPIC（SCHEDULE_TOPIC_XXXX），继续看写入commitlog部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend(long, java.nio.ByteBuffer, int, org.apache.rocketmq.store.MessageExtBrokerInner)</span></span><br><span class="line"> String msgId;</span><br><span class="line">            <span class="keyword">if</span> ((sysflag &amp; MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == <span class="number">0</span>) &#123;</span><br><span class="line">                msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(storeHostHolder), wroteOffset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdV6Memory, msgInner.getStoreHostBytes(storeHostHolder), wroteOffset);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>然而又一次错了，msgId并没有被重置为originMsgId，而是通过host和写入的offset算出来的。也就是说每一次重试，重新写入commitlog，msgId都会变。。。这下我颓了，难道我跟同事说错了？可是我以前排查问题的时候，明明每次都是一样的啊？</p><h2 id="再次消费"><a href="#再次消费" class="headerlink" title="再次消费"></a>再次消费</h2><p>不行，还得继续卷，这个时候我在想，难不成是在重新消费的时候做了啥处理？来看看消费者的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.client.consumer.PullCallback#onSuccess</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.PullAPIWrapper#processPullResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PullResult <span class="title">processPullResult</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> PullResult pullResult,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SubscriptionData subscriptionData)</span> </span>&#123;</span><br><span class="line">        PullResultExt pullResultExt = (PullResultExt) pullResult;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());</span><br><span class="line">        <span class="keyword">if</span> (PullStatus.FOUND == pullResult.getPullStatus()) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());</span><br><span class="line">            List&lt;MessageExt&gt; msgList = MessageDecoder.decodes(byteBuffer);</span><br><span class="line"></span><br><span class="line">            List&lt;MessageExt&gt; msgListFilterAgain = msgList;</span><br><span class="line">            <span class="keyword">if</span> (!subscriptionData.getTagsSet().isEmpty() &amp;&amp; !subscriptionData.isClassFilterMode()) &#123;</span><br><span class="line">                msgListFilterAgain = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(msgList.size());</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg.getTags() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (subscriptionData.getTagsSet().contains(msg.getTags())) &#123;</span><br><span class="line">                            msgListFilterAgain.add(msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasHook()) &#123;</span><br><span class="line">                FilterMessageContext filterMessageContext = <span class="keyword">new</span> FilterMessageContext();</span><br><span class="line">                filterMessageContext.setUnitMode(unitMode);</span><br><span class="line">                filterMessageContext.setMsgList(msgListFilterAgain);</span><br><span class="line">                <span class="keyword">this</span>.executeHook(filterMessageContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgListFilterAgain) &#123;</span><br><span class="line">                String traFlag = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                <span class="keyword">if</span> (Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">                    msg.setTransactionId(msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));</span><br><span class="line">                &#125;</span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,</span><br><span class="line">                    Long.toString(pullResult.getMinOffset()));</span><br><span class="line">                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,</span><br><span class="line">                    Long.toString(pullResult.getMaxOffset()));</span><br><span class="line">                msg.setBrokerName(mq.getBrokerName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pullResultExt.setMsgFoundList(msgListFilterAgain);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pullResultExt.setMessageBinary(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pullResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开始看到<code>msg.setTransactionId</code>这个，还开心了一下，想着找找<code>setMsgId</code>，结果还是没有。<br>难不成在消费服务中处理的？开始继续看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.ConsumeRequest#run</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;the message queue not be able to consume, because it&#x27;s dropped. group=&#123;&#125; &#123;&#125;&quot;</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">            ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">            ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());</span><br></pre></td></tr></table></figure><p>看到这个<code>defaultMQPushConsumerImpl.resetRetryAndNamespace</code>，我激动坏了，打开一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String groupTopic = MixAll.getRetryTopic(consumerGroup);</span><br><span class="line">       <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">           String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">           <span class="keyword">if</span> (retryTopic != <span class="keyword">null</span> &amp;&amp; groupTopic.equals(msg.getTopic())) &#123;</span><br><span class="line">               msg.setTopic(retryTopic);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotEmpty(<span class="keyword">this</span>.defaultMQPushConsumer.getNamespace())) &#123;</span><br><span class="line">               msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQPushConsumer.getNamespace()));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这啥呀这是，也不对。后来直到我进入了<code>MessageExt</code>, idea显示了这么一个图标：<br><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/2stcr97lkc-1642143607868.png"><br>我意识到事情不对劲，我可能做了很多无用功，忘记了 Java面向对象的三大特性之一的<code>继承</code>:<br><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/l4e3t74lja-1642143701745.png"><br>答案就藏在<code>MessageClientExt</code>中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageClientExt</span> <span class="keyword">extends</span> <span class="title">MessageExt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOffsetMsgId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getMsgId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffsetMsgId</span><span class="params">(String offsetMsgId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setMsgId(offsetMsgId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsgId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String uniqID = MessageClientIDSetter.getUniqID(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (uniqID == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getOffsetMsgId();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> uniqID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgId</span><span class="params">(String msgId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DO NOTHING</span></span><br><span class="line">        <span class="comment">//MessageClientIDSetter.setUniqID(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> WTF，我一直盯着setMsgId，以为是哪个地方把msgId重置了，没想到，他娘的是getMsgId方法被重写了。<br> 从这里可以得知两个东西：<br> <code>OffsetMsgId</code>：对应commitLog offset的，每次都会变的物理msgId<br> <code>uniqID</code>：对应Property中的UNIQ_KEY，看来不变的是这个。</p><p>那UNIQ_KEY到底是啥：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] ip;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ip = UtilAll.getIP();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ip = createFakeIP();</span><br><span class="line">        &#125;</span><br><span class="line">        LEN = ip.length + <span class="number">2</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">2</span>;</span><br><span class="line">        ByteBuffer tempBuffer = ByteBuffer.allocate(ip.length + <span class="number">2</span> + <span class="number">4</span>);</span><br><span class="line">        tempBuffer.put(ip);</span><br><span class="line">        tempBuffer.putShort((<span class="keyword">short</span>) UtilAll.getPid());</span><br><span class="line">        tempBuffer.putInt(MessageClientIDSetter.class.getClassLoader().hashCode());</span><br><span class="line">        FIX_STRING = UtilAll.bytes2string(tempBuffer.array());</span><br><span class="line">        setStartTime(System.currentTimeMillis());</span><br><span class="line">        COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createUniqID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(LEN * <span class="number">2</span>);</span><br><span class="line">        sb.append(FIX_STRING);</span><br><span class="line">        sb.append(UtilAll.bytes2string(createUniqIDBuffer()));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] createUniqIDBuffer() &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4</span> + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= nextStartTime) &#123;</span><br><span class="line">            setStartTime(current);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.putInt((<span class="keyword">int</span>) (System.currentTimeMillis() - startTime));</span><br><span class="line">        buffer.putShort((<span class="keyword">short</span>) COUNTER.getAndIncrement());</span><br><span class="line">        <span class="keyword">return</span> buffer.array();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>UNIQ_KEY是在第一次发送到Broker时，通过ip、pid、hashcode、时间差、自增序号组成的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消息本身的id是与消息offset相关的，每个消息都是不同的，而我们常在client使用的msgId是在client生产消息时赋予的具有逻辑唯一性的id（不论投递多少次）。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>陷入困境的时候，不妨去窝个liao。😊</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;同事突然问我：RocketMQ的一个消息，多次消费重试，消息的msgId会不会变？哪怕已经进了DLQ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刚开始出于经验，我说不会变。因为我之前每次排查问题的时候，用同一个msgId都能找到多次重试消费的日志。后来为了更加确定，我卷了一下源码，我看的是4.6.1，一是因为公司用的这个版本，二是我上次卷的就是这个版本。。。&lt;/p&gt;
&lt;h2 id=&quot;消息重试&quot;&gt;&lt;a href=&quot;#消息重试&quot; class=&quot;headerlink&quot; title=&quot;消息重试&quot;&gt;&lt;/a&gt;消息重试&lt;/h2&gt;&lt;p&gt;既然跟重试有关，那就从客户端消费失败的逻辑开始，看看能不能找到蛛丝马迹，下面是消费失败将消息发回broker的代码：&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="RocketMQ" scheme="https://jingzhouzhao.github.io/tags/RocketMQ/"/>
    
    <category term="MessageId" scheme="https://jingzhouzhao.github.io/tags/MessageId/"/>
    
    <category term="UniqKey" scheme="https://jingzhouzhao.github.io/tags/UniqKey/"/>
    
  </entry>
  
  <entry>
    <title>PDF转EPUB工具分享</title>
    <link href="https://jingzhouzhao.github.io/archives/760ddd3b.html"/>
    <id>https://jingzhouzhao.github.io/archives/760ddd3b.html</id>
    <published>2022-01-06T08:41:58.000Z</published>
    <updated>2022-02-22T07:31:09.018Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先说下，有经济条件的还是建议购买纸质书阅读啊！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在网上很多资料都是有在线版的，但是有时候到一些网络不好的地方就很尴尬了。不过同时大佬们也会提供PDF版本，但是个人觉得PDF的阅读体验实在太差了。</p><p>我一直觉得epub格式的阅读体验不错，适配各种显示设备。关于epub是什么，可以看看<a href="https://zh.wikipedia.org/wiki/EPUB">wiki</a>上的介绍：</p><span id="more"></span><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/51zhebyw4u-1641458854167.png"></p><p>总之值得一试。但是资料都是pdf的，找不到epub格式的咋办呢？</p><p>可以“百度”搜索一下“pdf转epub”，结果如下：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/9x7sodgd2i-1641459116511.png"></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>一个个尝试下来，发现以下两个还算能用：</p><p><a href="https://www.online-convert.com/">https://www.online-convert.com/</a></p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/wtnh9nq23e-image-20220106165731325.png"></p><p>选择<code>Convert to ePub</code>即可。</p><p><a href="https://convertio.co/zh/pdf-epub/">https://convertio.co/zh/pdf-epub/</a></p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/pq7y8l4r2g-image-20220106165841460.png"></p><p>直接选择文件即可。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h3><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/i2pegrs8iu-1641459961215.png"></p><h3 id="ePub"><a href="#ePub" class="headerlink" title="ePub"></a>ePub</h3><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/io0rawnrqi-image-20220106170720041.png"></p><p>我是用Mac自带的“图书”App打开的，可以标注重点，做笔记等。另外还可以<strong>同步进度、重点、笔记到iPhone上</strong>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果是扫描版的PDF，那么转换效果是很差的，基本上跟pdf一样。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果有时间可以研究一下，自己写个转换工具。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;首先说下，有经济条件的还是建议购买纸质书阅读啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在网上很多资料都是有在线版的，但是有时候到一些网络不好的地方就很尴尬了。不过同时大佬们也会提供PDF版本，但是个人觉得PDF的阅读体验实在太差了。&lt;/p&gt;
&lt;p&gt;我一直觉得epub格式的阅读体验不错，适配各种显示设备。关于epub是什么，可以看看&lt;a href=&quot;https://zh.wikipedia.org/wiki/EPUB&quot;&gt;wiki&lt;/a&gt;上的介绍：&lt;/p&gt;</summary>
    
    
    
    <category term="工具分享" scheme="https://jingzhouzhao.github.io/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="PDF" scheme="https://jingzhouzhao.github.io/tags/PDF/"/>
    
    <category term="EPUB" scheme="https://jingzhouzhao.github.io/tags/EPUB/"/>
    
    <category term="电子书" scheme="https://jingzhouzhao.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>什么是IRIW和MCA（multi-copy atomicity）</title>
    <link href="https://jingzhouzhao.github.io/archives/9489a17b.html"/>
    <id>https://jingzhouzhao.github.io/archives/9489a17b.html</id>
    <published>2021-12-30T06:50:51.000Z</published>
    <updated>2022-02-22T07:31:09.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近又在卷八股文，直呼卷不动了啊。这个行业啥时候才能不这么卷？？？</p></blockquote><h2 id="Java-volatile"><a href="#Java-volatile" class="headerlink" title="Java volatile"></a>Java volatile</h2><p>说起八股文，volatile绝对是个老八股，随便拉个人来都能说上两句，什么内存可见性、内存屏障、指令重排序。。。真搞不懂调包侠整这些玩意有啥用。</p><p>既然卷就卷到底，看看这玩意底层到底是在干啥。</p><span id="more"></span><h3 id="字节码层"><a href="#字节码层" class="headerlink" title="字节码层"></a>字节码层</h3><p>先定义一个Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个volatile 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写volatitle 变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读volatitle 变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>javac Test.java</code> ,<code>javap -c -p -v Test.class</code>，得到可读的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">zhaojingzhou</span>.<span class="title">Test</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">4.</span>#<span class="number">17</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">18</span>         <span class="comment">// com/zhaojingzhou/Test.i:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">19</span>            <span class="comment">// com/zhaojingzhou/Test</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">20</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               i</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               set</span><br><span class="line">  #<span class="number">12</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">13</span> = Utf8               get</span><br><span class="line">  #<span class="number">14</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">15</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">16</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// i:I</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               com/internet/zhaojingzhou/Test</span><br><span class="line">  #<span class="number">20</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PRIVATE, ACC_VOLATILE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.zhaojingzhou.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: iload_1</span><br><span class="line">         <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到volatile关键字修饰的变量多了一个flag :<code>ACC_VOLATILE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">   descriptor: I</span><br><span class="line">   flags: ACC_PRIVATE, ACC_VOLATILE</span><br></pre></td></tr></table></figure><p>另外可以看到对于变量的读写指令是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line"><span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br></pre></td></tr></table></figure><h3 id="CPP层"><a href="#CPP层" class="headerlink" title="CPP层"></a>CPP层</h3><p>根据我三脚猫的功夫，在源码中找到了这两个指令相关的内容，位于<code>src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp</code></p><p>（这里说一下，我看的是jdk8的源码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_getfield):</span><br><span class="line">      <span class="built_in">CASE</span>(_getstatic):</span><br><span class="line">        &#123;</span><br><span class="line">          u2 index;</span><br><span class="line">          ConstantPoolCacheEntry* cache;</span><br><span class="line">          index = Bytes::<span class="built_in">get_native_u2</span>(pc+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// QQQ Need to make this as inlined as possible. Probably need to</span></span><br><span class="line">          <span class="comment">// split all the bytecode cases out so c++ compiler has a chance</span></span><br><span class="line">          <span class="comment">// for constant prop to fold everything possible away.</span></span><br><span class="line"></span><br><span class="line">          cache = cp-&gt;<span class="built_in">entry_at</span>(index);</span><br><span class="line">          <span class="comment">// 这里省略了一些代码</span></span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;<span class="built_in">is_volatile</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">              OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (tos_type) &#123;</span><br><span class="line">              <span class="keyword">case</span> btos:</span><br><span class="line">              <span class="keyword">case</span> ztos:</span><br><span class="line">                <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">byte_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ctos:</span><br><span class="line">                <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">char_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> stos:</span><br><span class="line">                <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">short_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> itos:</span><br><span class="line">                <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">int_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ftos:</span><br><span class="line">                <span class="built_in">SET_STACK_FLOAT</span>(obj-&gt;<span class="built_in">float_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ltos:</span><br><span class="line">                <span class="built_in">SET_STACK_LONG</span>(obj-&gt;<span class="built_in">long_field_acquire</span>(field_offset), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> dtos:</span><br><span class="line">                <span class="built_in">SET_STACK_DOUBLE</span>(obj-&gt;<span class="built_in">double_field_acquire</span>(field_offset), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> atos: &#123;</span><br><span class="line">                oop val = obj-&gt;<span class="built_in">obj_field_acquire</span>(field_offset);</span><br><span class="line">                <span class="built_in">VERIFY_OOP</span>(val);</span><br><span class="line">                <span class="built_in">SET_STACK_OBJECT</span>(val, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里有几行这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache-&gt;<span class="built_in">is_volatile</span>()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">             OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>首先<code>is_volatile</code>判断是否volatile变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/hotspot/share/runtime/fieldDescriptor.hpp</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_volatile</span><span class="params">()</span>              <span class="keyword">const</span>    </span>&#123; <span class="keyword">return</span> <span class="built_in">access_flags</span>().<span class="built_in">is_volatile</span>(); &#125;</span><br><span class="line"><span class="comment">//这里的access_flags对应的就是上面字节码中ACC_开头的哪些flag。</span></span><br></pre></td></tr></table></figure><p>好了，总算看到八股文里面说的内存屏障了<code>OrderAccess::fence()</code>。</p><p>咦，咋肥事，咋外面还套了个if。也就是说，<code>并不是所有情况下都加了内存屏障</code>。那<code>support_IRIW_for_not_multiple_copy_atomic_cpu</code> 这个玩意到底是个啥？从这个变量里似乎可以拆除两个东西，一个是<code>multiple_copy_atomic</code>，另一个是<code>IRIW</code>。关于这两个东西，在中文资源里能查找到的东西非常少，特别是IRIW。</p><h2 id="MCA模型（multi-copy-atomicity）"><a href="#MCA模型（multi-copy-atomicity）" class="headerlink" title="MCA模型（multi-copy atomicity）"></a>MCA模型（multi-copy atomicity）</h2><p>从为数不多的<a href="https://zhuanlan.zhihu.com/p/150879932">中文资源</a>中找到如下说法：</p><p>那怎么样才称为multi-copy atomicity呢？不正式但易于理解的说法是</p><blockquote><p>When a write is visible to one thread other than its originating thread, it is visible to all other threads.</p></blockquote><p>翻译过来就是：<code>一个存储器写要么不被其他硬件线程看到，要是有一个看到了，那么就表示其他硬件线程都看到了</code>。</p><p>这个定义其实和ARM文档里的multi-copy atomicity不一致，ARM文档里MCA的定义要更严格：发出存储器写的硬件线程自己也看不到这个写，除非其他硬件线程也看到了。这其实区别就在于是不是允许自己的写forward给自己的读。如果允许，就是通常的MCA定义，否则就是ARM文档里的定义。ARM文档把这种约束不甚严格的MCA称为“other-multicopy-atomic”。这也是困扰了我很久的一个问题。</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/lgfp8bug9v-1640850839744.png"></p><p>对于上图这个例子，MCA模型不可能最后Thread1和Thread3最后读到的y和x都是0的，因为这个结果表明Thread1看到a而没看到d；但Thread3看到d而没看到a，这是不符合MCA的定义的。而对于Non-MCA，上图的结果是可能的。</p><p>卧槽，上面说的不就是内存可见性的问题吗？？？</p><h2 id="IRIW"><a href="#IRIW" class="headerlink" title="IRIW"></a>IRIW</h2><p>那啥又是IRIW呢？“百度”出来的结果如下：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/oltrtxrtaj-1640851680307.png"></p><p>TOP5，唯一一个看着靠谱一点的结果，点进去一看：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/5799w94r3e-1640851815354.png"></p><p>这啥呀。。。。</p><p>但是也不是一点没用，至少知道了这个缩写代表的是<code>Independent Reads, Independent Writes </code></p><p>但这玩意到底是个啥呢？最后我找到了一个<a href="http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/ec209.pdf">论文</a>，里面有一段内容：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/ihbdolegte-1640853204253.png"></p><p>里面说到了一个IRIW example：</p><p>有4个proc，0、1、2、3。proc0将x=1，proc1将y=1，proc2读到x=1，y=0，proc3读到y=1，x=0。</p><p>我寻思，IRIW难道就是MCA的反义？</p><p>后面又举了一个JMM的例子：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/bwfiu07fn8-1640855045159.png"></p><p>说的大概就是HotSpot之内的编译器会优化代码，将x=(r2==1)?y:1 优化为x=1，并优化了两个指令的位置，x=1跑r2=y前面去了。</p><p>IRIW又有独立指令重排的意思？？</p><p>说实话看完我还是迷糊的，但是回到前面的那个条件：<code>support_IRIW_for_not_multiple_copy_atomic_cpu</code>，大概能明白意思了，应该是指支持IRIW而不是MCA的CPU就使用fence。</p><h2 id="OrderAccess"><a href="#OrderAccess" class="headerlink" title="OrderAccess"></a>OrderAccess</h2><p><code>/src/hotspot/share/runtime/orderAccess.hpp</code>中定义了一些内存屏障，具体的实现，不同的架构又不一样，linux_x86如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/hotspot/os_cpu/linux_x86/orderAccess_linux_x86.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title">compiler_barrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> : : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::loadload()   &#123; compiler_barrier(); &#125;</span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::storestore() &#123; compiler_barrier(); &#125;</span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::loadstore()  &#123; compiler_barrier(); &#125;</span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::storeload()  &#123; fence();            &#125;</span><br><span class="line"></span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::acquire()    &#123; compiler_barrier(); &#125;</span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::release()    &#123; compiler_barrier(); &#125;</span><br><span class="line"></span><br><span class="line">inline <span class="keyword">void</span> OrderAccess::fence() &#123;</span><br><span class="line">   <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line">#<span class="function">ifdef AMD64</span></span><br><span class="line"><span class="function">  __asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">#<span class="function">endif</span></span><br><span class="line"><span class="function">  <span class="title">compiler_barrier</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>lock; addl</code>是关键 。</p><p>lock前缀是一个特殊的信号，执行过程如下：</p><p>对总线和缓存上锁。<br><code>强制所有lock信号之前的指令，都在此之前被执行，并同步相关缓存</code>。<br>执行lock后的指令（如cmpxchg）。<br>释放对总线和缓存上的锁。<br><code>强制所有lock信号之后的指令，都在此之后被执行，并同步相关缓存</code>。<br>因此，lock信号虽然不是内存屏障，但具有<code>mfence</code>的语义（当然，还有排他性的语义）。</p><p>与内存屏障相比，lock信号要额外对总线和缓存上锁，成本更高</p><p>而这里lock 后跟的是addl指令，对一个寄存器中的值加了0。然而通过lock信号的作用，实现了内存屏障的效果。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/150879932">https://zhuanlan.zhihu.com/p/150879932</a></p><p><a href="http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/ec209.pdf">http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/ec209.pdf</a></p><p><a href="https://www.cnblogs.com/sunddenly/articles/14829255.html">https://www.cnblogs.com/sunddenly/articles/14829255.html</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>卷得脑壳疼。。。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近又在卷八股文，直呼卷不动了啊。这个行业啥时候才能不这么卷？？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Java-volatile&quot;&gt;&lt;a href=&quot;#Java-volatile&quot; class=&quot;headerlink&quot; title=&quot;Java volatile&quot;&gt;&lt;/a&gt;Java volatile&lt;/h2&gt;&lt;p&gt;说起八股文，volatile绝对是个老八股，随便拉个人来都能说上两句，什么内存可见性、内存屏障、指令重排序。。。真搞不懂调包侠整这些玩意有啥用。&lt;/p&gt;
&lt;p&gt;既然卷就卷到底，看看这玩意底层到底是在干啥。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="IRIW" scheme="https://jingzhouzhao.github.io/tags/IRIW/"/>
    
    <category term="CPU" scheme="https://jingzhouzhao.github.io/tags/CPU/"/>
    
    <category term="volatile" scheme="https://jingzhouzhao.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>使用Python脚本自动订餐</title>
    <link href="https://jingzhouzhao.github.io/archives/5f3e8b9e.html"/>
    <id>https://jingzhouzhao.github.io/archives/5f3e8b9e.html</id>
    <published>2021-12-24T02:47:31.000Z</published>
    <updated>2022-02-22T07:31:09.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司员工餐选用的美餐平台，但是经常由于太忙忘记点餐，导致饿着肚子加班。反正菜品的可选项比较少，想着要是能自动点一个就好了。于是有了以下脚本。</p></blockquote><h2 id="接口分析"><a href="#接口分析" class="headerlink" title="接口分析"></a>接口分析</h2><h3 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h3><p>自动点餐无非就是模拟人的行为，自动请求一些关键接口。于是分析了一下美餐网的web端接口，发现关键接口如下：</p><ol><li>获取菜单接口：<a href="https://meican.com/preorder/api/v2.1/restaurants/show?tabUniqueId=???&amp;targetTime=???&amp;restaurantUniqueId=???&amp;client_id=???&amp;client_secret=">https://meican.com/preorder/api/v2.1/restaurants/show?tabUniqueId=???&amp;targetTime=???&amp;restaurantUniqueId=???&amp;client_id=???&amp;client_secret=</a>???</li><li>下单接口：<a href="https://meican.com/preorder/api/v2.1/orders/add?client_id=???&amp;client_secret=">https://meican.com/preorder/api/v2.1/orders/add?client_id=???&amp;client_secret=</a>???</li></ol><p>有了接口只是第一步，第二步开始分析、尝试接口的哪些参数是静态的，哪些是动态的。</p><span id="more"></span><p>首先通过多个请求，可以得知，上述两个关键接口中的<strong>client_id</strong>、<strong>client_secret</strong>是静态的固定不变的，猜测可能是web端的身份。</p><p>然后第一个接口中的<strong>restaurantUniqueId</strong>可以发现多次请求并没发生变化，并且通过命名基本可以得出，应该是类似企业食堂在美餐那边的一个唯一id。</p><p>第一个接口中的<strong>targetTime</strong>，通过数据样例分析，以及对比其他非关键接口数据，可以得知，应该是企业在美餐网设置的点餐截止时间。例如我们公司配置的是早餐6:00截止点餐，那么这个<strong>targetTime</strong>就是 yyyy-MM-dd +06:00。</p><p>最后第一个接口还有一个参数<strong>tabUniqueId</strong> ，最开始我以为是完全静态的，后面通过踩坑得知，这个应该是代表每一餐的唯一id，早、中、晚均不一样。</p><h3 id="响应分析"><a href="#响应分析" class="headerlink" title="响应分析"></a>响应分析</h3><p>第一个接口拿到的关键响应如下(忽略了一些)：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dishList&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;dishSectionId&quot;</span>: xxxx,</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: xxxx,</span><br><span class="line">            <span class="attr">&quot;isSection&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;晚餐&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;originalPriceInCent&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;priceInCent&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;priceString&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;dishSectionId&quot;</span>: xxxx,</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: y1,</span><br><span class="line">            <span class="attr">&quot;isSection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;周五 水饺&amp;花生米拌黄瓜&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;originalPriceInCent&quot;</span>: <span class="number">1100</span>,</span><br><span class="line">            <span class="attr">&quot;priceInCent&quot;</span>: <span class="number">1100</span>,</span><br><span class="line">            <span class="attr">&quot;priceString&quot;</span>: <span class="string">&quot;11&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;dishSectionId&quot;</span>: xxxx,</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: y2,</span><br><span class="line">            <span class="attr">&quot;isSection&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;周五 A套餐 小鸡炖蘑菇&amp;干炸小黄鱼&amp;肉沫豆腐&amp;土豆片炒肉&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;originalPriceInCent&quot;</span>: <span class="number">1100</span>,</span><br><span class="line">            <span class="attr">&quot;priceInCent&quot;</span>: <span class="number">1100</span>,</span><br><span class="line">            <span class="attr">&quot;priceString&quot;</span>: <span class="string">&quot;11&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>这个需要结合第二个接口参数来分析，哪些是有用的信息，第二个接口的请求参数如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;corpAddressRemark&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;corpAddressUniqueId&quot;</span>:<span class="string">&quot;xxxx&quot;</span>,<span class="attr">&quot;order&quot;</span>:orderP,<span class="attr">&quot;remarks&quot;</span>:remarkP,<span class="attr">&quot;tabUniqueId&quot;</span>:uu[&#x27;tab&#x27;],<span class="attr">&quot;targetTime&quot;</span>:targetTime,<span class="attr">&quot;userAddressUniqueId&quot;</span>:<span class="string">&quot;xxxx&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>其中<strong>targetTime</strong>应该与第一个接口的一致。<strong>remarks</strong>没懂到底有没有用，<strong>tabUniqueId</strong>跟上个接口也是一致。最后<strong>order</strong>是跟第一个接口响应有关的，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">&quot;count&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;dishId&quot;</span>:y1&#125;]</span><br></pre></td></tr></table></figure><p>其中<strong>dishId</strong>就是第一个接口<strong>dishList</strong>中的<strong>id</strong>。好了关键信息有了，接下来就可以开始编写脚本了。</p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>脚本就不废话了，由于Python不是主力语言，平时写的少，而且由于是摸鱼时间🐟来写的，所以写的比较粗糙和不规范。🤦‍♂️</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tomorrow = (datetime.datetime.now()+datetime.timedelta(days=<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tomorrow:&quot;</span>, tomorrow)</span><br><span class="line">headers=&#123;&#125;</span><br><span class="line">headers1=&#123;&#125;</span><br><span class="line">headers2=&#123;&#125;</span><br><span class="line">headers3=&#123;&#125;</span><br><span class="line"></span><br><span class="line">user1=&#123;<span class="string">&#x27;headers&#x27;</span>:headers,<span class="string">&#x27;phone&#x27;</span>:<span class="string">&#x27;xxxxx&#x27;</span>,<span class="string">&#x27;tab&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">user2=&#123;<span class="string">&#x27;headers&#x27;</span>:headers1,<span class="string">&#x27;phone&#x27;</span>:<span class="string">&#x27;xxxxx&#x27;</span>,<span class="string">&#x27;tab&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">user3=&#123;<span class="string">&#x27;headers&#x27;</span>:headers2,<span class="string">&#x27;phone&#x27;</span>:<span class="string">&#x27;xxxxx&#x27;</span>,<span class="string">&#x27;tab&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">user4=&#123;<span class="string">&#x27;headers&#x27;</span>:headers3,<span class="string">&#x27;phone&#x27;</span>:<span class="string">&#x27;xxxxx&#x27;</span>,<span class="string">&#x27;tab&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">users=[user1,user2,user3,user4]</span><br><span class="line"></span><br><span class="line">add_url=<span class="string">&quot;https://meican.com/preorder/api/v2.1/orders/add?client_id=xxxx&amp;client_secret=xxxx&quot;</span></span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(users)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        count=count+<span class="number">1</span></span><br><span class="line">        uu = users[i]</span><br><span class="line">        url = <span class="string">&quot;https://meican.com/preorder/api/v2.1/restaurants/show?tabUniqueId=&quot;</span>+uu[<span class="string">&#x27;tab&#x27;</span>]+<span class="string">&quot;&amp;targetTime=&quot;</span> + tomorrow + <span class="string">&quot;+06:00&amp;restaurantUniqueId=xxxx&amp;client_id=xxxx&amp;client_secret=xxxx&quot;</span></span><br><span class="line">        r = requests.get(url, headers=uu[<span class="string">&#x27;headers&#x27;</span>])</span><br><span class="line">        data = json.loads(r.content)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;dishList&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">            bData = data[<span class="string">&#x27;dishList&#x27;</span>][<span class="number">1</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">            aAata = data[<span class="string">&#x27;dishList&#x27;</span>][<span class="number">2</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">1</span>:</span><br><span class="line">              <span class="comment"># 发送企业微信通知</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;发通知&quot;</span>)</span><br><span class="line">                botData=json.dumps(&#123;<span class="string">&quot;msgtype&quot;</span>:<span class="string">&quot;text&quot;</span>,<span class="string">&quot;text&quot;</span>:&#123;<span class="string">&quot;content&quot;</span>:<span class="string">&quot;明日早餐：\r\n&quot;</span>+bData+<span class="string">&quot;\r\n&quot;</span>+aAata,<span class="string">&quot;mentioned_list&quot;</span>:[<span class="string">&quot;@all&quot;</span>]&#125;&#125;)</span><br><span class="line">                botR = requests.post(url=<span class="string">&#x27;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxx&#x27;</span>, data=botData, headers=&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/json;charset=utf-8&quot;</span>&#125;)</span><br><span class="line">                <span class="built_in">print</span>(botR.content)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;menu: &quot;</span>, aAata, bData)</span><br><span class="line">            bDataId=<span class="built_in">str</span>(data[<span class="string">&#x27;dishList&#x27;</span>][<span class="number">1</span>][<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">            targetTime = tomorrow + <span class="string">&#x27; 06:00&#x27;</span>;</span><br><span class="line">            orderP = <span class="string">&quot;[&#123;\&quot;count\&quot;:1,\&quot;dishId\&quot;:&quot;</span>+bDataId+<span class="string">&quot;&#125;]&quot;</span></span><br><span class="line">            remarkP = <span class="string">&quot;[&#123;\&quot;dishId\&quot;:\&quot;&quot;</span>+bDataId+<span class="string">&quot;\&quot;,\&quot;remark\&quot;:\&quot;\&quot;&#125;]&quot;</span></span><br><span class="line">            postData = &#123;<span class="string">&quot;corpAddressRemark&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;corpAddressUniqueId&quot;</span>:<span class="string">&quot;xxxxx&quot;</span>,<span class="string">&quot;order&quot;</span>:orderP,<span class="string">&quot;remarks&quot;</span>:remarkP,<span class="string">&quot;tabUniqueId&quot;</span>:uu[<span class="string">&#x27;tab&#x27;</span>],<span class="string">&quot;targetTime&quot;</span>:targetTime,<span class="string">&quot;userAddressUniqueId&quot;</span>:<span class="string">&quot;xxxxx&quot;</span>&#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;当前用户:&#x27;</span>,uu[<span class="string">&#x27;phone&#x27;</span>])</span><br><span class="line">            ar = requests.post(url=add_url, data=postData, headers=uu[<span class="string">&#x27;headers&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(ar.content)</span><br><span class="line">            data2 = json.loads(ar.content)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;status&#x27;</span> <span class="keyword">in</span> data2:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;SUCCESSFUL&#x27;</span>==data2[<span class="string">&#x27;status&#x27;</span>]:</span><br><span class="line">                    botData2 = json.dumps(&#123;<span class="string">&quot;msgtype&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;text&quot;</span>: &#123;<span class="string">&quot;content&quot;</span>: <span class="string">&quot;已为尊贵的会员点餐成功&quot;</span>, <span class="string">&quot;mentioned_mobile_list&quot;</span>: [uu[<span class="string">&#x27;phone&#x27;</span>]]&#125;&#125;)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;成功通知：&quot;</span>, botData2)</span><br><span class="line">                     <span class="comment"># 发送企业微信通知</span></span><br><span class="line">                    botR2 = requests.post(url=<span class="string">&#x27;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxx&#x27;</span>,data=botData2, headers=&#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json;charset=utf-8&quot;</span>&#125;)</span><br><span class="line">                    <span class="built_in">print</span>(botR2.content)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;点餐成功！&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;点餐失败！&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;点餐失败！&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;无可用信息:&#x27;</span>, data)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>最后由于本人用的Mac，所以直接使用了<code>launchctl</code>。</p><h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><p>首先进入<code>~/Library/LaunchAgents</code>,在目录下创建一个文件<code>com.meican.plist</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.meican.plist<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/zhaojingzhou/workspace/sources/meican.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StartCalendarInterval<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>Minute<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">integer</span>&gt;</span>00<span class="tag">&lt;/<span class="name">integer</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>Hour<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">integer</span>&gt;</span>16<span class="tag">&lt;/<span class="name">integer</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- &lt;key&gt;Day&lt;/key&gt;</span></span><br><span class="line"><span class="comment">      &lt;integer&gt;*&lt;/integer&gt;  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>Weekday<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>1<span class="tag">&lt;/<span class="name">integer</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>2<span class="tag">&lt;/<span class="name">integer</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>3<span class="tag">&lt;/<span class="name">integer</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>4<span class="tag">&lt;/<span class="name">integer</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>7<span class="tag">&lt;/<span class="name">integer</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/zhaojingzhou/workspace/sources/stdout<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/zhaojingzhou/workspace/sources/error<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ProgramArguments"><a href="#ProgramArguments" class="headerlink" title="ProgramArguments"></a>ProgramArguments</h3><p>任务执行的脚本，我这里用shell 将上面写的Python脚本包了一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/python3.9 /Users/zhaojingzhou/workspace/sources/meican.py</span><br></pre></td></tr></table></figure><p>脚本一定要给执行权限啊</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 xxx.sh</span><br></pre></td></tr></table></figure><h3 id="StartCalendarInterval"><a href="#StartCalendarInterval" class="headerlink" title="StartCalendarInterval"></a>StartCalendarInterval</h3><p>我这里定义的是周1，2，3，4，7下午16:00执行。需要注意的是0，7都代表周日。</p><h2 id="OutPath"><a href="#OutPath" class="headerlink" title="OutPath"></a>OutPath</h2><p>StandardOutPath，StandardErrorPath 代表标准输出，和错误输出，用来排查脚本错误。</p><h3 id="加载任务"><a href="#加载任务" class="headerlink" title="加载任务"></a>加载任务</h3><p>所有的的都准备好了之后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl load -w com.meican.plist</span><br></pre></td></tr></table></figure><p>如果修改了任务定义需要unload之后在load，unload：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl unload com.meican.plist</span><br></pre></td></tr></table></figure><p>如果想立即执行一次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl start com.meican.plist</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>目前跑了一段时间下来，感觉还行，再也不用饿肚子啦。。。</p><p>希望美餐别调整接口。。。</p><p><strong>码字不易，且看且珍惜</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;公司员工餐选用的美餐平台，但是经常由于太忙忘记点餐，导致饿着肚子加班。反正菜品的可选项比较少，想着要是能自动点一个就好了。于是有了以下脚本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;接口分析&quot;&gt;&lt;a href=&quot;#接口分析&quot; class=&quot;headerlink&quot; title=&quot;接口分析&quot;&gt;&lt;/a&gt;接口分析&lt;/h2&gt;&lt;h3 id=&quot;参数分析&quot;&gt;&lt;a href=&quot;#参数分析&quot; class=&quot;headerlink&quot; title=&quot;参数分析&quot;&gt;&lt;/a&gt;参数分析&lt;/h3&gt;&lt;p&gt;自动点餐无非就是模拟人的行为，自动请求一些关键接口。于是分析了一下美餐网的web端接口，发现关键接口如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取菜单接口：&lt;a href=&quot;https://meican.com/preorder/api/v2.1/restaurants/show?tabUniqueId=???&amp;amp;targetTime=???&amp;amp;restaurantUniqueId=???&amp;amp;client_id=???&amp;amp;client_secret=&quot;&gt;https://meican.com/preorder/api/v2.1/restaurants/show?tabUniqueId=???&amp;amp;targetTime=???&amp;amp;restaurantUniqueId=???&amp;amp;client_id=???&amp;amp;client_secret=&lt;/a&gt;???&lt;/li&gt;
&lt;li&gt;下单接口：&lt;a href=&quot;https://meican.com/preorder/api/v2.1/orders/add?client_id=???&amp;amp;client_secret=&quot;&gt;https://meican.com/preorder/api/v2.1/orders/add?client_id=???&amp;amp;client_secret=&lt;/a&gt;???&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了接口只是第一步，第二步开始分析、尝试接口的哪些参数是静态的，哪些是动态的。&lt;/p&gt;</summary>
    
    
    
    <category term="Python随记" scheme="https://jingzhouzhao.github.io/categories/Python%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://jingzhouzhao.github.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://jingzhouzhao.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="定时任务" scheme="https://jingzhouzhao.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="launchctl" scheme="https://jingzhouzhao.github.io/tags/launchctl/"/>
    
  </entry>
  
  <entry>
    <title>关于Paxos那些点</title>
    <link href="https://jingzhouzhao.github.io/archives/e00e37d3.html"/>
    <id>https://jingzhouzhao.github.io/archives/e00e37d3.html</id>
    <published>2021-12-16T06:07:48.000Z</published>
    <updated>2022-02-22T07:31:09.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>世界上只有一种共识协议，就是 Paxos，其他所有共识算法都是 Paxos 的退化版本。</p></blockquote><p>Paxos分为Basic Paxos、Multi Paxos、和其它演进版本。</p><h1 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h1><p><strong>前提：Basic Paxos 只能对单个值形成决议。</strong></p><p>Paxos 算法将分布式系统中的节点分为三类：</p><ul><li><strong>提案节点</strong>：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称之为<strong>提案</strong>（Proposal），值一旦设置成功，就是不会丢失也不可变的。请注意，Paxos 是典型的基于操作转移模型而非状态转移模型来设计的算法，这里的“设置值”不要类比成程序中变量赋值操作，应该类比成日志记录操作，在后面介绍的 Raft 算法中就直接把“提案”叫作“日志”了。</li><li><strong>决策节点</strong>：称为 Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被<strong>批准</strong>（Accept），提案被批准即意味着该值不能再被更改，也不会丢失，且最终所有节点都会接受该它。</li><li><strong>记录节点</strong>：被称为 Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。</li></ul><span id="more"></span><p>Paxos 算法包括两个阶段，其中，<strong>第一阶段“准备”（Prepare）</strong>就相当于上面抢占锁的过程（不是基于互斥量）。如果某个提案节点准备发起提案，必须先向所有的决策节点广播一个许可申请（称为 Prepare 请求）。提案节点的 Prepare 请求中会附带一个全局唯一的数字 n 作为提案 ID，决策节点收到后，将会给予<strong>提案节点两个承诺与一个应答</strong>。</p><p>两个承诺是指：</p><ul><li>承诺不会再接受提案 ID 小于或等于 n 的 Prepare 请求。</li><li>承诺不会再接受提案 ID 小于 n 的 Accept 请求。</li></ul><p>一个应答是指：</p><ul><li>不违背以前作出的承诺的前提下，回复已经批准过的提案中 ID 最大的那个提案所设定的值和提案 ID，如果该值从来没有被任何提案设定过，则返回空值。如果违反此前做出的承诺，即收到的提案 ID 并不是决策节点收到过的最大的，那允许直接对此 Prepare 请求不予理会。</li></ul><p>当提案节点收到了多数派决策节点的应答（称为 Promise 应答）后，可以开始<strong>第二阶段“批准”（Accept）</strong>过程，这时有如下两种可能的结果：</p><ul><li>如果提案节点发现所有响应的决策节点此前都没有批准过该值（即为空），那说明它是第一个设置值的节点，可以随意地决定要设定的值，将自己选定的值与提案 ID，构成一个二元组“(id, value)”，再次广播给全部的决策节点（称为 Accept 请求）。</li><li>如果提案节点发现响应的决策节点中，已经有至少一个节点的应答中包含有值了，那它就不能够随意取值了，必须无条件地从应答中找出提案 ID 最大的那个值并接受，构成一个二元组“(id, maxAcceptValue)”，再次广播给全部的决策节点（称为 Accept 请求）。</li></ul><p>当每一个决策节点收到 Accept 请求时，都会在不违背以前作出的承诺的前提下，接收并持久化对当前提案 ID 和提案附带的值。如果违反此前做出的承诺，即收到的提案 ID 并不是决策节点收到过的最大的，那允许直接对此 Accept 请求不予理会。</p><p>关于<strong>活锁</strong>：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/jc4j75h9ha-1639635295709.png">两个提案节点互不相让地争相提出自己的提案，抢占同一个值的修改权限，导致整个系统在持续性地“反复横跳”，外部看起来就像被锁住了一样</p><h1 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h1><p>Multi Paxos 对 Basic Paxos 的核心改进是<strong>增加了“选主”的过程</strong>，提案节点会通过定时轮询（心跳），确定当前网络中的所有节点里是否存在有一个主提案节点，一旦没有发现主节点存在，节点就会在心跳超时后<strong>使用 Basic Paxos 中定义的准备、批准的两轮网络交互过程，向所有其他节点广播自己希望竞选主节点的请求</strong>，希望整个分布式系统对“由我作为主节点”这件事情协商达成一致共识，如果得到了决策节点中多数派的批准，便宣告竞选成功。当选主完成之后，除非主节点失联之后发起重新竞选，否则从此往后，就只有主节点本身才能够提出提案。此时，无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是<strong>经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程。也可以通俗理解为选主过后，就不会再有其他节点与它竞争，相当于是处于无并发的环境当中进行的有序操作，所以此时系统中要对某个值达成一致，只需要进行一次批准的交互即可</strong></p><p>可能有人注意到这时候的二元组(id, value)已经变成了三元组(id, i, value)，这是因为需要给<strong>主节点增加一个“任期编号”，这个编号必须是严格单调递增的，以应付主节点陷入网络分区后重新恢复，但另外一部分节点仍然有多数派，且已经完成了重新选主的情况，此时必须以任期编号大的主节点为准</strong>。当节点有了选主机制的支持，在整体来看，就可以进一步简化节点角色，不去区分提案、决策和记录节点了，统统以“节点”来代替，节点只有主（Leader）和从（Follower）的区别</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="http://icyfenix.cn/distribution/consensus/paxos.html">http://icyfenix.cn/distribution/consensus/paxos.html</a></p><p><a href="http://icyfenix.cn/distribution/consensus/raft.html">http://icyfenix.cn/distribution/consensus/raft.html</a></p><p><a href="https://acehi.github.io/thesecretlivesofdata-cn/raft/">https://acehi.github.io/thesecretlivesofdata-cn/raft/</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;世界上只有一种共识协议，就是 Paxos，其他所有共识算法都是 Paxos 的退化版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Paxos分为Basic Paxos、Multi Paxos、和其它演进版本。&lt;/p&gt;
&lt;h1 id=&quot;Basic-Paxos&quot;&gt;&lt;a href=&quot;#Basic-Paxos&quot; class=&quot;headerlink&quot; title=&quot;Basic Paxos&quot;&gt;&lt;/a&gt;Basic Paxos&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前提：Basic Paxos 只能对单个值形成决议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Paxos 算法将分布式系统中的节点分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提案节点&lt;/strong&gt;：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称之为&lt;strong&gt;提案&lt;/strong&gt;（Proposal），值一旦设置成功，就是不会丢失也不可变的。请注意，Paxos 是典型的基于操作转移模型而非状态转移模型来设计的算法，这里的“设置值”不要类比成程序中变量赋值操作，应该类比成日志记录操作，在后面介绍的 Raft 算法中就直接把“提案”叫作“日志”了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;决策节点&lt;/strong&gt;：称为 Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被&lt;strong&gt;批准&lt;/strong&gt;（Accept），提案被批准即意味着该值不能再被更改，也不会丢失，且最终所有节点都会接受该它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录节点&lt;/strong&gt;：被称为 Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Paxos" scheme="https://jingzhouzhao.github.io/tags/Paxos/"/>
    
    <category term="一致性" scheme="https://jingzhouzhao.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>博客用的图床挂了</title>
    <link href="https://jingzhouzhao.github.io/archives/2baffaa5.html"/>
    <id>https://jingzhouzhao.github.io/archives/2baffaa5.html</id>
    <published>2021-12-01T09:35:02.000Z</published>
    <updated>2022-02-22T07:31:09.022Z</updated>
    
    <content type="html"><![CDATA[<p>之前不想把博客里面的图片也一同上传，用了utools里面一个默认的免费图床，结果今天发现好像图床挂掉了。之前写的博客里面的图片全挂了。。。果断换了gitee做新的图床。</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/l19rbp0xbd-1638351541087.png"></p><p>这不会再挂了吧。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前不想把博客里面的图片也一同上传，用了utools里面一个默认的免费图床，结果今天发现好像图床挂掉了。之前写的博客里面的图片全挂了。。。果断换了gitee做新的图床。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zhaojingzhou/file</summary>
      
    
    
    
    <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="图床" scheme="https://jingzhouzhao.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="博客" scheme="https://jingzhouzhao.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Mapper 源码分析</title>
    <link href="https://jingzhouzhao.github.io/archives/fb5cf917.html"/>
    <id>https://jingzhouzhao.github.io/archives/fb5cf917.html</id>
    <published>2021-09-22T06:26:02.000Z</published>
    <updated>2022-02-22T07:31:09.009Z</updated>
    
    <content type="html"><![CDATA[<p>天天都在用的Mybatis，为啥调用一个Mapper接口就能执行SQL，你有没有想过这个问题？</p><p>这一切都得从 <code>@MapperScan</code> 这个注解开始说起。打开这个注解定义可以看到：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;MapperScannerRegistrar.class&#125;)</span></span><br></pre></td></tr></table></figure><p>上面的元注解中重点关注<code>@Import(MapperScannerRegistrar.class)</code>，这是Spring的一个注解，允许导入@Configuration类、 ImportSelector和ImportBeanDefinitionRegistrar实现。很明显<code>MapperScannerRegistrar.class</code> 应该是<code>ImportBeanDefinitionRegistrar</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">&quot;annotationClass&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">&quot;markerInterface&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">&quot;factoryBean&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">&quot;basePackages&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : annoAttrs.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">      basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面代码在做一件事，就是初始化<code>ClassPathMapperScanner</code>，最后调用了<code>doScan</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages) + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先调用了父类的doScan，里面的主要逻辑是查找指定的basePackages下的所有Components，即声明了<code>@Component</code>以及将<code>@Component</code>作为元注解的注解，例如<code>@Repository</code>，<br>感兴趣的可以看看：</p><ul><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents</li><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(org.springframework.core.type.classreading.MetadataReader)</li><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters</li><li>org.springframework.core.type.filter.AnnotationTypeFilter#hasAnnotation</li><li>org.springframework.core.annotation.AnnotationUtils#getAnnotation(java.lang.reflect.AnnotatedElement, java.lang.Class<A>)</A></li></ul><p>接下来调用了<code>processBeanDefinitions</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() </span><br><span class="line">          + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + definition.getBeanClassName() + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(<span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(<span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点看看这两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); </span><br><span class="line">definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br></pre></td></tr></table></figure><p>似乎已经可以看出点蛛丝马迹，这里将Mapper的BeanDefinition的BeanClass替换为了<code>this.mapperFactoryBean.getClass()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MapperFactoryBean&lt;?&gt; mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p>并且将原本的BeanClass添加为了构造函数参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); </span><br></pre></td></tr></table></figure><p>熟悉Spring的应该都知道，Spring加载完BeanDefinition后会通过BeanClass来去实例化Bean，这里的BeanClass被替换为了一个FactoryBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addToConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intentionally empty </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">    notNull(<span class="keyword">this</span>.mapperInterface, <span class="string">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Configuration configuration = getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        configuration.addMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class="keyword">this</span>.mapperInterface + <span class="string">&quot;&#x27; to configuration.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------- mutators --------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the mapper interface of the MyBatis mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperInterface class of the interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperInterface</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the mapper interface of the MyBatis mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> class of the interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If addToConfig is false the mapper will not be added to MyBatis. This means</span></span><br><span class="line"><span class="comment">   * it must have been included in mybatis-config.xml.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * If it is true, the mapper will be added to MyBatis in the case it is not already</span></span><br><span class="line"><span class="comment">   * registered.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * By default addToCofig is true.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> addToConfig</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddToConfig</span><span class="params">(<span class="keyword">boolean</span> addToConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addToConfig = addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the flag for addition into MyBatis config.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true if the mapper will be added to MyBatis in the case it is not already</span></span><br><span class="line"><span class="comment">   * registered.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddToConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到之前那个被注册的构造函数参数应该就是在这被使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 关于这个Bean构造函数的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireConstructor</span><br><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>总之，Spring通过构造函数创建了一个 MapperFactoryBean 对象。接下来Spring去初始化这个Bean，Spring对FactoryBean有特殊处理，实际会调用getObject方法返回具体的Bean。<br>感兴趣的可以看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</span><br></pre></td></tr></table></figure><p>这下又回到了MapperFactoryBean中，来看看getObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用了父类getSqlSession()方法获得SqlSession，然后调用getMapper，传入了当前实际的Mapper。通过：</p><ul><li>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration)</li><li>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</li></ul><p>可以知道SqlSession实际的类型应该是<code>DefaultSqlSession</code>，看看getMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又调用了<code>configuration</code>的getMapper，configuration初始化可以看看<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>，<br>我们写的SQL就是在这个里面被解析的。到这里已经基本很清晰了。接着看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//configuration中的getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MapperRegistry中的getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关键就是 <code>MapperProxyFactory</code>了，这个是在 <code>org.apache.ibatis.binding.MapperRegistry#addMapper</code>  时会为每个Mapper绑定一个。<br>看newInstance：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就是说最终Mapper注册到BeanFactory中的是一个代理类<code>MapperProxy</code>，我们知道被代理的方法最终都会被转发到代理类的<code>invoke</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">       <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">       <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">   <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果不是Object类的方法，也不是Mapper接口的default（默认）方法，那么调用的是<code>mapperMethod.execute(sqlSession, args)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到这就差不多了吧？后面已经没啥好说了，基本就是通过statement name找到MappedStatement然后去执行sql了。</p><p>另外一个小知识，Mybatis是怎么在插入之后返回自增主键的？答案就在：</p><ul><li>org.apache.ibatis.executor.statement.PreparedStatementHandler#update</li><li>org.apache.ibatis.executor.keygen.KeyGenerator#processAfter</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>Spring代码实在太难看了，一环套一环，各种递归，必须debug才能看清。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;天天都在用的Mybatis，为啥调用一个Mapper接口就能执行SQL，你有没有想过这个问题？&lt;/p&gt;
&lt;p&gt;这一切都得从 &lt;code&gt;@MapperScan&lt;/code&gt; 这个注解开始说起。打开这个注解定义可以看到：&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>被Chrome一个bug坑了</title>
    <link href="https://jingzhouzhao.github.io/archives/6e43fa1b.html"/>
    <id>https://jingzhouzhao.github.io/archives/6e43fa1b.html</id>
    <published>2021-09-03T08:58:50.000Z</published>
    <updated>2022-02-22T07:31:09.024Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://files.catbox.moe/xbwdlv.png"></p><p>相信Chrome浏览器开发者工具中的Preview你不陌生，但是就这玩意有一个bug。</p><p>事情是这样的，前端跟我说你接口有bug，返回的数据不正确。听到bug，我反手就是一个你会不会用。</p><span id="more"></span><p>他发来了一个截图：</p><p><img src="https://files.catbox.moe/b7x3tw.png"></p><p>我给他返回的json中有一个<code>max</code>字段，值是<code>100000000000000</code> ,正确的应该是<code>99999999999999.99999999999999999999</code>,你先别管为什么是这么个值。</p><p>好了，他拿出证据了，我开始怀疑真的是哪里写的有问题了，一顿查找，发现TMD哪里都没有问题啊，怎么可能，怎么会呢？</p><p>中午的饭都不香了。</p><p>我开始怀疑是网关的问题，网关大佬说没问题。。。。。</p><p>于是拿着请求地址，curl了一下，<code>max:99999999999999.99999999999999999999</code>。卧槽。。。又对了？</p><p>于是我开始怀疑最不可能出问题的浏览器，直到我点开了<code>Response</code> :</p><p><img src="https://files.catbox.moe/kygqzl.png"></p><p>。。。。。。</p><p>反手就是给提了一个bug：</p><p><img src="https://files.catbox.moe/l53ij6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://files.catbox.moe/xbwdlv.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;相信Chrome浏览器开发者工具中的Preview你不陌生，但是就这玩意有一个bug。&lt;/p&gt;
&lt;p&gt;事情是这样的，前端跟我说你接口有bug，返回的数据不正确。听到bug，我反手就是一个你会不会用。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
    <category term="Chrome" scheme="https://jingzhouzhao.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Lambda应用与浅析</title>
    <link href="https://jingzhouzhao.github.io/archives/d53a1750.html"/>
    <id>https://jingzhouzhao.github.io/archives/d53a1750.html</id>
    <published>2021-08-02T12:47:02.000Z</published>
    <updated>2022-02-22T07:31:09.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在Java8之前创建一个线程的写法（之一）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello inner class!&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>通过查看编译后的生成的Class文件，可以得知new Runnable这块会生成一个匿名类：</p><p><img src="https://files.catbox.moe/e1vlbc.png"></p><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final class LambdaTest$1 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    LambdaTest$1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;hello inner class!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java8开始一切都开始变得不同，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello inner class!&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>()-&gt;System.out.println(&quot;hello inner class!&quot;)</code>就是今天的主角<em><strong>lambda表达式</strong></em>!</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Lambda表达式，是一种匿名函数，一开始只有函数式编程语言中有此功能，但是现在已经有越来越多的命令式编程语言中也支持了Lambda表达式。</p><blockquote><p>Lambda表达式不是一个新鲜事，最早支持Lambda表达式的是1958发布的LISP语言。在Java中也存在了快7-8年时间（2014年发布的Java8开始支持），目前Java已经都发布16。</p></blockquote><p>Lambda表达式简化匿名内部类的书写，但Lambda表达式并不能取代所有的匿名内部类，只能用来取代<strong>函数接口（Functional Interface）</strong>的简写。</p><p>说到函数接口，那么来看下什么是函数接口，看看最开始的例子里出现的<em><strong>Runnable</strong></em>  ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看另外一个<strong>Comparable</strong> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public int compareTo(T o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现了什么？只有一个[抽象]方法的接口即是函数接口。</p><p><code>@FunctionalInterface</code> 并不是必须的，加上此注解可以让编译器帮你check当前定义的是不是正确的函数接口：</p><p><img src="/Users/zhaojingzhou/Library/Application%20Support/typora-user-images/image-20211201171908933.png"></p><p>Java8 引入Lambda表达式的同时也定义了很多新的函数接口，适用于大部分场景：</p><p><img src="https://files.catbox.moe/qptsmq.png"></p><p>也就是说Java8中的Lambda表达式不可以随意乱写，必须有与其对应的函数接口定义，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a, b) -&gt; a + b;</span><br></pre></td></tr></table></figure><p>如果在JDK中找不到对应的函数接口，我们可以自定义一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface TwoParamsOneResultFunction &#123;</span><br><span class="line"></span><br><span class="line">    Integer get(Integer p1, Integer p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>下面来通过一个实例看看Lambda表达式的应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private static boolean sync2Es(List&lt;Long&gt; result, EsIndexEnum esIndexEnum, boolean isAsync) &#123;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;同步&#123;&#125;至ES，idList:&#123;&#125;,isAsync:&#123;&#125;&quot;, JSON.toJSONString(esIndexEnum), JSON.toJSONString(result), isAsync);</span><br><span class="line"></span><br><span class="line">    if (esIndexEnum == null) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CollectionUtils.isEmpty(result)) &#123;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //es最多支持一次同步3000条，所以需要拆分</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Long&gt;&gt; partition = Lists.partition(StreamUtils.safeList(result), AssetsConstant.MAX_BATCH_SYNC_SIZE);</span><br><span class="line"></span><br><span class="line">    //es支持同步和异步，按需选择</span><br><span class="line"></span><br><span class="line">    EsSyncProcessorInstance instance = EsSyncProcessorFactory.getInstance(esIndexEnum.getIndexClass());</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; esFunction = getEsSyncFunction(isAsync);</span><br><span class="line"></span><br><span class="line">    boolean esResult = StreamUtils.allMatch(StreamUtils.listToList(partition, ids -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        EsResult&lt;BulkMessage&gt; bulkMessageEsResult = esFunction.apply(instance, ids);</span><br><span class="line"></span><br><span class="line">        //es可能失败，重试一次，如果还是不行那估计就是大问题了。</span><br><span class="line"></span><br><span class="line">        if (!bulkMessageEsResult.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(&quot;同步ES失败:&#123;&#125;,重试一次&quot;, JSON.toJSONString(bulkMessageEsResult));</span><br><span class="line"></span><br><span class="line">            bulkMessageEsResult = esFunction.apply(instance, StreamUtils.listToList(StreamUtils.safeGetField(bulkMessageEsResult.getValue(), BulkMessage::getFailIds), Long::valueOf));</span><br><span class="line"></span><br><span class="line">            if (!bulkMessageEsResult.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                log.error(&quot;同步ES重试再次失败:&#123;&#125;&quot;, JSON.toJSONString(bulkMessageEsResult));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return bulkMessageEsResult.isSuccess();</span><br><span class="line"></span><br><span class="line">    &#125;), Boolean::booleanValue);</span><br><span class="line"></span><br><span class="line">    if (!esResult) &#123;</span><br><span class="line"></span><br><span class="line">        log.error(&quot;同步到ES存在失败:&#123;&#125;&quot;, JSON.toJSONString(result));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return esResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段代码主要是在做同步数据给ES的逻辑，由于ES提供了多种同步方式，不想将细节暴露给上层，所以做了一些封装。</p><p>先看看这一段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; esFunction = getEsSyncFunction(isAsync);</span><br></pre></td></tr></table></figure><p>调用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; getEsSyncFunction(boolean isAsync) &#123;</span><br><span class="line"></span><br><span class="line">    return isAsync ? EsSyncProcessorInstance::syncByPrimaryKey : EsSyncProcessorInstance::syncByPrimaryKeyImmediate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中可以看到类似<code>EsSyncProcessorInstance::syncByPrimaryKey</code>这种写法，这个叫方法引用，可以理解为是一种特殊的lambda表达式（语法糖），相当于给一段函数取了一个名字，然后直接引用，看看syncByPrimaryKey：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public EsResult&lt;BulkMessage&gt; syncByPrimaryKey(List&lt;Long&gt; indexPrimaryKeyList) &#123;</span><br><span class="line"></span><br><span class="line">    String method = &quot;EsSyncProcessorInstance#syncByPrimaryKey&quot;;</span><br><span class="line"></span><br><span class="line">    if (indexPrimaryKeyList != null &amp;&amp; indexPrimaryKeyList.size() &gt; 3000) &#123;</span><br><span class="line"></span><br><span class="line">        log.warn(&quot;&#123;&#125; allowable size exceeded, size=&#123;&#125;, max=&#123;&#125;&quot;, new Object[]&#123;method, indexPrimaryKeyList.size(), 3000&#125;);</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        EsSyncLoopQuery query = this.newInstanceQuery();</span><br><span class="line"></span><br><span class="line">        query.setIdList(indexPrimaryKeyList);</span><br><span class="line"></span><br><span class="line">        return this.synchronizeToEs(query, this.defaultConfig());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个List<Long> 参数，一个EsResult<BulkMessage>返回值，那为什么适配的函数接口是BiFunction？看看BiFunction：</BulkMessage></Long></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface BiFunction&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里需要两个参数</span><br><span class="line"></span><br><span class="line">    R apply(T t, U u);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于syncByPrimaryKey是一个实例方法，所以还需要一个<strong>实例对象</strong>才能调用，所以<code>EsSyncProcessorInstance::syncByPrimaryKey</code> 相当于(<code>EsSyncProcessorInstance instance,List&lt;Long&gt; ids)-&gt;&#123;...&#125;</code></p><p>再一次验证，lambda表达式不能随意乱写，必须有对应的函数接口对应。</p><p>接下来再来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StreamUtils.listToList(partition, ids -&gt; &#123;</span><br></pre></td></tr></table></figure><p>这是对Java8 Stream+Lambda的一层封装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, R&gt; List&lt;R&gt; listToList(List&lt;T&gt; list, Function&lt;T, R&gt; function) &#123;</span><br><span class="line"></span><br><span class="line">        return safeList(list).stream().map(function).filter(Objects::nonNull).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到stream().map需要一个function用来转换数据，而其他的基本都是固定写法，这体现了Lambda的另外一个好处：抽象行为。</p><p><img src="https://files.catbox.moe/akijpg.png"></p><p>还有很多用法不一一介绍了。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这么🐂🍺的Lambda表达式Java底层是怎么实现的呢？首先可以确定的是，不是匿名内部类，还是最开始的例子，我们改成lambda表达式后编译看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello lambda&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/ular40.png"></p><p>可以看到并没有匿名内部类生成，我们查看下LambdaTest.class字节码(<em>javap -c -p -v LambdaTest.class</em>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zhaojingzhou/workspace/larry/lambda/src/LambdaTest.class</span><br><span class="line"></span><br><span class="line">  Last modified 2021-8-2; size 1047 bytes</span><br><span class="line"></span><br><span class="line">  MD5 checksum 191cb67c3e5a457eb20b4c8a47f5a5d2</span><br><span class="line"></span><br><span class="line">  Compiled from &quot;LambdaTest.java&quot;</span><br><span class="line"></span><br><span class="line">public class LambdaTest</span><br><span class="line"></span><br><span class="line">  minor version: 0</span><br><span class="line"></span><br><span class="line">  major version: 52</span><br><span class="line"></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line"></span><br><span class="line">   #1 = Methodref          #9.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">   #2 = Class              #20            // java/lang/Thread</span><br><span class="line"></span><br><span class="line">   #3 = InvokeDynamic      #0:#25         // #0:run:()Ljava/lang/Runnable;</span><br><span class="line"></span><br><span class="line">   #4 = Methodref          #2.#26         // java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br><span class="line"></span><br><span class="line">   #5 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">   #6 = String             #29            // hello inner class!</span><br><span class="line"></span><br><span class="line">   #7 = Methodref          #30.#31        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">   #8 = Class              #32            // LambdaTest</span><br><span class="line"></span><br><span class="line">   #9 = Class              #33            // java/lang/Object</span><br><span class="line"></span><br><span class="line">  #10 = Utf8               &lt;init&gt;</span><br><span class="line"></span><br><span class="line">  #11 = Utf8               ()V</span><br><span class="line"></span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line"></span><br><span class="line">  #13 = Utf8               LineNumberTable</span><br><span class="line"></span><br><span class="line">  #14 = Utf8               main</span><br><span class="line"></span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  #16 = Utf8               lambda$main$0</span><br><span class="line"></span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line"></span><br><span class="line">  #18 = Utf8               LambdaTest.java</span><br><span class="line"></span><br><span class="line">  #19 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">  #20 = Utf8               java/lang/Thread</span><br><span class="line"></span><br><span class="line">  #21 = Utf8               BootstrapMethods</span><br><span class="line"></span><br><span class="line">  #22 = MethodHandle       #6:#34         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line"></span><br><span class="line">  #23 = MethodType         #11            //  ()V</span><br><span class="line"></span><br><span class="line">  #24 = MethodHandle       #6:#35         // invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #25 = NameAndType        #36:#37        // run:()Ljava/lang/Runnable;</span><br><span class="line"></span><br><span class="line">  #26 = NameAndType        #10:#38        // &quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br><span class="line"></span><br><span class="line">  #27 = Class              #39            // java/lang/System</span><br><span class="line"></span><br><span class="line">  #28 = NameAndType        #40:#41        // out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">  #29 = Utf8               hello inner class!</span><br><span class="line"></span><br><span class="line">  #30 = Class              #42            // java/io/PrintStream</span><br><span class="line"></span><br><span class="line">  #31 = NameAndType        #43:#44        // println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  #32 = Utf8               LambdaTest</span><br><span class="line"></span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line"></span><br><span class="line">  #34 = Methodref          #45.#46        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line"></span><br><span class="line">  #35 = Methodref          #8.#47         // LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #36 = Utf8               run</span><br><span class="line"></span><br><span class="line">  #37 = Utf8               ()Ljava/lang/Runnable;</span><br><span class="line"></span><br><span class="line">  #38 = Utf8               (Ljava/lang/Runnable;)V</span><br><span class="line"></span><br><span class="line">  #39 = Utf8               java/lang/System</span><br><span class="line"></span><br><span class="line">  #40 = Utf8               out</span><br><span class="line"></span><br><span class="line">  #41 = Utf8               Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">  #42 = Utf8               java/io/PrintStream</span><br><span class="line"></span><br><span class="line">  #43 = Utf8               println</span><br><span class="line"></span><br><span class="line">  #44 = Utf8               (Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  #45 = Class              #48            // java/lang/invoke/LambdaMetafactory</span><br><span class="line"></span><br><span class="line">  #46 = NameAndType        #49:#53        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line"></span><br><span class="line">  #47 = NameAndType        #16:#11        // lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #48 = Utf8               java/lang/invoke/LambdaMetafactory</span><br><span class="line"></span><br><span class="line">  #49 = Utf8               metafactory</span><br><span class="line"></span><br><span class="line">  #50 = Class              #55            // java/lang/invoke/MethodHandles$Lookup</span><br><span class="line"></span><br><span class="line">  #51 = Utf8               Lookup</span><br><span class="line"></span><br><span class="line">  #52 = Utf8               InnerClasses</span><br><span class="line"></span><br><span class="line">  #53 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line"></span><br><span class="line">  #54 = Class              #56            // java/lang/invoke/MethodHandles</span><br><span class="line"></span><br><span class="line">  #55 = Utf8               java/lang/invoke/MethodHandles$Lookup</span><br><span class="line"></span><br><span class="line">  #56 = Utf8               java/lang/invoke/MethodHandles</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  public LambdaTest();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line"></span><br><span class="line">         0: aload_0</span><br><span class="line"></span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">         4: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 9: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line"></span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack=3, locals=1, args_size=1</span><br><span class="line"></span><br><span class="line">         0: new           #2                  // class java/lang/Thread</span><br><span class="line"></span><br><span class="line">         3: dup</span><br><span class="line"></span><br><span class="line">         4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br><span class="line"></span><br><span class="line">         9: invokespecial #4                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br><span class="line"></span><br><span class="line">        12: pop</span><br><span class="line"></span><br><span class="line">        13: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br><span class="line"></span><br><span class="line">        line 19: 13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line"></span><br><span class="line">         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">         3: ldc           #6                  // String hello inner class!</span><br><span class="line"></span><br><span class="line">         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;LambdaTest.java&quot;</span><br><span class="line"></span><br><span class="line">InnerClasses:</span><br><span class="line"></span><br><span class="line">     public static final #51= #50 of #54; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br><span class="line"></span><br><span class="line">BootstrapMethods:</span><br><span class="line"></span><br><span class="line">  0: #22 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line"></span><br><span class="line">    Method arguments:</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br><span class="line"></span><br><span class="line">      #24 invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br></pre></td></tr></table></figure><p>很多信息我们关注一下重点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure><p>第85行可以看到原lambda表达式被编译成了<code>invokedynamic</code> 字节码，这个是Java中多个调用字节码之一，其它的分别是<code>invokestatic</code>、<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokeinterface</code>。也是Java1.0以后第一个被新增的调用字节码。</p><p>接下来看#3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#3 = InvokeDynamic      #0:#25         // #0:run:()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure><p>#0:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line"></span><br><span class="line">  0: #22 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line"></span><br><span class="line">    Method arguments:</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br><span class="line"></span><br><span class="line">      #24 invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br></pre></td></tr></table></figure><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21">JVM规范</a>规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定<strong>有且仅有一个</strong>BootstrapMethods属性。BootstrapMethods属性是个变长的表。</p><p>其中根据相关信息会创建一个DynamicCallSite动态调用点，可以看到最终调用的方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line">  private static void lambda$main$0();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line"></span><br><span class="line">         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">         3: ldc           #6                  // String hello inner class!</span><br><span class="line"></span><br><span class="line">         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br></pre></td></tr></table></figure><p>也就是说Java虽然不会对Lambda表达式生成匿名类，但是会生成匿名静态方法。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://segmentfault.com/a/1190000020607546">https://segmentfault.com/a/1190000020607546</a></p><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p><p><a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method">https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;在Java8之前创建一个线程的写法（之一）：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LambdaTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new Thread(new Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&amp;quot;hello inner class!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty中FastThreadLocal源码解析</title>
    <link href="https://jingzhouzhao.github.io/archives/4b47846d.html"/>
    <id>https://jingzhouzhao.github.io/archives/4b47846d.html</id>
    <published>2021-05-08T02:25:25.000Z</published>
    <updated>2022-02-22T07:31:09.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ThreadLocal</code>一个特殊变体，当从<code>FastThreadLocalThread</code>访问时，可获得更高的访问性能。<br>在内部， <code>FastThreadLocal</code>在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。<br>要利用此线程局部变量，您的线程必须是<code>FastThreadLocalThread</code>或其子类型。 由于这个原因，默认情况下， <code>DefaultThreadFactory</code>创建的所有线程均为<code>FastThreadLocalThread</code> 。<br>请注意，只有在扩展<code>FastThreadLocalThread</code>线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规<code>ThreadLocal</code> 。</p><p>上面这段描述来自<code>FastThreadLocal</code>源码中的文档，从中可以知道<code>FastThreadLocal</code>必须和<code>FastThreadLocalThread</code>或其子类型一起使用才可以达到Fast的效果。</p><span id="more"></span><h2 id="FastThreadLocalThread"><a href="#FastThreadLocalThread" class="headerlink" title="FastThreadLocalThread"></a>FastThreadLocalThread</h2><p>既然必须要和<code>FastThreadLocalThread</code>    一起使用，那就来看看<code>FastThreadLocalThread</code>到底有什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A special &#123;<span class="doctag">@link</span> Thread&#125; that provides fast access to &#123;<span class="doctag">@link</span> FastThreadLocal&#125; variables.</span></span><br><span class="line"><span class="comment"> * 一种特殊的&#123;<span class="doctag">@link</span> Thread&#125;，可以快速访问&#123;<span class="doctag">@link</span> FastThreadLocal&#125;变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// This will be set to true if we have a chance to wrap the Runnable.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> cleanupFastThreadLocals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(FastThreadLocalRunnable.wrap(target));</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……    </span><br></pre></td></tr></table></figure><p>省略了一部分代码，可以看到<code>FastThreadLocalThread</code>继承自<code>Thread</code>，额外多了一个<code>InternalThreadLocalMap threadLocalMap</code>，从doc中可以看出这个变量就是关键。</p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal data structure that stores the thread-local variables for Netty and all &#123;<span class="doctag">@link</span> FastThreadLocal&#125;s.</span></span><br><span class="line"><span class="comment"> * Note that this class is for internal use only and is subject to change at any time.  Use &#123;<span class="doctag">@link</span> FastThreadLocal&#125;</span></span><br><span class="line"><span class="comment"> * unless you know what you are doing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></span><br><span class="line">    Object[] indexedVariables;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> slowGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">        InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">            slowThreadLocalMap.set(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextIndex.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;too many thread-local indexed variables&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if a new thread-local variable has been created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        Object[] lookup = indexedVariables;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">            Object oldValue = lookup[index];</span><br><span class="line">            lookup[index] = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><code>InternalThreadLocalMap</code>继承自<code>UnpaddedInternalThreadLocalMap</code>，为了好看一点我把父类中的相关代码放到了一起，dubbo借鉴netty代码也是这么干的。</p><h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>最后看看<code>FastThreadLocal</code>是怎么把这几个核心类给串起来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> variablesToRemoveIndex = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value for the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">        <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = initialValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the initial value for this thread-local variable.</span></span><br><span class="line"><span class="comment">     * 这个方法一般会把覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/nxk8yt.png"></p><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p><a href="https://github.com/apache/dubbo/pull/1745">https://github.com/apache/dubbo/pull/1745</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;一个特殊变体，当从&lt;code&gt;FastThreadLocalThread&lt;/code&gt;访问时，可获得更高的访问性能。&lt;br&gt;在内部， &lt;code&gt;FastThreadLocal&lt;/code&gt;在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。&lt;br&gt;要利用此线程局部变量，您的线程必须是&lt;code&gt;FastThreadLocalThread&lt;/code&gt;或其子类型。 由于这个原因，默认情况下， &lt;code&gt;DefaultThreadFactory&lt;/code&gt;创建的所有线程均为&lt;code&gt;FastThreadLocalThread&lt;/code&gt; 。&lt;br&gt;请注意，只有在扩展&lt;code&gt;FastThreadLocalThread&lt;/code&gt;线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规&lt;code&gt;ThreadLocal&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;上面这段描述来自&lt;code&gt;FastThreadLocal&lt;/code&gt;源码中的文档，从中可以知道&lt;code&gt;FastThreadLocal&lt;/code&gt;必须和&lt;code&gt;FastThreadLocalThread&lt;/code&gt;或其子类型一起使用才可以达到Fast的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis批量更新的一个小问题</title>
    <link href="https://jingzhouzhao.github.io/archives/e8013d2a.html"/>
    <id>https://jingzhouzhao.github.io/archives/e8013d2a.html</id>
    <published>2021-03-25T09:20:15.000Z</published>
    <updated>2022-02-22T07:31:09.012Z</updated>
    
    <content type="html"><![CDATA[<p>批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateBatch&quot; parameterType=&quot;list&quot;&gt;</span><br><span class="line">    &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;;&quot; index=&quot;index&quot;&gt;</span><br><span class="line">      update test</span><br><span class="line">      &lt;set&gt;</span><br><span class="line">        status = #&#123;item.status,jdbcType=BIGINT&#125;,</span><br><span class="line">        amount = #&#123;item.amount,jdbcType=BIGINT&#125;,</span><br><span class="line">        version = version+1,</span><br><span class="line">        gmt_modified = now(),</span><br><span class="line">      &lt;/set&gt;</span><br><span class="line">      &lt;where&gt;</span><br><span class="line">        id = #&#123;item.id&#125;</span><br><span class="line">      &lt;/where&gt;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">  &lt;/update&gt;</span><br></pre></td></tr></table></figure><p>非常简单的update SQL，通过Mybatis foreach 生成多个update SQL同时执行，但是运行时一直报：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;update test</span><br><span class="line">       SET amount = -116534270,</span><br><span class="line">        version&#x27; at line 10</span><br><span class="line">; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;update test</span><br><span class="line">       SET amount = -116534270,</span><br><span class="line">        version&#x27; at line 10</span><br></pre></td></tr></table></figure><p>看到这个错误下意识的认为肯定是sql哪里写的不对有语法错误，可是检查了半天没发现问题，而且将报错的sql 通过navicat运行也可以通过。</p><p>后来查到如果批量执行语句需要将database connection url中加上如下参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowMultiQueries=true</span><br></pre></td></tr></table></figure><p>完整的url例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/xxxx?allowMultiQueries=true&amp;amp;autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterset=utf8mb4</span><br></pre></td></tr></table></figure><p>不得不说MySQL报错信息实在是太模糊了。😓</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
    <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
    <category term="Mybatis" scheme="https://jingzhouzhao.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上死锁排查</title>
    <link href="https://jingzhouzhao.github.io/archives/9e47523f.html"/>
    <id>https://jingzhouzhao.github.io/archives/9e47523f.html</id>
    <published>2021-03-23T03:46:15.000Z</published>
    <updated>2022-02-22T07:31:09.015Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>最近又收到了相同的告警，可能不是偶然事件，于是开始排查。<br>首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。</p><span id="more"></span><p>于是向DBA要来了deadlock log，日志内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-03-22 16:02:01 0x7f1cfc289700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 153411874, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 8 lock struct(s), heap size 1136, 23 row lock(s), undo log entries 22</span><br><span class="line">MySQL thread id 8203444, OS thread handle 139762013996800, query id 766107488 updating</span><br><span class="line">update test</span><br><span class="line">SET status = 4,</span><br><span class="line">version = version+1,</span><br><span class="line">gmt_modified = &#x27;2021-03-22 16:02:01&#x27; </span><br><span class="line">where  id = 1</span><br><span class="line">and version=14</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table `test` trx id 153411874 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 153411876, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">8 lock struct(s), heap size 1136, 7 row lock(s), undo log entries 6</span><br><span class="line">MySQL thread id 8204162, OS thread handle 139762466330368, query id 766107489  updating</span><br><span class="line">update test</span><br><span class="line">         SET approval_status = 5,</span><br><span class="line">                biz_date = &#x27;2021-02-23 00:00:00&#x27;,</span><br><span class="line">                modified_id = 123,</span><br><span class="line">                modified_name = &#x27;xxx&#x27;,</span><br><span class="line">                contact_company_id = 456,</span><br><span class="line">                contact_company_n</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table `test` trx id 153411876 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table `test` trx id 153411876 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 28 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面日志只保留了关键部分，表名等也进行了脱敏。<br>可以看到两个事务都在等待PRIMARY也就是主键索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table `test`</span><br></pre></td></tr></table></figure><p>然后再结合日志中的SQL和代码，发现问题的原因如下:</p><p>一共涉及3个系统，分别是S、C、F，在S系统中有一个业务操作完成后会给C，F发消息，C收到S的消息处理完成后也会给F发一个消息，如图所示:</p><p><img src="https://i.loli.net/2021/03/23/cqBePdigLzNIUhF.png" alt="9b1b7abc8bdf0a3113e751fce4700924.png"></p><p>在F中几乎同时开启了两个事务，并且两个消息在F中涉及的记录是相同的，id分别是1，2，表为test。<br>于是出现了事务一:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test set status = 4 ...... where id=1</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test set status = 4 ...... where id=2</span><br></pre></td></tr></table></figure><p>事务二:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test SET approval_status = 5 ...... where id =2</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test SET approval_status = 5 ...... where id =1 </span><br></pre></td></tr></table></figure><p>事务一先持有id=1的锁，事务二持有id=2的锁，事务一尝试获取id=2的锁，事务二尝试获取id=1的锁，所以死锁了。最后MySQL回滚了事务二。</p><p>发生这种情况是由于产品和系统设计不合理导致的，目前正在重构中。</p><p>如果下次再发生死锁直接看deadlock log吧，没必要浪费时间翻代码看业务日志了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近又收到了相同的告警，可能不是偶然事件，于是开始排查。&lt;br&gt;首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
    <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
    <category term="Deadlock" scheme="https://jingzhouzhao.github.io/tags/Deadlock/"/>
    
  </entry>
  
  <entry>
    <title>关闭代码块移动</title>
    <link href="https://jingzhouzhao.github.io/archives/7f244d3f.html"/>
    <id>https://jingzhouzhao.github.io/archives/7f244d3f.html</id>
    <published>2020-08-25T07:22:10.000Z</published>
    <updated>2022-02-22T07:31:09.022Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Editor –&gt; General -&gt; Enable Drag’n’Drop functionality in Editor </span><br></pre></td></tr></table></figure><p>关闭即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>利用mybatis标签替换硬编码</title>
    <link href="https://jingzhouzhao.github.io/archives/ad1a887a.html"/>
    <id>https://jingzhouzhao.github.io/archives/ad1a887a.html</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2022-02-22T07:31:09.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>利用mybatis标签替换硬编码</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中偶尔看到这样的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;querySqlString&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       1=1</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;fundsOrderIdList != null and fundsOrderIdList.size()&gt;0&quot;</span>&gt;</span></span><br><span class="line">           and funds_order_id IN</span><br><span class="line">           <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;fundsOrderIdList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">               #&#123;id&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码中有个<code>1=1</code>很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。</p><span id="more"></span><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>在很久以前，充满智慧的程序员为了解决动态条件拼接的问题，发明了<code>1=1</code>这个写法，对应的还有<code>1=0</code>的写法，我们来看看这个写法在以前是怎么解决问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;select * from car_table where 1=1&quot;</span></span><br><span class="line"><span class="keyword">for</span>(Condtion condition:conditions)&#123;</span><br><span class="line">    <span class="comment">/**假如没有1=1，第一个条件直接拼接上and语法就错误了</span></span><br><span class="line"><span class="comment">    *还得做出额外判断才行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sql = sql + <span class="string">&quot; and &quot;</span> + condition.field + <span class="string">&quot; = &quot;</span> + condition.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实很巧妙，而且也没有性能问题，不信我给你举个🌰:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> channel_code <span class="operator">=</span> <span class="string">&#x27;50008&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这是一条很简单的SQL，其中就有<code>1=1</code>的写法，我们来看看MySQL查询优化器优化后实际执行的SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> channel_code <span class="operator">=</span> <span class="string">&#x27;50008&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br><span class="line">实际执行的<span class="keyword">SQL</span>:</span><br><span class="line"><span class="comment">/* select#1 */</span> <span class="keyword">select</span> 此处省略很多<span class="keyword">column</span> <span class="keyword">from</span> `online_paychannel`.`pay_channel_with_bank` <span class="keyword">where</span> (`online_paychannel`.`pay_channel_with_bank`.`channel_code` <span class="operator">=</span> <span class="number">50008</span>)</span><br></pre></td></tr></table></figure><p>可以看到<code>1=1</code>已经被优化掉了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然这种写法没啥大问题，但是代码是给人看的。如果不了解这种写法，乍一眼看过去肯定有点懵。</p><p>而且我们现在使用的Mybatis提供的<code>&lt;where&gt;</code>标签本身就会帮我们做优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPrefix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!prefixApplied) &#123;</span><br><span class="line">        prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">            <span class="comment">//此处会移除一些前缀  </span></span><br><span class="line">            <span class="keyword">if</span> (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">              sql.delete(<span class="number">0</span>, toRemove.trim().length());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sql.insert(<span class="number">0</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">          sql.insert(<span class="number">0</span>, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WhereSqlNode</code>中定义的<code>prefixesToOverride</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">&quot;AND &quot;</span>,<span class="string">&quot;OR &quot;</span>,<span class="string">&quot;AND\n&quot;</span>, <span class="string">&quot;OR\n&quot;</span>, <span class="string">&quot;AND\r&quot;</span>, <span class="string">&quot;OR\r&quot;</span>, <span class="string">&quot;AND\t&quot;</span>, <span class="string">&quot;OR\t&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以使用了<code>&lt;where&gt;</code>标签后可以放心大胆的去掉<code>1=1</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;建议&quot;&gt;&lt;a href=&quot;#建议&quot; class=&quot;headerlink&quot; title=&quot;建议&quot;&gt;&lt;/a&gt;建议&lt;/h2&gt;&lt;p&gt;利用mybatis标签替换硬编码&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目中偶尔看到这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sql&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;querySqlString&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;where&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       1=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;fundsOrderIdList != null and fundsOrderIdList.size()&amp;gt;0&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           and funds_order_id IN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;collection&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;fundsOrderIdList&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;index&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;open&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;close&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;separator&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               #&amp;#123;id&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码中有个&lt;code&gt;1=1&lt;/code&gt;很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>命令收藏</title>
    <link href="https://jingzhouzhao.github.io/archives/afa41a9c.html"/>
    <id>https://jingzhouzhao.github.io/archives/afa41a9c.html</id>
    <published>2020-07-22T02:45:53.000Z</published>
    <updated>2022-02-22T07:31:09.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h4 id="关闭SPI-获取根目录写权限"><a href="#关闭SPI-获取根目录写权限" class="headerlink" title="关闭SPI(获取根目录写权限)"></a>关闭SPI(获取根目录写权限)</h4><ul><li>重启 <code>command+R</code> 进入恢复界面</li><li>实用工具 - 终端 输入：<code>csrutil disable</code></li><li>重启：<code>reboot</code></li><li>打开终端，挂载根目录：<code>sudo mount -uw /</code><span id="more"></span><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:9999</span><br></pre></td></tr></table></figure><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><h4 id="更新app"><a href="#更新app" class="headerlink" title="更新app"></a>更新app</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cu -a -f</span><br></pre></td></tr></table></figure><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><h4 id="保存堆快照"><a href="#保存堆快照" class="headerlink" title="保存堆快照"></a>保存堆快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof pid</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h2&gt;&lt;h4 id=&quot;关闭SPI-获取根目录写权限&quot;&gt;&lt;a href=&quot;#关闭SPI-获取根目录写权限&quot; class=&quot;headerlink&quot; title=&quot;关闭SPI(获取根目录写权限)&quot;&gt;&lt;/a&gt;关闭SPI(获取根目录写权限)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;重启 &lt;code&gt;command+R&lt;/code&gt; 进入恢复界面&lt;/li&gt;
&lt;li&gt;实用工具 - 终端 输入：&lt;code&gt;csrutil disable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启：&lt;code&gt;reboot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开终端，挂载根目录：&lt;code&gt;sudo mount -uw /&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>常见集群方式</title>
    <link href="https://jingzhouzhao.github.io/archives/6a6e8ff1.html"/>
    <id>https://jingzhouzhao.github.io/archives/6a6e8ff1.html</id>
    <published>2020-06-16T05:45:53.000Z</published>
    <updated>2022-02-22T07:31:09.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从（master-slave）"><a href="#主从（master-slave）" class="headerlink" title="主从（master-slave）"></a>主从（master-slave）</h3><p>写master，同步到slave 。slave可用于读。常见mysql，redis。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>在主从的基础上，添加了master宕机时，slave自动切换为master。</p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>集群内每个节点都是分片。通过分布式一致性协议沟通。</p><p>例如redis，通过Gossip 协议，在集群内同步，各个分片的哈希槽信息。</p><p>便于重定向请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;主从（master-slave）&quot;&gt;&lt;a href=&quot;#主从（master-slave）&quot; class=&quot;headerlink&quot; title=&quot;主从（master-slave）&quot;&gt;&lt;/a&gt;主从（master-slave）&lt;/h3&gt;&lt;p&gt;写master，同步到sla</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ RMQ_SYS_TRANS_HALF_TOPIC 爆掉的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/cfa05355.html"/>
    <id>https://jingzhouzhao.github.io/archives/cfa05355.html</id>
    <published>2020-06-05T05:22:44.000Z</published>
    <updated>2022-02-22T07:31:09.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>SaaS项目东郭反应，项目中发的事务消息一直在<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：<img src="https://files.catbox.moe/gdp5ap.png"></p><p>这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了<code>TRANS_CHECK_MAXTIME_TOPIC</code>中。</p><p>不正常的是<code>REAL_TOPIC</code>变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。</p><span id="more"></span><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><h4 id="一、排查"><a href="#一、排查" class="headerlink" title="一、排查"></a>一、排查</h4><p>一开始我们以为是Producer的问题，因为得到的反馈是这个消息没有被“消费”，所以我们开始排查Producer所在的项目。发现并没有什么问题。后来我们观察到上述日志中有一个DELAY=3，结合在网上查询的<a href="http://mail-archives.apache.org/mod_mbox/rocketmq-dev/201910.mbox/%3C157129868332.7323.16435164322004213562.gitbox@gitbox.apache.org%3E">资料</a>，认为可能是触发了RocketMQ的一个问题，就是事务消息进行了延迟发送。我们以为快接近真相了，我们开始查找Producer是否在发送事务消息时设置了DELAY参数。很快我们就失望了，Producer没有任何地方设置了DELAY参数。</p><h4 id="二、翻阅源码"><a href="#二、翻阅源码" class="headerlink" title="二、翻阅源码"></a>二、翻阅源码</h4><p>我们回头去看上面那个日志，发现<code>RECONSUME_TIME=1</code>并且<code>RETRY_TOPIC</code>也不为空，这说明这个消息肯定是被消费者消费到了，但是由于某种原因消费失败了，触发了重试。于是我们开始看RocketMQ重试相关源码。我们首先找到了DELAY=3这个参数的来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的消费者中设置了ConsumeConcurrentlyContext 延时级别</span></span><br><span class="line">context.setDelayLevelWhenNextConsume(getDelayLevelWhenNextConsume(reconsumeTimes));</span><br><span class="line"><span class="comment">//可以看到这个delayLevel最终是会被发送到broker</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap topic with namespace before sending back message.</span></span><br><span class="line">  msg.setTopic(<span class="keyword">this</span>.defaultMQPushConsumer.withNamespace(msg.getTopic()));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;sendMessageBack exception, group: &quot;</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">&quot; msg: &quot;</span> + msg.toString(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找到对应broker版本(4.6.0)的源码一步步找到了这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.CommitLog#putMessage</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line"><span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">    || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">  <span class="comment">// Delay Delivery</span></span><br><span class="line">  <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">      msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">    queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">    msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">    msg.setTopic(topic);</span><br><span class="line">    msg.setQueueId(queueId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照之前日志里的参数，<code>sysFlag=8,delay=3</code>，我们认为很可能走了这段逻辑，然后触发了事务消息进行了延迟发送的问题。继续看了延时消息发送的逻辑，没有找到问题，而且这也解释不了为什么<code>REAL_TOPIC</code>变成了``RMQ_SYS_TRANS_HALF_TOPIC`</p><h4 id="三、真相"><a href="#三、真相" class="headerlink" title="三、真相"></a>三、真相</h4><p>上面还提到了一个<code>RETRY_TOPIC</code>，这个在之前的排查过程中没有发现有什么地方设置，于是我们搜索了一把，发现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(MessageExt msg, <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String brokerAddr = (<span class="keyword">null</span> != brokerName) ? <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</span><br><span class="line">            : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class="number">5000</span>, getMaxReconsumeTimes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;sendMessageBack Exception, &quot;</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</span><br><span class="line"></span><br><span class="line">        Message newMsg = <span class="keyword">new</span> Message(MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span><br><span class="line"></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msg);</span><br><span class="line">        MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">        newMsg.setFlag(msg.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(newMsg, msg.getProperties());</span><br><span class="line">       <span class="comment">//这里设置了RETRY_TOPIC</span></span><br><span class="line">        MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span><br><span class="line">        MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class="number">1</span>));</span><br><span class="line">        MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span><br><span class="line">       </span><br><span class="line">        newMsg.setDelayTimeLevel(<span class="number">3</span> + msg.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQPushConsumer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显是个异常流程，那么到底是什么导致了这个异常流程呢？既然知道是在消费的时候出了异常，于是我们找到对应的消费者日志，发现如下错误：</p><p><img src="https://files.catbox.moe/42fapz.png"></p><p>这里Broker返回的错误是<code>MESSAGE_ILIEGAL</code>，在回过头去看重试相关代码，有了之前的经验这次很快就定位到了可能报这个错误的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一处：org.apache.rocketmq.store.DefaultMessageStore#putMessage </span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line"> log.warn(<span class="string">&quot;putMessage message topic length too long &quot;</span> + msg.getTopic().length());</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//第二处：org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend(long, java.nio.ByteBuffer, int, org.apache.rocketmq.store.MessageExtBrokerInner)</span></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">  log.warn(<span class="string">&quot;putMessage message properties length too long. length=&#123;&#125;&quot;</span>, propertiesData.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br></pre></td></tr></table></figure><p>果断找运维要了<code>store.log</code>，发现如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN SendMessageThread_1 - putMessage message topic length too long 149</span><br></pre></td></tr></table></figure><p>所以应该就是第一处的问题了。至此问题的原因基本找到了，但还有以下问题：</p><ol><li><p>为什么TOPIC会超长？</p><p>重试的消息TOPIC规则为%RETRY%+consumerGroup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup())</span><br></pre></td></tr></table></figure><p>而我们的consumerGroup的规则为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group + <span class="string">&quot;_&quot;</span> + getTopic() + <span class="string">&quot;_&quot;</span> + getTags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题的consumer的tags为：<code>SAAS_PURCHASE_PURCHASE_ORDER_UPDATE||SAAS_PURCHASE_PURCHASE_ORDER_OPEN_RECEVIED||SAAS_PURCHASE_PURCHASE_ORDER_COMPLETED_RECEVIED</code></p><p>所以最终拼出来的TOPIC超出了长度。</p></li><li><p>为什么走了Catch里面的流程就会导致HALF队列爆掉？</p><p>这是由于我们使用的RocketMQ-client版本为<code>4.5.0</code>，这个版本Catch里的代码有个bug，没有清除掉原始消息的事务消息标志<code>TRANS_MSG=true</code>。所以这个消息发出去后在broker端又会走事务消息的流程，并且还是带延时的。这会导致真实的TOPIC丢掉。</p><p>下面用一张图来说明一下：</p><p><img src="https://files.catbox.moe/ssraef.png"></p><p>事务消息消费失败，topic转为<code>%RETRY%xxxx</code>发送到broker，由于事务消息标志没有被清除，于是topic转成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。又由于delay参数没有被清除，topic最后被转为了<code>schedule_topic_xxxx</code>。等到schedule执行时，消息会发到<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中。由于不是Producer发的事务消息，所以拿不到LocalTransactionState。只能等待事务消息回查。</p><p>这时刚好又碰到我们的LocalTransactionListener的一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">  Object msg = HessianUtils.decode(messageExt.getBody());</span><br><span class="line">  String topic = messageExt.getTopic();</span><br><span class="line">  String tag = messageExt.getTags();</span><br><span class="line">  <span class="comment">//由于拿着rmq_sys_trans_half_topic来获取handler所以肯定获取不到。</span></span><br><span class="line">  LocalTransactionHandler localTransacationHandler = getLocalTransacationHandler(topic, tag);</span><br><span class="line"></span><br><span class="line">  String msgId = messageExt.getMsgId();</span><br><span class="line">  <span class="keyword">if</span>( localTransacationHandler == <span class="keyword">null</span> )&#123;</span><br><span class="line">    logger.error(<span class="string">&quot;localTransacationHandler is empty should never happened! msgId=&#123;&#125;, arg=&#123;&#125;&quot;</span>, msgId, JSON.toJSONString(msg));</span><br><span class="line">    <span class="comment">//于是这个地方会返回COMMIT_MESSAGE</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> checkResult = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkResult = localTransacationHandler.localTransactionCheck(msgId, msg);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;localTransacationCheck failed! msgId=&#123;&#125;, arg=&#123;&#125;&quot;</span>, msgId, JSON.toJSONString(msg), e);</span><br><span class="line">    checkResult = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> checkResult ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broker收到<code>COMMIT_MESSAGE</code>后会将消息写往REAL_TOPIC中。而此时REAL_TOPIC早已变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。就这样，<code>RMQ_SYS_TRANS_HALF_TOPIC </code>爆掉了。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>首先我们将handler为空时返回<code>COMMIT_MESSAGE</code>，改为了<code>ROLLBACK_MESSAGE</code>。</p></li><li><p>升级stone中RocketMQ为4.6.1，可以看到在Catch代码中多了一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageAccessor.clearProperty(newMsg, &quot;TRAN_MSG&quot;);</span><br></pre></td></tr></table></figure></li><li><p>有问题的consumer将tag拆分</p><p>第一步和第二步只能解决<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉的问题。但是topic超长还是会有问题。所以目前暂时是将consumer的tag拆开。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;SaaS项目东郭反应，项目中发的事务消息一直在&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：&lt;img src=&quot;https://files.catbox.moe/gdp5ap.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了&lt;code&gt;TRANS_CHECK_MAXTIME_TOPIC&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;不正常的是&lt;code&gt;REAL_TOPIC&lt;/code&gt;变成了&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
    <category term="RocketMQ" scheme="https://jingzhouzhao.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>读取Jar中指定目录下的所有文件</title>
    <link href="https://jingzhouzhao.github.io/archives/f728629b.html"/>
    <id>https://jingzhouzhao.github.io/archives/f728629b.html</id>
    <published>2020-03-19T03:47:54.000Z</published>
    <updated>2022-02-22T07:31:09.015Z</updated>
    
    <content type="html"><![CDATA[<p>读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。</p><span id="more"></span><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>首先要读取Jar中的目录下的文件，得先搞清楚Jar中的目录结构，例如常见的SpringBoot打包后的Jar中目录如下：</p><p><img src="/archives/f728629b/1.png" alt="1"></p><p>假如我们要读取的目录是<code>BOOT-INF/classes/processes</code>（对应源文件目录是<code>resources/processes</code>）</p><p><img src="/archives/f728629b/2.png" alt="2"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前Jar文件路径</span></span><br><span class="line">URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    String jarPath = url.toString().substring(<span class="number">0</span>, url.toString().indexOf(<span class="string">&quot;!/&quot;</span>) + <span class="number">2</span>);</span><br><span class="line">    log.info(<span class="string">&quot;jarPath:&#123;&#125;&quot;</span>, jarPath);</span><br><span class="line">    URL jarURL = <span class="keyword">new</span> URL(jarPath);</span><br><span class="line">    JarURLConnection jarCon = (JarURLConnection) jarURL.openConnection();</span><br><span class="line">    JarFile jarFile = jarCon.getJarFile();</span><br><span class="line"><span class="comment">//获取Jar下所有文件</span></span><br><span class="line">    Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">        JarEntry jarEntry = entries.nextElement();</span><br><span class="line">      <span class="comment">//获取文件路径</span></span><br><span class="line">        String innerPath = jarEntry.getName();</span><br><span class="line">        log.info(<span class="string">&quot;jarEntry Name:&#123;&#125;&quot;</span>, innerPath);</span><br><span class="line">      <span class="comment">//判断是否需要处理的目录下的文件，PROCESSES=BOOT-INF/classes/processes</span></span><br><span class="line">        <span class="keyword">if</span> (innerPath.startsWith(PROCESSES) &amp;&amp; !jarEntry.isDirectory()) &#123;</span><br><span class="line">          <span class="comment">//获取到文件流</span></span><br><span class="line">            InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(innerPath);</span><br><span class="line">          <span class="comment">//doSomething</span></span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式优缺点：无第三方库依赖，用的都是JDK 相关API。但是只能在jar模式下运行，本地调试会出错。</p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>如果有使用到Spring，那么不管是打成Jar运行还是本地运行，获取指定目录中的文件就很简单了。主要是利用了Spring 的<code>ResourcePatternResolver</code>，详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    List&lt;Resource&gt; resourceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = Arrays.asLIst(&quot;**.bpmn20.xml&quot;,&quot;**.bpmn&quot;)</span></span><br><span class="line">    <span class="keyword">for</span> (String suffix : PROCESS_DEFINITION_LOCATION_SUFFIXES) &#123;</span><br><span class="line">      <span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = classpath://processes/</span></span><br><span class="line">        <span class="comment">//拼接路径pattern</span></span><br><span class="line">        String path = PROCESS_DEFINITION_LOCATION_PREFIX + suffix;</span><br><span class="line">      <span class="comment">//通过ResourcePatternResolver获取资源文件,</span></span><br><span class="line">        <span class="comment">//resourceLoader = @Autowired ResourcePatternResolver resourceLoader</span></span><br><span class="line">        Resource[] resources = resourceLoader.getResources(path);</span><br><span class="line">        <span class="keyword">if</span> (resources != <span class="keyword">null</span> &amp;&amp; resources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            resourceList.addAll(Arrays.asList(resources));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过resource.getInputStream()即可获取文件流</span></span><br><span class="line"><span class="comment">//doSomething</span></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>此方式优缺点，依赖了Spring框架，但是对运行环境没有要求。</p><p>总结：</p><p>推荐使用第二种方式，毕竟现在基本上都会使用到Spring。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。&lt;/p&gt;</summary>
    
    
    
    <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
