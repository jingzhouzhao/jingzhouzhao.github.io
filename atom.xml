<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵荆州的个人博客</title>
  
  <subtitle>赵荆州的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingzhouzhao.github.io/"/>
  <updated>2021-05-08T06:48:57.879Z</updated>
  <id>https://jingzhouzhao.github.io/</id>
  
  <author>
    <name>赵荆州</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty中FastThreadLocal源码解析</title>
    <link href="https://jingzhouzhao.github.io/archives/4b47846d.html"/>
    <id>https://jingzhouzhao.github.io/archives/4b47846d.html</id>
    <published>2021-05-08T02:25:25.000Z</published>
    <updated>2021-05-08T06:48:57.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ThreadLocal</code>一个特殊变体，当从<code>FastThreadLocalThread</code>访问时，可获得更高的访问性能。<br>在内部， <code>FastThreadLocal</code>在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。<br>要利用此线程局部变量，您的线程必须是<code>FastThreadLocalThread</code>或其子类型。 由于这个原因，默认情况下， <code>DefaultThreadFactory</code>创建的所有线程均为<code>FastThreadLocalThread</code> 。<br>请注意，只有在扩展<code>FastThreadLocalThread</code>线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规<code>ThreadLocal</code> 。</p><p>上面这段描述来自<code>FastThreadLocal</code>源码中的文档，从中可以知道<code>FastThreadLocal</code>必须和<code>FastThreadLocalThread</code>或其子类型一起使用才可以达到Fast的效果。</p><h2 id="FastThreadLocalThread"><a href="#FastThreadLocalThread" class="headerlink" title="FastThreadLocalThread"></a>FastThreadLocalThread</h2><p>既然必须要和<code>FastThreadLocalThread</code>    一起使用，那就来看看<code>FastThreadLocalThread</code>到底有什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A special &#123;<span class="doctag">@link</span> Thread&#125; that provides fast access to &#123;<span class="doctag">@link</span> FastThreadLocal&#125; variables.</span></span><br><span class="line"><span class="comment"> * 一种特殊的&#123;<span class="doctag">@link</span> Thread&#125;，可以快速访问&#123;<span class="doctag">@link</span> FastThreadLocal&#125;变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// This will be set to true if we have a chance to wrap the Runnable.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> cleanupFastThreadLocals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(FastThreadLocalRunnable.wrap(target));</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>省略了一部分代码，可以看到<code>FastThreadLocalThread</code>继承自<code>Thread</code>，额外多了一个<code>InternalThreadLocalMap threadLocalMap</code>，从doc中可以看出这个变量就是关键。</p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal data structure that stores the thread-local variables for Netty and all &#123;<span class="doctag">@link</span> FastThreadLocal&#125;s.</span></span><br><span class="line"><span class="comment"> * Note that this class is for internal use only and is subject to change at any time.  Use &#123;<span class="doctag">@link</span> FastThreadLocal&#125;</span></span><br><span class="line"><span class="comment"> * unless you know what you are doing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></span><br><span class="line">    Object[] indexedVariables;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> slowGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">        InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">            slowThreadLocalMap.set(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextIndex.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"too many thread-local indexed variables"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if a new thread-local variable has been created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        Object[] lookup = indexedVariables;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">            Object oldValue = lookup[index];</span><br><span class="line">            lookup[index] = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>InternalThreadLocalMap</code>继承自<code>UnpaddedInternalThreadLocalMap</code>，为了好看一点我把父类中的相关代码放到了一起，dubbo借鉴netty代码也是这么干的。</p><h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>最后看看<code>FastThreadLocal</code>是怎么把这几个核心类给串起来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> variablesToRemoveIndex = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value for the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">        <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = initialValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the initial value for this thread-local variable.</span></span><br><span class="line"><span class="comment">     * 这个方法一般会把覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/nxk8yt.png" alt></p><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p><a href="https://github.com/apache/dubbo/pull/1745" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/1745</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;一个特殊变体，当从&lt;code&gt;FastThreadLocalThread&lt;/code&gt;访问时
      
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis批量更新的一个小问题</title>
    <link href="https://jingzhouzhao.github.io/archives/e8013d2a.html"/>
    <id>https://jingzhouzhao.github.io/archives/e8013d2a.html</id>
    <published>2021-03-25T09:20:15.000Z</published>
    <updated>2021-03-25T09:34:47.232Z</updated>
    
    <content type="html"><![CDATA[<p>批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateBatch&quot; parameterType&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;item&quot; separator&#x3D;&quot;;&quot; index&#x3D;&quot;index&quot;&gt;</span><br><span class="line">      update test</span><br><span class="line">      &lt;set&gt;</span><br><span class="line">        status &#x3D; #&#123;item.status,jdbcType&#x3D;BIGINT&#125;,</span><br><span class="line">        amount &#x3D; #&#123;item.amount,jdbcType&#x3D;BIGINT&#125;,</span><br><span class="line">        version &#x3D; version+1,</span><br><span class="line">        gmt_modified &#x3D; now(),</span><br><span class="line">      &lt;&#x2F;set&gt;</span><br><span class="line">      &lt;where&gt;</span><br><span class="line">        id &#x3D; #&#123;item.id&#125;</span><br><span class="line">      &lt;&#x2F;where&gt;</span><br><span class="line">    &lt;&#x2F;foreach&gt;</span><br><span class="line">  &lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p>非常简单的update SQL，通过Mybatis foreach 生成多个update SQL同时执行，但是运行时一直报：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;update test</span><br><span class="line">       SET amount &#x3D; -116534270,</span><br><span class="line">        version&#39; at line 10</span><br><span class="line">; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;update test</span><br><span class="line">       SET amount &#x3D; -116534270,</span><br><span class="line">        version&#39; at line 10</span><br></pre></td></tr></table></figure><p>看到这个错误下意识的认为肯定是sql哪里写的不对有语法错误，可是检查了半天没发现问题，而且将报错的sql 通过navicat运行也可以通过。</p><p>后来查到如果批量执行语句需要将database connection url中加上如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowMultiQueries&#x3D;true</span><br></pre></td></tr></table></figure><p>完整的url例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;x.x.x.x:3306&#x2F;xxxx?allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterset&#x3D;utf8mb4</span><br></pre></td></tr></table></figure><p>不得不说MySQL报错信息实在是太模糊了。😓</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
      <category term="Mybatis" scheme="https://jingzhouzhao.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上死锁排查</title>
    <link href="https://jingzhouzhao.github.io/archives/9e47523f.html"/>
    <id>https://jingzhouzhao.github.io/archives/9e47523f.html</id>
    <published>2021-03-23T03:46:15.000Z</published>
    <updated>2021-03-23T06:48:00.368Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>最近又收到了相同的告警，可能不是偶然事件，于是开始排查。<br>首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。</p><p>于是向DBA要来了deadlock log，日志内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-03-22 16:02:01 0x7f1cfc289700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 153411874, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 8 lock struct(s), heap size 1136, 23 row lock(s), undo log entries 22</span><br><span class="line">MySQL thread id 8203444, OS thread handle 139762013996800, query id 766107488 updating</span><br><span class="line">update test</span><br><span class="line">SET status &#x3D; 4,</span><br><span class="line">version &#x3D; version+1,</span><br><span class="line">gmt_modified &#x3D; &#39;2021-03-22 16:02:01&#39; </span><br><span class="line">where  id &#x3D; 1</span><br><span class="line">and version&#x3D;14</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411874 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 153411876, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">8 lock struct(s), heap size 1136, 7 row lock(s), undo log entries 6</span><br><span class="line">MySQL thread id 8204162, OS thread handle 139762466330368, query id 766107489  updating</span><br><span class="line">update test</span><br><span class="line">         SET approval_status &#x3D; 5,</span><br><span class="line">                biz_date &#x3D; &#39;2021-02-23 00:00:00&#39;,</span><br><span class="line">                modified_id &#x3D; 123,</span><br><span class="line">                modified_name &#x3D; &#39;xxx&#39;,</span><br><span class="line">                contact_company_id &#x3D; 456,</span><br><span class="line">                contact_company_n</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411876 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411876 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 28 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br></pre></td></tr></table></figure><p>上面日志只保留了关键部分，表名等也进行了脱敏。<br>可以看到两个事务都在等待PRIMARY也就是主键索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96;</span><br></pre></td></tr></table></figure><p>然后再结合日志中的SQL和代码，发现问题的原因如下:</p><p>一共涉及3个系统，分别是S、C、F，在S系统中有一个业务操作完成后会给C，F发消息，C收到S的消息处理完成后也会给F发一个消息，如图所示:</p><p><img src="https://i.loli.net/2021/03/23/cqBePdigLzNIUhF.png" alt="9b1b7abc8bdf0a3113e751fce4700924.png"></p><p>在F中几乎同时开启了两个事务，并且两个消息在F中涉及的记录是相同的，id分别是1，2，表为test。<br>于是出现了事务一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test set status &#x3D; 4 ...... where id&#x3D;1</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test set status &#x3D; 4 ...... where id&#x3D;2</span><br></pre></td></tr></table></figure><p>事务二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test SET approval_status &#x3D; 5 ...... where id &#x3D;2</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test SET approval_status &#x3D; 5 ...... where id &#x3D;1</span><br></pre></td></tr></table></figure><p>事务一先持有id=1的锁，事务二持有id=2的锁，事务一尝试获取id=2的锁，事务二尝试获取id=1的锁，所以死锁了。最后MySQL回滚了事务二。</p><p>发生这种情况是由于产品和系统设计不合理导致的，目前正在重构中。</p><p>如果下次再发生死锁直接看deadlock log吧，没必要浪费时间翻代码看业务日志了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
      <category term="Deadlock" scheme="https://jingzhouzhao.github.io/tags/Deadlock/"/>
    
  </entry>
  
  <entry>
    <title>关闭代码块移动</title>
    <link href="https://jingzhouzhao.github.io/archives/7f244d3f.html"/>
    <id>https://jingzhouzhao.github.io/archives/7f244d3f.html</id>
    <published>2020-08-25T07:22:10.000Z</published>
    <updated>2020-08-25T07:26:32.886Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Editor –&gt; General -&gt; Enable Drag’n’Drop functionality in Editor</span><br></pre></td></tr></table></figure><p>关闭即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>利用mybatis标签替换硬编码</title>
    <link href="https://jingzhouzhao.github.io/archives/ad1a887a.html"/>
    <id>https://jingzhouzhao.github.io/archives/ad1a887a.html</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-13T03:39:22.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>利用mybatis标签替换硬编码</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中偶尔看到这样的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"querySqlString"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       1=1</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"fundsOrderIdList != null and fundsOrderIdList.size()&gt;0"</span>&gt;</span></span><br><span class="line">           and funds_order_id IN</span><br><span class="line">           <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"fundsOrderIdList"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">               #&#123;id&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码中有个<code>1=1</code>很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。</p><a id="more"></a><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>在很久以前，充满智慧的程序员为了解决动态条件拼接的问题，发明了<code>1=1</code>这个写法，对应的还有<code>1=0</code>的写法，我们来看看这个写法在以前是怎么解决问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">"select * from car_table where 1=1"</span></span><br><span class="line"><span class="keyword">for</span>(Condtion condition:conditions)&#123;</span><br><span class="line">    <span class="comment">/**假如没有1=1，第一个条件直接拼接上and语法就错误了</span></span><br><span class="line"><span class="comment">    *还得做出额外判断才行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sql = sql + <span class="string">" and "</span> + condition.field + <span class="string">" = "</span> + condition.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实很巧妙，而且也没有性能问题，不信我给你举个🌰:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> channel_code = <span class="string">'50008'</span>;</span><br></pre></td></tr></table></figure><p>这是一条很简单的SQL，其中就有<code>1=1</code>的写法，我们来看看MySQL查询优化器优化后实际执行的SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> channel_code = <span class="string">'50008'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>;</span><br><span class="line">实际执行的SQL:</span><br><span class="line"><span class="comment">/* select#1 */</span> <span class="keyword">select</span> 此处省略很多<span class="keyword">column</span> <span class="keyword">from</span> <span class="string">`online_paychannel`</span>.<span class="string">`pay_channel_with_bank`</span> <span class="keyword">where</span> (<span class="string">`online_paychannel`</span>.<span class="string">`pay_channel_with_bank`</span>.<span class="string">`channel_code`</span> = <span class="number">50008</span>)</span><br></pre></td></tr></table></figure><p>可以看到<code>1=1</code>已经被优化掉了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然这种写法没啥大问题，但是代码是给人看的。如果不了解这种写法，乍一眼看过去肯定有点懵。</p><p>而且我们现在使用的Mybatis提供的<code>&lt;where&gt;</code>标签本身就会帮我们做优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPrefix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!prefixApplied) &#123;</span><br><span class="line">        prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">            <span class="comment">//此处会移除一些前缀  </span></span><br><span class="line">            <span class="keyword">if</span> (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">              sql.delete(<span class="number">0</span>, toRemove.trim().length());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sql.insert(<span class="number">0</span>, <span class="string">" "</span>);</span><br><span class="line">          sql.insert(<span class="number">0</span>, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WhereSqlNode</code>中定义的<code>prefixesToOverride</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">"AND "</span>,<span class="string">"OR "</span>,<span class="string">"AND\n"</span>, <span class="string">"OR\n"</span>, <span class="string">"AND\r"</span>, <span class="string">"OR\r"</span>, <span class="string">"AND\t"</span>, <span class="string">"OR\t"</span>);</span><br></pre></td></tr></table></figure><p>所以使用了<code>&lt;where&gt;</code>标签后可以放心大胆的去掉<code>1=1</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建议&quot;&gt;&lt;a href=&quot;#建议&quot; class=&quot;headerlink&quot; title=&quot;建议&quot;&gt;&lt;/a&gt;建议&lt;/h2&gt;&lt;p&gt;利用mybatis标签替换硬编码&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目中偶尔看到这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sql&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;querySqlString&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;where&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       1=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fundsOrderIdList != null and fundsOrderIdList.size()&amp;gt;0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           and funds_order_id IN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;collection&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fundsOrderIdList&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;index&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;open&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;(&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;close&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;separator&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               #&amp;#123;id&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码中有个&lt;code&gt;1=1&lt;/code&gt;很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>命令收藏</title>
    <link href="https://jingzhouzhao.github.io/archives/afa41a9c.html"/>
    <id>https://jingzhouzhao.github.io/archives/afa41a9c.html</id>
    <published>2020-07-22T02:45:53.000Z</published>
    <updated>2020-07-23T11:19:16.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h4 id="关闭SPI-获取根目录写权限"><a href="#关闭SPI-获取根目录写权限" class="headerlink" title="关闭SPI(获取根目录写权限)"></a>关闭SPI(获取根目录写权限)</h4><ul><li><p>重启 <code>command+R</code> 进入恢复界面</p></li><li><p>实用工具 - 终端 输入：<code>csrutil disable</code></p></li><li><p>重启：<code>reboot</code></p></li><li><p>打开终端，挂载根目录：<code>sudo mount -uw /</code></p><a id="more"></a><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2></li></ul><h4 id="更新app"><a href="#更新app" class="headerlink" title="更新app"></a>更新app</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cu -a -f</span><br></pre></td></tr></table></figure><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><h4 id="保存堆快照"><a href="#保存堆快照" class="headerlink" title="保存堆快照"></a>保存堆快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h2&gt;&lt;h4 id=&quot;关闭SPI-获取根目录写权限&quot;&gt;&lt;a href=&quot;#关闭SPI-获取根目录写权限&quot; class=&quot;headerlink&quot; title=&quot;关闭SPI(获取根目录写权限)&quot;&gt;&lt;/a&gt;关闭SPI(获取根目录写权限)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重启 &lt;code&gt;command+R&lt;/code&gt; 进入恢复界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实用工具 - 终端 输入：&lt;code&gt;csrutil disable&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重启：&lt;code&gt;reboot&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开终端，挂载根目录：&lt;code&gt;sudo mount -uw /&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>常见集群方式</title>
    <link href="https://jingzhouzhao.github.io/archives/6a6e8ff1.html"/>
    <id>https://jingzhouzhao.github.io/archives/6a6e8ff1.html</id>
    <published>2020-06-16T05:45:53.000Z</published>
    <updated>2020-06-16T05:47:23.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从（master-slave）"><a href="#主从（master-slave）" class="headerlink" title="主从（master-slave）"></a>主从（master-slave）</h3><p>写master，同步到slave 。slave可用于读。常见mysql，redis。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>在主从的基础上，添加了master宕机时，slave自动切换为master。</p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>集群内每个节点都是分片。通过分布式一致性协议沟通。</p><p>例如redis，通过Gossip 协议，在集群内同步，各个分片的哈希槽信息。</p><p>便于重定向请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主从（master-slave）&quot;&gt;&lt;a href=&quot;#主从（master-slave）&quot; class=&quot;headerlink&quot; title=&quot;主从（master-slave）&quot;&gt;&lt;/a&gt;主从（master-slave）&lt;/h3&gt;&lt;p&gt;写master，同步到sla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ RMQ_SYS_TRANS_HALF_TOPIC 爆掉的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/cfa05355.html"/>
    <id>https://jingzhouzhao.github.io/archives/cfa05355.html</id>
    <published>2020-06-05T05:22:44.000Z</published>
    <updated>2021-04-01T02:05:00.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>SaaS项目东郭反应，项目中发的事务消息一直在<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：<img src="https://files.catbox.moe/gdp5ap.png" alt></p><p>这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了<code>TRANS_CHECK_MAXTIME_TOPIC</code>中。</p><p>不正常的是<code>REAL_TOPIC</code>变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。</p><a id="more"></a><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><h4 id="一、排查"><a href="#一、排查" class="headerlink" title="一、排查"></a>一、排查</h4><p>一开始我们以为是Producer的问题，因为得到的反馈是这个消息没有被“消费”，所以我们开始排查Producer所在的项目。发现并没有什么问题。后来我们观察到上述日志中有一个DELAY=3，结合在网上查询的<a href="http://mail-archives.apache.org/mod_mbox/rocketmq-dev/201910.mbox/%3C157129868332.7323.16435164322004213562.gitbox@gitbox.apache.org%3E" target="_blank" rel="noopener">资料</a>，认为可能是触发了RocketMQ的一个问题，就是事务消息进行了延迟发送。我们以为快接近真相了，我们开始查找Producer是否在发送事务消息时设置了DELAY参数。很快我们就失望了，Producer没有任何地方设置了DELAY参数。</p><h4 id="二、翻阅源码"><a href="#二、翻阅源码" class="headerlink" title="二、翻阅源码"></a>二、翻阅源码</h4><p>我们回头去看上面那个日志，发现<code>RECONSUME_TIME=1</code>并且<code>RETRY_TOPIC</code>也不为空，这说明这个消息肯定是被消费者消费到了，但是由于某种原因消费失败了，触发了重试。于是我们开始看RocketMQ重试相关源码。我们首先找到了DELAY=3这个参数的来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的消费者中设置了ConsumeConcurrentlyContext 延时级别</span></span><br><span class="line">context.setDelayLevelWhenNextConsume(getDelayLevelWhenNextConsume(reconsumeTimes));</span><br><span class="line"><span class="comment">//可以看到这个delayLevel最终是会被发送到broker</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap topic with namespace before sending back message.</span></span><br><span class="line">  msg.setTopic(<span class="keyword">this</span>.defaultMQPushConsumer.withNamespace(msg.getTopic()));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"sendMessageBack exception, group: "</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">" msg: "</span> + msg.toString(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找到对应broker版本(4.6.0)的源码一步步找到了这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.CommitLog#putMessage</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line"><span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">    || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">  <span class="comment">// Delay Delivery</span></span><br><span class="line">  <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">      msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">    queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">    msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">    msg.setTopic(topic);</span><br><span class="line">    msg.setQueueId(queueId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照之前日志里的参数，<code>sysFlag=8,delay=3</code>，我们认为很可能走了这段逻辑，然后触发了事务消息进行了延迟发送的问题。继续看了延时消息发送的逻辑，没有找到问题，而且这也解释不了为什么<code>REAL_TOPIC</code>变成了``RMQ_SYS_TRANS_HALF_TOPIC`</p><h4 id="三、真相"><a href="#三、真相" class="headerlink" title="三、真相"></a>三、真相</h4><p>上面还提到了一个<code>RETRY_TOPIC</code>，这个在之前的排查过程中没有发现有什么地方设置，于是我们搜索了一把，发现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(MessageExt msg, <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String brokerAddr = (<span class="keyword">null</span> != brokerName) ? <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</span><br><span class="line">            : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class="number">5000</span>, getMaxReconsumeTimes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"sendMessageBack Exception, "</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</span><br><span class="line"></span><br><span class="line">        Message newMsg = <span class="keyword">new</span> Message(MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span><br><span class="line"></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msg);</span><br><span class="line">        MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">        newMsg.setFlag(msg.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(newMsg, msg.getProperties());</span><br><span class="line">       <span class="comment">//这里设置了RETRY_TOPIC</span></span><br><span class="line">        MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span><br><span class="line">        MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class="number">1</span>));</span><br><span class="line">        MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span><br><span class="line">       </span><br><span class="line">        newMsg.setDelayTimeLevel(<span class="number">3</span> + msg.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQPushConsumer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显是个异常流程，那么到底是什么导致了这个异常流程呢？既然知道是在消费的时候出了异常，于是我们找到对应的消费者日志，发现如下错误：</p><p><img src="https://files.catbox.moe/42fapz.png" alt></p><p>这里Broker返回的错误是<code>MESSAGE_ILIEGAL</code>，在回过头去看重试相关代码，有了之前的经验这次很快就定位到了可能报这个错误的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一处：org.apache.rocketmq.store.DefaultMessageStore#putMessage </span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line"> log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//第二处：org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend(long, java.nio.ByteBuffer, int, org.apache.rocketmq.store.MessageExtBrokerInner)</span></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">  log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br></pre></td></tr></table></figure><p>果断找运维要了<code>store.log</code>，发现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN SendMessageThread_1 - putMessage message topic length too long 149</span><br></pre></td></tr></table></figure><p>所以应该就是第一处的问题了。至此问题的原因基本找到了，但还有以下问题：</p><ol><li><p>为什么TOPIC会超长？</p><p>重试的消息TOPIC规则为%RETRY%+consumerGroup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup())</span><br></pre></td></tr></table></figure><p>而我们的consumerGroup的规则为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group + <span class="string">"_"</span> + getTopic() + <span class="string">"_"</span> + getTags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题的consumer的tags为：<code>SAAS_PURCHASE_PURCHASE_ORDER_UPDATE||SAAS_PURCHASE_PURCHASE_ORDER_OPEN_RECEVIED||SAAS_PURCHASE_PURCHASE_ORDER_COMPLETED_RECEVIED</code></p><p>所以最终拼出来的TOPIC超出了长度。</p></li><li><p>为什么走了Catch里面的流程就会导致HALF队列爆掉？</p><p>这是由于我们使用的RocketMQ-client版本为<code>4.5.0</code>，这个版本Catch里的代码有个bug，没有清除掉原始消息的事务消息标志<code>TRANS_MSG=true</code>。所以这个消息发出去后在broker端又会走事务消息的流程，并且还是带延时的。这会导致真实的TOPIC丢掉。</p><p>下面用一张图来说明一下：</p><p><img src="https://files.catbox.moe/ssraef.png" alt></p><p>事务消息消费失败，topic转为<code>%RETRY%xxxx</code>发送到broker，由于事务消息标志没有被清除，于是topic转成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。又由于delay参数没有被清除，topic最后被转为了<code>schedule_topic_xxxx</code>。等到schedule执行时，消息会发到<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中。由于不是Producer发的事务消息，所以拿不到LocalTransactionState。只能等待事务消息回查。</p><p>这时刚好又碰到我们的LocalTransactionListener的一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">  Object msg = HessianUtils.decode(messageExt.getBody());</span><br><span class="line">  String topic = messageExt.getTopic();</span><br><span class="line">  String tag = messageExt.getTags();</span><br><span class="line">  <span class="comment">//由于拿着rmq_sys_trans_half_topic来获取handler所以肯定获取不到。</span></span><br><span class="line">  LocalTransactionHandler localTransacationHandler = getLocalTransacationHandler(topic, tag);</span><br><span class="line"></span><br><span class="line">  String msgId = messageExt.getMsgId();</span><br><span class="line">  <span class="keyword">if</span>( localTransacationHandler == <span class="keyword">null</span> )&#123;</span><br><span class="line">    logger.error(<span class="string">"localTransacationHandler is empty should never happened! msgId=&#123;&#125;, arg=&#123;&#125;"</span>, msgId, JSON.toJSONString(msg));</span><br><span class="line">    <span class="comment">//于是这个地方会返回COMMIT_MESSAGE</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> checkResult = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkResult = localTransacationHandler.localTransactionCheck(msgId, msg);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">"localTransacationCheck failed! msgId=&#123;&#125;, arg=&#123;&#125;"</span>, msgId, JSON.toJSONString(msg), e);</span><br><span class="line">    checkResult = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> checkResult ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broker收到<code>COMMIT_MESSAGE</code>后会将消息写往REAL_TOPIC中。而此时REAL_TOPIC早已变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。就这样，<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉了。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>首先我们将handler为空时返回<code>COMMIT_MESSAGE</code>，改为了<code>ROLLBACK_MESSAGE</code>。</p></li><li><p>升级stone中RocketMQ为4.6.1，可以看到在Catch代码中多了一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageAccessor.clearProperty(newMsg, &quot;TRAN_MSG&quot;);</span><br></pre></td></tr></table></figure></li><li><p>有问题的consumer将tag拆分</p><p>第一步和第二步只能解决<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉的问题。但是topic超长还是会有问题。所以目前暂时是将consumer的tag拆开。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;SaaS项目东郭反应，项目中发的事务消息一直在&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：&lt;img src=&quot;https://files.catbox.moe/gdp5ap.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了&lt;code&gt;TRANS_CHECK_MAXTIME_TOPIC&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;不正常的是&lt;code&gt;REAL_TOPIC&lt;/code&gt;变成了&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="RocketMQ" scheme="https://jingzhouzhao.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>读取Jar中指定目录下的所有文件</title>
    <link href="https://jingzhouzhao.github.io/archives/f728629b.html"/>
    <id>https://jingzhouzhao.github.io/archives/f728629b.html</id>
    <published>2020-03-19T03:47:54.000Z</published>
    <updated>2020-03-19T05:46:01.558Z</updated>
    
    <content type="html"><![CDATA[<p>读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。</p><a id="more"></a><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>首先要读取Jar中的目录下的文件，得先搞清楚Jar中的目录结构，例如常见的SpringBoot打包后的Jar中目录如下：</p><p><img src="/archives/f728629b/1.png" alt="1"></p><p>假如我们要读取的目录是<code>BOOT-INF/classes/processes</code>（对应源文件目录是<code>resources/processes</code>）</p><p><img src="/archives/f728629b/2.png" alt="2"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前Jar文件路径</span></span><br><span class="line">URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">""</span>);</span><br><span class="line">    String jarPath = url.toString().substring(<span class="number">0</span>, url.toString().indexOf(<span class="string">"!/"</span>) + <span class="number">2</span>);</span><br><span class="line">    log.info(<span class="string">"jarPath:&#123;&#125;"</span>, jarPath);</span><br><span class="line">    URL jarURL = <span class="keyword">new</span> URL(jarPath);</span><br><span class="line">    JarURLConnection jarCon = (JarURLConnection) jarURL.openConnection();</span><br><span class="line">    JarFile jarFile = jarCon.getJarFile();</span><br><span class="line"><span class="comment">//获取Jar下所有文件</span></span><br><span class="line">    Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">        JarEntry jarEntry = entries.nextElement();</span><br><span class="line">      <span class="comment">//获取文件路径</span></span><br><span class="line">        String innerPath = jarEntry.getName();</span><br><span class="line">        log.info(<span class="string">"jarEntry Name:&#123;&#125;"</span>, innerPath);</span><br><span class="line">      <span class="comment">//判断是否需要处理的目录下的文件，PROCESSES=BOOT-INF/classes/processes</span></span><br><span class="line">        <span class="keyword">if</span> (innerPath.startsWith(PROCESSES) &amp;&amp; !jarEntry.isDirectory()) &#123;</span><br><span class="line">          <span class="comment">//获取到文件流</span></span><br><span class="line">            InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(innerPath);</span><br><span class="line">          <span class="comment">//doSomething</span></span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式优缺点：无第三方库依赖，用的都是JDK 相关API。但是只能在jar模式下运行，本地调试会出错。</p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>如果有使用到Spring，那么不管是打成Jar运行还是本地运行，获取指定目录中的文件就很简单了。主要是利用了Spring 的<code>ResourcePatternResolver</code>，详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    List&lt;Resource&gt; resourceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = Arrays.asLIst("**.bpmn20.xml","**.bpmn")</span></span><br><span class="line">    <span class="keyword">for</span> (String suffix : PROCESS_DEFINITION_LOCATION_SUFFIXES) &#123;</span><br><span class="line">      <span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = classpath://processes/</span></span><br><span class="line">        <span class="comment">//拼接路径pattern</span></span><br><span class="line">        String path = PROCESS_DEFINITION_LOCATION_PREFIX + suffix;</span><br><span class="line">      <span class="comment">//通过ResourcePatternResolver获取资源文件,</span></span><br><span class="line">        <span class="comment">//resourceLoader = @Autowired ResourcePatternResolver resourceLoader</span></span><br><span class="line">        Resource[] resources = resourceLoader.getResources(path);</span><br><span class="line">        <span class="keyword">if</span> (resources != <span class="keyword">null</span> &amp;&amp; resources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            resourceList.addAll(Arrays.asList(resources));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过resource.getInputStream()即可获取文件流</span></span><br><span class="line"><span class="comment">//doSomething</span></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>此方式优缺点，依赖了Spring框架，但是对运行环境没有要求。</p><p>总结：</p><p>推荐使用第二种方式，毕竟现在基本上都会使用到Spring。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>tk.mybatis与Activiti共存问题解决</title>
    <link href="https://jingzhouzhao.github.io/archives/7008e148.html"/>
    <id>https://jingzhouzhao.github.io/archives/7008e148.html</id>
    <published>2020-03-05T12:53:07.000Z</published>
    <updated>2020-03-05T13:03:39.084Z</updated>
    
    <content type="html"><![CDATA[<p>由于tk.mybatis依赖了persistence-api，会让Activiti装配JpaProcessEngineAutoConfiguration，因为其@conditonalOnclass(name = “javax.persistence.EntityManagerFactory”)。</p><p>但实际没有使用JPA，导致启动报错。如果排除persistence-api，又会导致tk.mybatis报错。</p><p>参考了一番其它的人做法，无论是各种排除还是添加依赖都无效。</p><p>最终自己的解决方案是：</p><p>首先排除activiti jpa的自动装配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude&#x3D;&#123;JpaProcessEngineAutoConfiguration.class&#125;)。</span><br></pre></td></tr></table></figure><p>然后找到activiti中的<code>DataSourceProcessEngineAutoConfiguration.class</code> 复制出源码，在自己的项目中添加一个同名文件（不同名也行）。然后粘贴内容到新建的文件中。最后删掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnMissionClass(name &#x3D; &quot;javax.persistence.EntityManagerFactory&quot;)</span><br></pre></td></tr></table></figure><p>Ok,搞定！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于tk.mybatis依赖了persistence-api，会让Activiti装配JpaProcessEngineAutoConfiguration，因为其@conditonalOnclass(name = “javax.persistence.EntityManage
      
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Activiti" scheme="https://jingzhouzhao.github.io/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>被隔离的第7天</title>
    <link href="https://jingzhouzhao.github.io/archives/3eda1a9.html"/>
    <id>https://jingzhouzhao.github.io/archives/3eda1a9.html</id>
    <published>2020-03-03T05:22:11.000Z</published>
    <updated>2020-03-03T05:28:00.747Z</updated>
    
    <content type="html"><![CDATA[<p>被隔离的第7天，每天接到无数个部门的电话，量体温，报情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;被隔离的第7天，每天接到无数个部门的电话，量体温，报情况。&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://jingzhouzhao.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>更换电脑后hexo deploy访问出现404的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/32745de6.html"/>
    <id>https://jingzhouzhao.github.io/archives/32745de6.html</id>
    <published>2019-10-16T10:49:53.000Z</published>
    <updated>2019-10-16T11:14:24.615Z</updated>
    
    <content type="html"><![CDATA[<p>更换电脑后重新拉下hexo相关sources，安装完成hexo-cli以及hexo-deployer-git和其他node_modules。</p><p>执行hexo clean &amp;&amp; hexo g </p><p>然后执行hexo d。</p><a id="more"></a><p>完成后发现访问出现404，提示<strong>There isn’t a GitHub Pages site here.</strong></p><p>并且github发了大量警告邮件，有得没得，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are attempting to use a Jekyll theme, &quot;icarus&quot;, which is not supported by GitHub Pages.</span><br></pre></td></tr></table></figure><p>定位问题：</p><ol><li>查看github pages对应repository，发现里面的文件完全不正确，不是hexo g生成的文件。而变成了博客对应的源文件。</li><li>查看文件是否正确生成，public目录下正确生成。</li><li>通过上面两个步骤，说明问题出在deploy。</li></ol><p>解决问题：</p><p>删除<code>.deploy_git</code>，重新<code>hexo d</code>，一切恢复正常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更换电脑后重新拉下hexo相关sources，安装完成hexo-cli以及hexo-deployer-git和其他node_modules。&lt;/p&gt;
&lt;p&gt;执行hexo clean &amp;amp;&amp;amp; hexo g &lt;/p&gt;
&lt;p&gt;然后执行hexo d。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>PriorityQueue解析</title>
    <link href="https://jingzhouzhao.github.io/archives/f50feeee.html"/>
    <id>https://jingzhouzhao.github.io/archives/f50feeee.html</id>
    <published>2019-10-10T02:13:00.000Z</published>
    <updated>2019-10-16T09:05:40.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载至github：<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md</a></p></blockquote><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><a id="more"></a><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p><code>leftNo = parentNo*2+1</code></p><p><code>rightNo = parentNo*2+2</code></p><p><code>parentNo = (nodeNo-1)/2</code></p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftUp()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></p><p>代码也就非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftDown()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    <span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载至github：&lt;a href=&quot;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PriorityQueue&quot;&gt;&lt;a href=&quot;#PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue&quot;&gt;&lt;/a&gt;PriorityQueue&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerlink&quot; title=&quot;总体介绍&quot;&gt;&lt;/a&gt;总体介绍&lt;/h1&gt;&lt;p&gt;前面以Java &lt;em&gt;ArrayDeque&lt;/em&gt;为例讲解了&lt;em&gt;Stack&lt;/em&gt;和&lt;em&gt;Queue&lt;/em&gt;，其实还有一种特殊的队列叫做&lt;em&gt;PriorityQueue&lt;/em&gt;，即优先队列。&lt;strong&gt;优先队列的作用是能保证每次取出的元素都是队列中权值最小的&lt;/strong&gt;（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，&lt;strong&gt;元素大小的评判可以通过元素本身的自然顺序（&lt;em&gt;natural ordering&lt;/em&gt;），也可以通过构造时传入的比较器&lt;/strong&gt;（&lt;em&gt;Comparator&lt;/em&gt;，类似于C++的仿函数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker-alpine镜像导致的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/f3674cca.html"/>
    <id>https://jingzhouzhao.github.io/archives/f3674cca.html</id>
    <published>2019-09-26T05:04:26.000Z</published>
    <updated>2019-10-16T09:05:40.003Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。</p><a id="more"></a><p>通过查找日志发现以下异常堆栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="keyword">null</span></span><br><span class="line">        at sun.awt.X11FontManager.getDefaultPlatformFont(X11FontManager.java:<span class="number">779</span>)</span><br><span class="line">        at sun.font.SunFontManager$<span class="number">2</span>.run(SunFontManager.java:<span class="number">433</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:<span class="number">376</span>)</span><br><span class="line">        at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:<span class="number">32</span>)</span><br><span class="line">        at sun.reflect.GeneratedConstructorAccessor62.newInstance(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">        at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">526</span>)</span><br><span class="line">        at java.lang.Class.newInstance(Class.java:<span class="number">383</span>)</span><br><span class="line">        at sun.font.FontManagerFactory$<span class="number">1</span>.run(FontManagerFactory.java:<span class="number">83</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:<span class="number">74</span>)</span><br><span class="line">        at java.awt.Font.getFont2D(Font.java:<span class="number">490</span>)</span><br><span class="line">        at java.awt.Font.access$<span class="number">000</span>(Font.java:<span class="number">224</span>)</span><br><span class="line">        at java.awt.Font$FontAccessImpl.getFont2D(Font.java:<span class="number">228</span>)</span><br><span class="line">        at sun.font.FontUtilities.getFont2D(FontUtilities.java:<span class="number">180</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:<span class="number">645</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:<span class="number">806</span>)</span><br><span class="line">        at sun.java2d.pipe.GlyphListPipe.drawString(GlyphListPipe.java:<span class="number">50</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.drawString(SunGraphics2D.java:<span class="number">2887</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>结合源码发现，应该是无法获取到字体导致的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphics.setFont(new Font(&quot;Default&quot;, Font.PLAIN, fsize));</span><br></pre></td></tr></table></figure><p>由于代码没有做出过变更，所以毫无疑问，应该是环境的问题了。</p><p>于是我进入Dokcer容器查看相关字体：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it containerId bash</span><br><span class="line">fc-list</span><br></pre></td></tr></table></figure><p>发现无任何内容输出。经过一番查找，解决办法如下：</p><ol><li><p>进入容器安装字体（只能临时解决，当重新构建后，字体会丢失）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>修改Dockerfile 在构建镜像时安装字体（会影响构建速度，安装字体比较慢）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>更改基础镜像（推荐）</p><p>我这边出问题的容器是基于<code>tomcat:8.0-jre7-alpine</code>构建的，alpine tag的镜像比较小，比较干净。</p><p>我到docker hub上找到了类似的镜像，<code>slim</code> tag的。</p><p>修改Dockerfile，将<code>FROM tomcat:8.0-jre7-alpine</code> 改为 <code>FROM tomcat:8.0-jre7-slim</code>即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker随记" scheme="https://jingzhouzhao.github.io/categories/Docker%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://jingzhouzhao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>为什么苹果不自己制造芯片</title>
    <link href="https://jingzhouzhao.github.io/archives/52360944.html"/>
    <id>https://jingzhouzhao.github.io/archives/52360944.html</id>
    <published>2019-09-20T02:01:43.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？</p><a id="more"></a><p>原来业内习惯把半导体行业的公司分为三类：</p><p>fabless（无晶圆芯片设计厂）：这样的公司只设计芯片，不自己制造芯片。最大的fabless企业有高通、博通、AMD、联发科、搭上人工智能这波热点最近火的不行的Nvidia等等。国内的fabless企业有收购了展讯和锐迪科的清华紫光、华为海思等。<br>Foundry（代工厂）：这样的公司专门为别人制造芯片。最大的Foundry企业有台积电（TSMC）、GlobalFoundry、UMC等。国内最大的是中芯国际。随着工艺进步到20nm以下，从平面晶体管向三维FinFET演化，新一代工艺所需要的投资越来越大，已经只有少数几个玩家能玩得起了（台积电、三星、Intel）。国内的中芯国际跟台积电有几代的差距。中芯国际目前商用的最先进工艺是28nm，台积电16nm已经大规模商用，7nm也马上就要用起来。<br>IDM（制造垂直整合）：这样的公司既设计芯片，也自己制造芯片。最大的有Intel和三星。</p><p>这样做的好处是，分担风险，苹果不用花费巨大投资建立生产线，因此轻资产，灵活性高，可以对市场快速反应，活力足。</p><p>再说另外一个问题，为什么主流的手机处理器厂商中很少见到英特尔呢？<br>首先提一下CPU的简单构成：ALU（算术逻辑单元）、控制单元、寄存器<br>控制单元通过时钟控制着指令执行的节奏，将指令加载存放在寄存器、并通过ALU计算。<br>这里提到了指令，指令基本上分为两类：RISC（精简指令集） 、CISC （复杂指令集），指令越复杂意味着能耗越高，试想一下，在目前手机电池技术还未突破的情况下，手机CPU会上CISC吗？<br>上面说的两个指令集的典型代表就是ARM和x86，ARM是目前主流的手机CPU架构，也就是精简指令。而x86才是英特尔等厂商的强项。<br>也许是英特尔出于战略考虑放弃了移动处理器这块蛋糕，或者说英特尔没有意料到这块蛋糕这么大。不过，目前App背后对应的还是各种Server，Server离不开x86。</p><p>参考资料：<br><a href="https://www.zhihu.com/question/68283951/answer/262481048" target="_blank" rel="noopener">https://www.zhihu.com/question/68283951/answer/262481048</a><br><a href="https://www.zhihu.com/question/20148756" target="_blank" rel="noopener">https://www.zhihu.com/question/20148756</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>golang写文件异常invalid argument</title>
    <link href="https://jingzhouzhao.github.io/archives/848ae75e.html"/>
    <id>https://jingzhouzhao.github.io/archives/848ae75e.html</id>
    <published>2019-09-11T07:10:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">defer</span> dst.Close()</span><br><span class="line">n, err := dst.Write(buffer.Buffer[<span class="number">0</span>:n])</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是一段很简单的代码，但是在频繁调用的时候报错了了:<code>invalid argument</code></p><p>这个错误着实太误导人了，让我以为是使用的姿势不对，后来发现没有问题，于是开始debug，后来在下面一段代码中发现了真正的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFile</span><span class="params">(name *<span class="keyword">uint16</span>, access <span class="keyword">uint32</span>, mode <span class="keyword">uint32</span>, sa *SecurityAttributes, createmode <span class="keyword">uint32</span>, attrs <span class="keyword">uint32</span>, templatefile <span class="keyword">int32</span>)</span> <span class="params">(handle Handle, err error)</span></span> &#123;</span><br><span class="line">r0, _, e1 := Syscall9(procCreateFileW.Addr(), <span class="number">7</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(name)), <span class="keyword">uintptr</span>(access), <span class="keyword">uintptr</span>(mode), <span class="keyword">uintptr</span>(unsafe.Pointer(sa)), <span class="keyword">uintptr</span>(createmode), <span class="keyword">uintptr</span>(attrs), <span class="keyword">uintptr</span>(templatefile), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">handle = Handle(r0)</span><br><span class="line"><span class="keyword">if</span> handle == InvalidHandle &#123;</span><br><span class="line"><span class="keyword">if</span> e1 != <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">err = errnoErr(e1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = EINVAL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出了真正的原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; errnoErr(e1)&#x2F;&#x2F;这个地方给出了真正的错误：ERROR_SHARING_VIOLATION (32)</span><br></pre></td></tr></table></figure><p>查询微软<a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-文档，" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-文档，</a></p><p>这个错误是因为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The process cannot access the file because it is being used by another process.</span><br></pre></td></tr></table></figure><p>也就是说，在OpenFile一个文件的时候，之前使用的这个文件的file descriptor 并真正没有释放，所以出错了。</p><p>而Golang上层的错误并没有给出明确的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dst, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, &lt;span class=&quot;number&quot;&gt;0644&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; dst.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n, err := dst.Write(buffer.Buffer[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:n])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://jingzhouzhao.github.io/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://jingzhouzhao.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>跟着B站学Golang(admin-ep-saga)</title>
    <link href="https://jingzhouzhao.github.io/archives/f11de5dd.html"/>
    <id>https://jingzhouzhao.github.io/archives/f11de5dd.html</id>
    <published>2019-09-05T08:50:12.000Z</published>
    <updated>2019-10-16T09:05:40.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文完全出于学习的目的，如有异议，请联系删除。</p></blockquote><p>之前XL事件流出的优秀代码太多了，这次选择的是一个好像与具体业务无关的模块(admin-ep-saga)来进行学习。</p><a id="more"></a><p>首先看看目录结构：</p><p><img src="/archives/f11de5dd/1.png" alt="目录结构"></p><p>这么多先看哪一个呢？在不知道具体每个包是干什么的情况下，只好一个一个的看了。</p><p>先看看<code>api</code>下有些什么：</p><p><img src="/archives/f11de5dd/2.png" alt="api"></p><p>不得不说这个目录的结构相当规范呀，虽然我没有点开具体文件，但是仅仅从目录名和文件名就能猜出这个目录下是干什么的：</p><p>应该是使用了grpc框架和protobuf协议定义的接口。这个暂时先放一边，我需要先找到<strong>程序入口</strong>，这样才能一步一步的学习优秀代码是如何编写的。</p><p>接下来打开<code>cmd</code>:</p><p><img src="/archives/f11de5dd/3.png" alt="cmd"></p><p>这个目录下有三个文件：</p><ol><li><code>BUILD</code>看着应该是用来做构建用的，这不是我这次学习的重点，先跳过。</li><li><code>saga-admin-test.toml</code> 我打开看了一眼，是一个配置文件，从名字可以看出应该是测试用的配置项，后面还会碰到。</li><li><code>main.go</code> 如果不出意外，这个应该就是<strong>程序入口</strong>了，运气还不错，第二个目录就找到了入口。</li></ol><p>接下来详细的看看main.go做了些什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里我忽略了一些包导入，以及一些常量</span></span><br><span class="line"><span class="comment">因为如果每个导入的包都要看的话，会越陷越深。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line">    <span class="comment">//初始化配置</span></span><br><span class="line"><span class="keyword">if</span> err := conf.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"conf.Init() error(%v)"</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化Log</span></span><br><span class="line">log.Init(conf.Conf.Log)</span><br><span class="line"><span class="keyword">defer</span> log.Close()</span><br><span class="line">log.Info(<span class="string">"saga-admin start"</span>)</span><br><span class="line"><span class="comment">//启动一个服务</span></span><br><span class="line">s := service.New()</span><br><span class="line">http.Init(s)</span><br><span class="line">    <span class="comment">//启动一个grpc服务</span></span><br><span class="line">grpcsvr, err := grpc.New(<span class="literal">nil</span>, s.Wechat())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建一个长度为1的os.Signal类型的channel</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">//通知</span></span><br><span class="line">signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//从前面创建的channel中读取signal</span></span><br><span class="line">si := &lt;-c</span><br><span class="line">log.Info(<span class="string">"saga-admin get a signal %s"</span>, si.String())</span><br><span class="line"><span class="keyword">switch</span> si &#123;</span><br><span class="line">        <span class="comment">//如果是SIGQUIT、SIGTERM、SIGINT则关闭相关服务，然后退出</span></span><br><span class="line"><span class="keyword">case</span> syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:</span><br><span class="line">grpcsvr.Shutdown(context.Background())</span><br><span class="line">log.Info(<span class="string">"saga-admin exit"</span>)</span><br><span class="line">s.Close()</span><br><span class="line">time.Sleep(_durationForClosingServer * time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略的看了一下代码后，带着疑问，一行一行的来分析，首先第一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure><p>作为Golang小白，我知道这个应该是使用在<code>flag.StringVar</code>这样的代码后面，定义需要获取的命令行参数。</p><p>但是<code>flag.Parse()</code>作为第一行代码前面并没有<code>flag.StringVar</code>类似这样的代码呀，然后我想到了Golang中<code>init</code>函数的作用。于是我开始找<code>main.go</code>中导入的其他包中有没有定义init函数，果不其然，在<code>saga/conf/conf.go</code>中我找到了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个命令行参数，用来接收配置文件路径</span></span><br><span class="line">flag.StringVar(&amp;confPath, <span class="string">"conf"</span>, <span class="string">""</span>, <span class="string">"config path"</span>)</span><br><span class="line">    <span class="comment">//这个reload后面再讲</span></span><br><span class="line">reload = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>main.go</code>来看下面几行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := conf.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Error(<span class="string">"conf.Init() error(%v)"</span>, err)</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略错误判断以及日志打印，我们可以看到这几行中最关键的代码就是<code>conf.Init()</code>，这个代码做了些什么事情呢？接下来进入<code>saga/conf/conf.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//判断如果配置文件的路径为空，则执行configCenter()方法</span></span><br><span class="line"><span class="keyword">if</span> confPath == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> configCenter()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果配置文件路径不为空通过toml.DecodeFile(confPath, &amp;Conf)解析配置到&amp;Conf中</span></span><br><span class="line"><span class="keyword">if</span> _, err = toml.DecodeFile(confPath, &amp;Conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"toml.DecodeFile(%s) err(%+v)"</span>, confPath, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//单独解析TeamInfo相关配置</span></span><br><span class="line">Conf = parseTeamInfo(Conf)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> confPath == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> configCenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数名可以看出，当没有手动指定配置文件路径是，走配置中心解析配置。<code>configCenter</code>我们先放一放，我们接着往下看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err = toml.DecodeFile(confPath, &amp;Conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"toml.DecodeFile(%s) err(%+v)"</span>, confPath, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟之前一样，我们忽略错误和日志处理，可以看到这几行关键代码是<code>toml.DecodeFile(confPath, &amp;Conf)</code>，</p><p><code>toml</code>这个看着是不是很眼熟，之前在<code>cmd</code>包下我们看到过一个这个格式的文件<code>saga-admin-test.toml</code>，这是一个由GitHub联合创始人Tom Preston-Werner 搞出的极简配置文件格式。各个语言都有相关实现，BZ这里使用的是<code>github.com/BurntSushi/toml</code>这个库。</p><p>总而言之，这几行代码无非就是解析配置文件。</p><p>继续往下看:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conf = parseTeamInfo(Conf)</span><br></pre></td></tr></table></figure><p>单独用了一个方法来解析<code>TeamInfo</code>说明toml标准的DecodeFile解析不了，我们来看看这个方法做了什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个方法做的事情比较简单，直接采用注释的方法讲解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseTeamInfo</span><span class="params">(c *Config)</span> *<span class="title">Config</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strings.Fields，我们都知道这个是根据字符串中的空格或者一些个特殊符号来拆分字符串为Array的方法。</span></span><br><span class="line"><span class="comment">我们来看看之前提到的saga-admin-test.toml中c.Property.Department 定义的是什么：</span></span><br><span class="line"><span class="comment">[property.department]</span></span><br><span class="line"><span class="comment">        label = "主站 直播 bplus 开放平台 创作中心 商业产品 数据中心 视频云 游戏 火鸟"</span></span><br><span class="line"><span class="comment">        value = "mainsite live bplus openplatform creative advertising datacenter videocloud game firebird"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DeLabel := strings.Fields(c.Property.Department.Label)</span><br><span class="line">DeValue := strings.Fields(c.Property.Department.Value)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(DeLabel); i++ &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">所以这几行代码，很显而易见了，就是将上述的label 和value组合成key-value的形式然后append到另外一个(DeInfo)Array中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">info := &amp;model.PairKey&#123;</span><br><span class="line">Label: DeLabel[i],</span><br><span class="line">Value: DeValue[i],</span><br><span class="line">&#125;</span><br><span class="line">c.Property.DeInfo = <span class="built_in">append</span>(c.Property.DeInfo, info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面几行代码同上，就不在赘述</span></span><br><span class="line">buLabel := strings.Fields(c.Property.Business.Label)</span><br><span class="line">buValue := strings.Fields(c.Property.Business.Value)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(buLabel); i++ &#123;</span><br><span class="line"></span><br><span class="line">info := &amp;model.PairKey&#123;</span><br><span class="line">Label: buLabel[i],</span><br><span class="line">Value: buValue[i],</span><br><span class="line">&#125;</span><br><span class="line">c.Property.BuInfo = <span class="built_in">append</span>(c.Property.BuInfo, info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话说，上面的<code>Business</code>和<code>Department</code>处理过程一样，为啥不将这个过程提取成一个函数呢？来自小白的疑问。</p><p>还记得我们之前跳过一个函数<code>configCenter()</code>吗？接下来我们一起来看看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configCenter</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里的conf应该是BZ一个公共组件，这里做的就是创建一个配置中心的client</span></span><br><span class="line"><span class="keyword">if</span> client, err = conf.New(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里调用了load函数</span></span><br><span class="line"><span class="keyword">if</span> err = load(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里应该是添加了一个配置中心的监听</span></span><br><span class="line">client.WatchAll()</span><br><span class="line">    <span class="comment">//起一个goroute</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//获取事件，如果配置中心的配置存在修改重新调用load函数</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> client.Event() &#123;</span><br><span class="line">log.Info(<span class="string">"config reload"</span>)</span><br><span class="line"><span class="keyword">if</span> load() != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"config reload error (%v)"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//load成功往reload chan写入一个数据，这里有个疑问，等后面再说</span></span><br><span class="line">reload &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略其它代码，可以看到上面实现配置中心配置加载的应该是load函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一组局部变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">s       <span class="keyword">string</span></span><br><span class="line">ok      <span class="keyword">bool</span></span><br><span class="line">tmpConf *Config</span><br><span class="line">)</span><br><span class="line">    <span class="comment">//通过配置中心的client获取配置，这里的_configkey是常量："saga-admin.toml"</span></span><br><span class="line"><span class="keyword">if</span> s, ok = client.Value(_configKey); !ok &#123;</span><br><span class="line">err = errors.Errorf(<span class="string">"load config center error [%s]"</span>, _configKey)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//跟之前一样通过toml解析配置</span></span><br><span class="line"><span class="keyword">if</span> _, err = toml.Decode(s, &amp;tmpConf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.Wrapf(err, <span class="string">"could not decode config err(%+v)"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//跟之前一样单独解析TeamInfo</span></span><br><span class="line">Conf = parseTeamInfo(tmpConf)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们差不多刚刚看完<code>main.go</code>中<code>conf.Init()</code>的调用，接下来回到<code>main.go</code>，继续往下看：</p><p>我们跳过Log的初始化，直接看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用/saga/service中的New函数</span></span><br><span class="line">s := service.New()</span><br><span class="line"><span class="comment">//调用/saga/http中的Init函数</span></span><br><span class="line">http.Init(s)</span><br></pre></td></tr></table></figure><p>跳转到<code>New</code>函数中，我们看看做了些什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(s *Service)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">err error</span><br><span class="line">)</span><br><span class="line">s = &amp;Service&#123;</span><br><span class="line">dao:  dao.New(),</span><br><span class="line">cron: cron.New(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncProject.CheckCron, s.collectprojectproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.Git.CheckCron, s.alertProjectPipelineProc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCron, s.syncdataproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCronAll, s.syncalldataproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncData.CheckCronWeek, s.syncweekdataproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">s.cron.Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// init gitlab client</span></span><br><span class="line">s.gitlab = gitlab.New(conf.Conf.Property.Gitlab.API, conf.Conf.Property.Gitlab.Token)</span><br><span class="line"><span class="comment">// init online gitlab client</span></span><br><span class="line">s.git = gitlab.New(conf.Conf.Property.Git.API, conf.Conf.Property.Git.Token)</span><br><span class="line"><span class="comment">// init wechat client</span></span><br><span class="line">s.wechat = wechat.New(s.dao)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码大部分都是在做定时任务的创建，<code>cron</code>使用的是<code>&quot;github.com/robfig/cron&quot;</code>这个库，我们挑一个看看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = s.cron.AddFunc(conf.Conf.Property.SyncProject.CheckCron, s.collectprojectproc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>conf.Conf.Property.SyncProject.CheckCron</code> 是配置中的cron表达式，在<code>saga-admin-test.toml</code>中看到是</p><p><code>* */15 * * * ?</code>也就是说这个任务每15分钟执行一次。</p><p><code>s.collectprojectproc</code> 是要执行的任务，接下来看看这个任务做了什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">collectprojectproc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">    <span class="comment">//可以看到实际调用的是CollectProject，这里的context.TODO()表示context还未实现，这里仅仅用作占位，没有实际意义</span></span><br><span class="line"><span class="keyword">if</span> err = s.CollectProject(context.TODO()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"s.CollectProject err (%+v)"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">CollectProject</span><span class="params">(c context.Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是一组局部变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">projects []*gitlab.Project</span><br><span class="line">total    = <span class="number">0</span></span><br><span class="line">page     = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">"Collect Project start"</span>)</span><br><span class="line">    <span class="comment">//这里出现了一个magic number，1000</span></span><br><span class="line"><span class="keyword">for</span> page &lt;= <span class="number">1000</span> &#123;</span><br><span class="line"><span class="comment">//调用gitlab接口获取指定页码的项目列表，这里的s.gitlab是在service.New()中实例化的。这里有一个疑问。</span></span><br><span class="line"><span class="keyword">if</span> projects, err = s.gitlab.ListProjects(page); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num := <span class="built_in">len</span>(projects)</span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">total = total + num</span><br><span class="line"><span class="comment">//将获取到的项目保存到db中，这个insertDB就不展开讲了，这里面做的大概就是saveOrUpdate的事情。</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> projects &#123;</span><br><span class="line"><span class="keyword">if</span> err = s.insertDB(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = page + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"Collect Project end, find %d projects"</span>, total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service.New()</code>中其他的cron也差不多是做着类似的事情，由于太多，就不在这里一一展开。刚刚说到</p><p><code>s.gitlab.ListProjects(page);</code>我有一个疑问，是什么呢？我们看这里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.cron.Start()</span><br><span class="line"><span class="comment">// init gitlab client</span></span><br><span class="line">s.gitlab = gitlab.New(conf.Conf.Property.Gitlab.API, conf.Conf.Property.Gitlab.Token)</span><br><span class="line"><span class="comment">// init online gitlab client</span></span><br><span class="line">s.git = gitlab.New(conf.Conf.Property.Git.API, conf.Conf.Property.Git.Token)</span><br><span class="line"><span class="comment">// init wechat client</span></span><br><span class="line">s.wechat = wechat.New(s.dao)</span><br></pre></td></tr></table></figure><p>可以发现cron的start是在gitlab、git、wechat实例化之前，而cron相关的任务中又依赖了这些client，那有没有这么一种可能：这个程序启动的时候正好碰上cron触发，而gitlab，wechat这些client还没有实例化，所以有没有可能出现panic？当然了，这个可能性很小。</p><p>让我们再次回到main.go中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个http服务</span></span><br><span class="line">http.Init(s)</span><br></pre></td></tr></table></figure><p>进入<code>Init</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init init</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(s *service.Service)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这个srv很重要，这是在上面service.New()最后返回的实例，在后面经常用到</span></span><br><span class="line">srv = s</span><br><span class="line">    <span class="comment">//这个permit是go-common/library/net/http/blademaster 中的组件，应该是用来做接口认证的</span></span><br><span class="line">authSvc = permit.New2(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//下面就是启动http engine了，这个engine就是上面提到的这个blademaster</span></span><br><span class="line">engine := bm.DefaultServer(conf.Conf.BM)</span><br><span class="line">engine.Ping(ping)</span><br><span class="line">initRouter(engine)</span><br><span class="line"><span class="keyword">if</span> err := engine.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"engine.Start error(%v)"</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个http服务是依赖的BZ公共的组件，就不继续深入了，我怕出不来了。我们看看<code>initRouter</code>中定义的Router，由于太长，我只选择开始一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version := e.Group(<span class="string">"/ep/admin/saga/v1"</span>, authSvc.Permit2(<span class="string">""</span>))</span><br><span class="line">&#123;</span><br><span class="line">project := version.Group(<span class="string">"/projects"</span>)</span><br><span class="line">&#123;</span><br><span class="line">project.GET(<span class="string">"/favorite"</span>, favoriteProjects)</span><br><span class="line">project.POST(<span class="string">"/favorite/edit"</span>, editFavorite)</span><br><span class="line">project.GET(<span class="string">"/common"</span>, queryCommonProjects)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就是很常见的url-mapping了，这里的<code>favoriteProjects</code>、<code>editFavorite</code>、<code>queryCommonProjects</code> 都是定义在当前<code>http</code>包下的函数，我们选择<code>favoriteProjects</code>看下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoriteProjects</span><span class="params">(ctx *bm.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">req      = &amp;model.Pagination&#123;&#125;</span><br><span class="line">err      error</span><br><span class="line">userName <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">    <span class="comment">//这里应该是解析请求参数到req变量中</span></span><br><span class="line"><span class="keyword">if</span> err = ctx.Bind(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="literal">nil</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里是调用函数获取当前用户名</span></span><br><span class="line"><span class="keyword">if</span> userName, err = getUsername(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="literal">nil</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//我们看到这里最终回到了srv上，调用了实际的处理方法。这里的FavoriteProjects实际就是通过db查询当前用户收藏的项目，我们就不继续深入了。</span></span><br><span class="line">ctx.JSON(srv.FavoriteProjects(ctx, req, userName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的流程大概是这样的，首先在<code>http</code>包中将参数等一些信息进行解析，最后调用到了<code>service</code>中的方法。这个就很像Java中流行的写法：从<code>Controller</code>到<code>Service</code>，符合<code>MVC</code>分层的思想。</p><p>最后还有一个grpc，我大概看了下，应该是用来企业微信发消息的。</p><p>总结：</p><p>这应该是用来做gitlab ci告警之类的project，可以看到这个project层次很分明，代码看过去一目了然。</p><p>最后，之前还有一个疑问，就是<code>reload</code>这个变量，在初始化时是有长度的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>长度为10，在每次配置文件修改后，goroute watch到event之后会往这个channel写入一个<code>true</code>，但是看完整个代码之后，并没有看到有地方从这个channel取出数据（也有可能是我漏看了），也就是说当修改10次之后，这个地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>就会阻塞，从而导致这个goroute无响应？</p><p>码字不易，且转且珍惜。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文完全出于学习的目的，如有异议，请联系删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前XL事件流出的优秀代码太多了，这次选择的是一个好像与具体业务无关的模块(admin-ep-saga)来进行学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://jingzhouzhao.github.io/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://jingzhouzhao.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一张图说明Golang的并发模型MPG</title>
    <link href="https://jingzhouzhao.github.io/archives/79f4a57c.html"/>
    <id>https://jingzhouzhao.github.io/archives/79f4a57c.html</id>
    <published>2019-09-04T03:10:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 天生支持并发，Goroutine是Go 最吸引人的地方，采用的是CSP并发通信模型。到底Go是怎么支持高并发的呢？这里就需要说一说Golang 的MPG模型。</p><a id="more"></a><ol><li><strong>M</strong> 代表着一个内核线程 ，一个M就是一个内核线程，goroutine就是跑在M之上的</li><li><strong>P</strong> 代表着(Processor)处理器， 它的主要用途就是用来执行goroutine的，所以它也维护了一个可运行的goroutine队列，和自由的goroutine队列，里面存储了所有需要它来执行的goroutine。</li><li><strong>G</strong> 代表着goroutine 实际的数据结构，并维护者goroutine 需要的栈、程序计数器以及它所在的M等信息。</li><li><strong>Sched</strong> 代表着一个调度器 它维护有存储空闲的M队列和空闲的P队列，可运行的G队列，自由的G队列以及调度器的一些状态信息等。</li></ol><p>一张图就可以说明MPG模型：</p><p><img src="/archives/79f4a57c/1.jpg" alt="MPG"></p><p>图中的“土拨鼠”代表的就是<strong>M</strong>，“推车”代表的是<strong>P</strong>，“木块”代表的就是<strong>G</strong>。在这张图外还存在一个特殊的”土拨鼠“这个”土拨鼠“就是”包工头“<strong>Sched</strong>。</p><p><img src="/archives/79f4a57c/2.png" alt="Sched"></p><p>从图中我们可以看到“土拨鼠“不停地将“木块“搬运到“推车“上，然后推去烧。在这个过程中可能出现“土拨鼠“因为累坏了，而处理的速度变慢的情况，这个时候“包工头“就出现了，“包工头“非常体贴的将这个“土拨鼠“的“推车“交给其他“土拨鼠“去处理。如果一个“土拨鼠“的“推车“里面的“木块“装的太多，“包工头“也会让其它的“土拨鼠“去帮忙拿出一些来。当“包工头“发现现有的“土拨鼠“已经忙不过来的时候，就回去找一些新的“土拨鼠“过来，并给他们配发“推车“。直到所有的“木块“都烧完为止。</p><p>上面说到的几种情况：</p><ol><li>“土拨鼠”累坏了，形容的是IO等耗时的操作。</li><li>其他“土拨鼠”帮忙，形容的是工作窃取算法（work stealing），这个算法在很多语言中都有应用，例如Java中的Fork/Foin。</li></ol><p>在Golang中土拨鼠默认的数量是CPU的核数，土拨鼠通过CSP模型沟通。</p><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/22352969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22352969</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 天生支持并发，Goroutine是Go 最吸引人的地方，采用的是CSP并发通信模型。到底Go是怎么支持高并发的呢？这里就需要说一说Golang 的MPG模型。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://jingzhouzhao.github.io/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://jingzhouzhao.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go Module 引入本地自定义包</title>
    <link href="https://jingzhouzhao.github.io/archives/c8d527a1.html"/>
    <id>https://jingzhouzhao.github.io/archives/c8d527a1.html</id>
    <published>2019-09-04T02:20:49.000Z</published>
    <updated>2019-10-16T09:05:40.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载至 <a href="http://www.r9it.com/20190611/go-mod-use-dev-package.html#1-启用-go-module" target="_blank" rel="noopener">小一辈无产阶级码农</a></p></blockquote><p>最近由于项目要求，需要对 <code>IPFS</code> 源码进行修改，由于自己在此之前没有接触过 Go 语言，在使用 <code>go mod</code> 导入本地自己开发的工具包的时候折腾了好久才搞定。 记录一下，以备后期查阅。 Go 语言的 Module 新特性是在 go1.11 的发布之后才支持的，这是 Go 语言新的一套依赖管理系统。</p><a id="more"></a><p>文章导读</p><ul><li><a href="#1-启用-Go-Module">1. 启用 Go Module</a></li><li><a href="#2-创建-Go-Module">2. 创建 Go Module</a></li><li><a href="#3-Go-Module-版本规则">3. Go Module 版本规则</a></li><li><a href="#4-引入本地依赖包">4. 引入本地依赖包</a></li><li><a href="#5-使用-replace-将远程包替换为本地包服务">5. 使用 replace 将远程包替换为本地包服务</a></li></ul><h1 id="1-启用-Go-Module"><a href="#1-启用-Go-Module" class="headerlink" title="1. 启用 Go Module"></a>1. 启用 Go Module</h1><p>首先在默认情况下，<code>$GOPATH</code> 默认情况下是不支持 go mudules 的，当你执行 <code>go mod init</code> 的时候会遇到如下错误：</p><blockquote><p>go: modules disabled inside GOPATH/src by GO111MODULE=auto; see ‘go help modules’</p></blockquote><p>我们需要在执行 <code>go mod</code> 命令之前，导出 <code>GO111MODULE</code> 环境变量，你可以直接临时一次性导出， 为了后面方便，建议直接在 <code>~/.bashrc</code> 文件中导出， 在文件末尾加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure><p>Bash</p><p>从这也表明了 go 将来是要利用 modules 机制去消灭 <code>$GOPATH</code> 的。</p><h1 id="2-创建-Go-Module"><a href="#2-创建-Go-Module" class="headerlink" title="2. 创建 Go Module"></a>2. 创建 Go Module</h1><p>我们现在 <code>$GOPATH</code> 下面先创建一个项目，并初始化 module</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $GOPATH/src/gitee.com/rockyang/testmod -p</span><br><span class="line">cd $GOPATH/src/gitee.com/rockyang/test-gomod</span><br><span class="line">go mod init gitee.com/rockyang/test-gomod</span><br><span class="line">go: creating new go.mod: module gitee.com/rockyang/testmod</span><br></pre></td></tr></table></figure><p>Bash</p><p>这时，我们新建的项目已经成为了一个 module 了，我们可以在项目中随便写几个函数导出测试。</p><p>Note: 我这里使用的是<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>做项目托管，没有使用 github，国内码云确实比 github 快得多。</p><p>接下来你可以选择把项目推送到远程仓库，如果你的仓库是公开的话，别人就是可以直接使用 <code>go get</code> 命令去下载你的项目了。</p><p>如果是私有项目只想给内部使用，则你可以参考我的这篇博客的做法。<a href="http://www.r9it.com/21090611/go-mod-use-private-package.html" target="_blank" rel="noopener">Go Module 使用私有仓库作为项目依赖包</a></p><h1 id="3-Go-Module-版本规则"><a href="#3-Go-Module-版本规则" class="headerlink" title="3. Go Module 版本规则"></a>3. Go Module 版本规则</h1><p>go modules 是一个版本化依赖管理系统，版本需要遵循一些规则，打开一个 <code>go.mod</code> 文件，你会发现类似下面的依赖规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">github.com/filecoin-project/go-leb128 v0.0.0-20190212224330-8d79a5489543</span><br><span class="line">github.com/golang/mock v1.2.0 // indirect</span><br><span class="line">github.com/ipfs/go-bitswap v0.0.2</span><br><span class="line">github.com/libp2p/go-stream-muxer v0.0.1</span><br><span class="line">github.com/minio/blake2b-simd v0.0.0-20160723061019-3f5f724cb5b1</span><br><span class="line">gotest.tools v2.2.0+incompatible // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Bash</p><p>依赖规则由两个部分组成，前面一部分是包路径，后面一部分表示的是版本号。 你会发现有两种版本号，一种是我们很熟悉的 git 标签，比如 <code>v0.0.2</code>，另一种就比较复杂一些，它是：<strong>版本号 + 时间戳 +hash</strong> 比如：<code>v0.0.0-20190212224330-8d79a5489543</code>，它其实是精准的对应着一个 <code>git log</code> 记录，后面的哈希是去提交哈希的前 12 位。</p><p>比如我当前的提交记录是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> </span></span><br><span class="line">commit 4c55783279db32be4f02e193713d5a862b96db85 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: yangjian &lt;yangjian102621@gmail.com&gt;</span><br><span class="line">Date:   Mon Jun 10 18:34:14 2019 +0800</span><br></pre></td></tr></table></figure><p>Bash</p><p>则我的最新版本号应该为 <code>v0.0.0-20190610103414-4c55783279db</code></p><h1 id="4-引入本地依赖包"><a href="#4-引入本地依赖包" class="headerlink" title="4. 引入本地依赖包"></a>4. 引入本地依赖包</h1><p>前面铺垫了这么多，接下来回到我们的主题，我该怎样使用我们自己开发的工具包呢？ 假设我们有一个新的项目 <code>testmod-demo</code>，现在想要在新的项目中使用 testmod 中的工具包，那么首先我们需要使用 <code>go mod</code> 初始化该项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd testmod-demo</span><br><span class="line">go mod init gitee.com/rockyang/testmod-demo</span><br></pre></td></tr></table></figure><p>Bash</p><p>初始化之后会在当前项目根目录生成一个 <code>go.mod</code>，接下来我们有两种方式去引入 testmod 包，一种是直接修改 <code>go.mod</code> 文件，在 require 配置中添加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitee.com/rockyang/testmod v0.0.0-20190610103414-4c55783279db</span><br></pre></td></tr></table></figure><p>Bash</p><p>或者使用 <code>go mod edit</code> 命令修改依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require="gitee.com/rockyang/testmod@v0.0.0-20190610103414-4c55783279db"</span><br><span class="line">go mod tidy # 整理依赖包</span><br></pre></td></tr></table></figure><p>Bash</p><h1 id="5-使用-replace-将远程包替换为本地包服务"><a href="#5-使用-replace-将远程包替换为本地包服务" class="headerlink" title="5. 使用 replace 将远程包替换为本地包服务"></a>5. 使用 replace 将远程包替换为本地包服务</h1><p>这时如果你执行 <code>go build</code> 的时候会报错，提示找不到 <code>gitee.com/rockyang/testmod</code>，是因为你没有把仓库推送到远程，所以无法下载。 go module 提供了另外一个方案, 使用 replace, 编辑 go.mod 文件，在最后面添加：<code>replace gitee.com/rockyang/testmod =&gt; /gopath/src/gitee.com/rockyang/testmod</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module gitee.com/rockyang/testmod-demo</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gin-gonic/gin v1.3.0</span><br><span class="line">gitee.com/rockyang/testmod@v0.0.0-20190610103414-4c55783279db</span><br><span class="line">    golang.org/x/net v0.0.0-20190320064053-1272bf9dcd53 // indirect</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace gitee.com/rockyang/testmod =&gt; /gopath/src/gitee.com/rockyang/testmod</span><br></pre></td></tr></table></figure><p>Bash</p><blockquote><p>这里的 /gopath/src/gitee.com/rockyang/testmod 是本地的包路径</p></blockquote><p>然后再执行 <code>go build</code> 你会看到你想要的结果。</p><hr><p>以上为原作者原文，转载这篇文章的原因是因为Golang1.13发布了，看到了其中一个新特新<a href="https://tip.golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules" target="_blank" rel="noopener"><code>GOPRIVATE</code></a> 可以搭配 <a href="https://tip.golang.org/cmd/go/#hdr-Module_downloading_and_verification" target="_blank" rel="noopener"><code>GOPROXY</code></a> 对私有模块更细粒度的控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章转载至 &lt;a href=&quot;http://www.r9it.com/20190611/go-mod-use-dev-package.html#1-启用-go-module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小一辈无产阶级码农&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近由于项目要求，需要对 &lt;code&gt;IPFS&lt;/code&gt; 源码进行修改，由于自己在此之前没有接触过 Go 语言，在使用 &lt;code&gt;go mod&lt;/code&gt; 导入本地自己开发的工具包的时候折腾了好久才搞定。 记录一下，以备后期查阅。 Go 语言的 Module 新特性是在 go1.11 的发布之后才支持的，这是 Go 语言新的一套依赖管理系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang随记" scheme="https://jingzhouzhao.github.io/categories/Golang%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Golang" scheme="https://jingzhouzhao.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Python实现图像文字识别</title>
    <link href="https://jingzhouzhao.github.io/archives/99680cca.html"/>
    <id>https://jingzhouzhao.github.io/archives/99680cca.html</id>
    <published>2019-09-03T08:46:36.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>使用的实际是tesseract这个OCR引擎。如果识别的有中文，需要添加中文的<a href="https://github.com/tesseract-ocr/tessdata/raw/4.00/chi_sim.traineddata" target="_blank" rel="noopener">chi_sim.traineddata</a>。</p><p>我这里使用的是windows，下载是<a href="http://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe" target="_blank" rel="noopener">Windows Installer made with MinGW-w64</a>，在安装过程中注意有个选项，展开可以看到各种语言的数据，勾上chi_sim.traineddata即可。</p><a id="more"></a><p>我这里使用的是Python3.7，首先安装必备的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pillow</span><br></pre></td></tr></table></figure><p>我使用的Pycharm，直接Alt+Enter导入。</p><p>完整的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pytesseract</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image &#x3D; Image.open(&quot;..&#x2F;pic&#x2F;c.png&quot;)</span><br><span class="line">code &#x3D; pytesseract.image_to_string(image,lang&#x3D;&quot;chi_sim&quot;,config&#x3D;&quot;-psm 6&quot;)</span><br><span class="line">print(code)</span><br></pre></td></tr></table></figure><p>直接运行可能会报错，会提示<code>tesseract</code>识别不了，我看到其他人都是直接修改pytesseract源文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract_cmd &#x3D; &#39;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&#39;</span><br></pre></td></tr></table></figure><p>我这里的做法是将<code>C:\Program Files (x86)\Tesseract-OCR\</code>添加到环境变量PATH中。</p><p>有可能不会生效，需要重启Pycharm。</p><p>OCR识别不是100%准确，我这里测试的结果是，可能会多或者少一些字符。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/github_33304260/article/details/79155154" target="_blank" rel="noopener">https://blog.csdn.net/github_33304260/article/details/79155154</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用的实际是tesseract这个OCR引擎。如果识别的有中文，需要添加中文的&lt;a href=&quot;https://github.com/tesseract-ocr/tessdata/raw/4.00/chi_sim.traineddata&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chi_sim.traineddata&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我这里使用的是windows，下载是&lt;a href=&quot;http://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows Installer made with MinGW-w64&lt;/a&gt;，在安装过程中注意有个选项，展开可以看到各种语言的数据，勾上chi_sim.traineddata即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Python随记" scheme="https://jingzhouzhao.github.io/categories/Python%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://jingzhouzhao.github.io/tags/Python/"/>
    
      <category term="OCR" scheme="https://jingzhouzhao.github.io/tags/OCR/"/>
    
  </entry>
  
</feed>
