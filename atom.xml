<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵烧鸡腿饭的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingzhouzhao.github.io/"/>
  <updated>2021-12-16T06:26:15.084Z</updated>
  <id>https://jingzhouzhao.github.io/</id>
  
  <author>
    <name>赵烧鸡腿饭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Paxos那些点</title>
    <link href="https://jingzhouzhao.github.io/archives/e00e37d3.html"/>
    <id>https://jingzhouzhao.github.io/archives/e00e37d3.html</id>
    <published>2021-12-16T06:07:48.000Z</published>
    <updated>2021-12-16T06:26:15.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>世界上只有一种共识协议，就是 Paxos，其他所有共识算法都是 Paxos 的退化版本。</p></blockquote><p>Paxos分为Basic Paxos、Multi Paxos、和其它演进版本。</p><h1 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h1><p><strong>前提：Basic Paxos 只能对单个值形成决议。</strong></p><p>Paxos 算法将分布式系统中的节点分为三类：</p><ul><li><strong>提案节点</strong>：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称之为<strong>提案</strong>（Proposal），值一旦设置成功，就是不会丢失也不可变的。请注意，Paxos 是典型的基于操作转移模型而非状态转移模型来设计的算法，这里的“设置值”不要类比成程序中变量赋值操作，应该类比成日志记录操作，在后面介绍的 Raft 算法中就直接把“提案”叫作“日志”了。</li><li><strong>决策节点</strong>：称为 Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被<strong>批准</strong>（Accept），提案被批准即意味着该值不能再被更改，也不会丢失，且最终所有节点都会接受该它。</li><li><strong>记录节点</strong>：被称为 Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。</li></ul><a id="more"></a><p>Paxos 算法包括两个阶段，其中，<strong>第一阶段“准备”（Prepare）</strong>就相当于上面抢占锁的过程（不是基于互斥量）。如果某个提案节点准备发起提案，必须先向所有的决策节点广播一个许可申请（称为 Prepare 请求）。提案节点的 Prepare 请求中会附带一个全局唯一的数字 n 作为提案 ID，决策节点收到后，将会给予<strong>提案节点两个承诺与一个应答</strong>。</p><p>两个承诺是指：</p><ul><li>承诺不会再接受提案 ID 小于或等于 n 的 Prepare 请求。</li><li>承诺不会再接受提案 ID 小于 n 的 Accept 请求。</li></ul><p>一个应答是指：</p><ul><li>不违背以前作出的承诺的前提下，回复已经批准过的提案中 ID 最大的那个提案所设定的值和提案 ID，如果该值从来没有被任何提案设定过，则返回空值。如果违反此前做出的承诺，即收到的提案 ID 并不是决策节点收到过的最大的，那允许直接对此 Prepare 请求不予理会。</li></ul><p>当提案节点收到了多数派决策节点的应答（称为 Promise 应答）后，可以开始<strong>第二阶段“批准”（Accept）</strong>过程，这时有如下两种可能的结果：</p><ul><li>如果提案节点发现所有响应的决策节点此前都没有批准过该值（即为空），那说明它是第一个设置值的节点，可以随意地决定要设定的值，将自己选定的值与提案 ID，构成一个二元组“(id, value)”，再次广播给全部的决策节点（称为 Accept 请求）。</li><li>如果提案节点发现响应的决策节点中，已经有至少一个节点的应答中包含有值了，那它就不能够随意取值了，必须无条件地从应答中找出提案 ID 最大的那个值并接受，构成一个二元组“(id, maxAcceptValue)”，再次广播给全部的决策节点（称为 Accept 请求）。</li></ul><p>当每一个决策节点收到 Accept 请求时，都会在不违背以前作出的承诺的前提下，接收并持久化对当前提案 ID 和提案附带的值。如果违反此前做出的承诺，即收到的提案 ID 并不是决策节点收到过的最大的，那允许直接对此 Accept 请求不予理会。</p><p>关于<strong>活锁</strong>：</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/jc4j75h9ha-1639635295709.png" alt>两个提案节点互不相让地争相提出自己的提案，抢占同一个值的修改权限，导致整个系统在持续性地“反复横跳”，外部看起来就像被锁住了一样</p><h1 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h1><p>Multi Paxos 对 Basic Paxos 的核心改进是<strong>增加了“选主”的过程</strong>，提案节点会通过定时轮询（心跳），确定当前网络中的所有节点里是否存在有一个主提案节点，一旦没有发现主节点存在，节点就会在心跳超时后<strong>使用 Basic Paxos 中定义的准备、批准的两轮网络交互过程，向所有其他节点广播自己希望竞选主节点的请求</strong>，希望整个分布式系统对“由我作为主节点”这件事情协商达成一致共识，如果得到了决策节点中多数派的批准，便宣告竞选成功。当选主完成之后，除非主节点失联之后发起重新竞选，否则从此往后，就只有主节点本身才能够提出提案。此时，无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是<strong>经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程。也可以通俗理解为选主过后，就不会再有其他节点与它竞争，相当于是处于无并发的环境当中进行的有序操作，所以此时系统中要对某个值达成一致，只需要进行一次批准的交互即可</strong></p><p>可能有人注意到这时候的二元组(id, value)已经变成了三元组(id, i, value)，这是因为需要给<strong>主节点增加一个“任期编号”，这个编号必须是严格单调递增的，以应付主节点陷入网络分区后重新恢复，但另外一部分节点仍然有多数派，且已经完成了重新选主的情况，此时必须以任期编号大的主节点为准</strong>。当节点有了选主机制的支持，在整体来看，就可以进一步简化节点角色，不去区分提案、决策和记录节点了，统统以“节点”来代替，节点只有主（Leader）和从（Follower）的区别</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="http://icyfenix.cn/distribution/consensus/paxos.html" target="_blank" rel="noopener">http://icyfenix.cn/distribution/consensus/paxos.html</a></p><p><a href="http://icyfenix.cn/distribution/consensus/raft.html" target="_blank" rel="noopener">http://icyfenix.cn/distribution/consensus/raft.html</a></p><p><a href="https://acehi.github.io/thesecretlivesofdata-cn/raft/" target="_blank" rel="noopener">https://acehi.github.io/thesecretlivesofdata-cn/raft/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世界上只有一种共识协议，就是 Paxos，其他所有共识算法都是 Paxos 的退化版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Paxos分为Basic Paxos、Multi Paxos、和其它演进版本。&lt;/p&gt;
&lt;h1 id=&quot;Basic-Paxos&quot;&gt;&lt;a href=&quot;#Basic-Paxos&quot; class=&quot;headerlink&quot; title=&quot;Basic Paxos&quot;&gt;&lt;/a&gt;Basic Paxos&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前提：Basic Paxos 只能对单个值形成决议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Paxos 算法将分布式系统中的节点分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提案节点&lt;/strong&gt;：称为 Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称之为&lt;strong&gt;提案&lt;/strong&gt;（Proposal），值一旦设置成功，就是不会丢失也不可变的。请注意，Paxos 是典型的基于操作转移模型而非状态转移模型来设计的算法，这里的“设置值”不要类比成程序中变量赋值操作，应该类比成日志记录操作，在后面介绍的 Raft 算法中就直接把“提案”叫作“日志”了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;决策节点&lt;/strong&gt;：称为 Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被&lt;strong&gt;批准&lt;/strong&gt;（Accept），提案被批准即意味着该值不能再被更改，也不会丢失，且最终所有节点都会接受该它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录节点&lt;/strong&gt;：被称为 Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Paxos" scheme="https://jingzhouzhao.github.io/tags/Paxos/"/>
    
      <category term="一致性" scheme="https://jingzhouzhao.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>博客用的图床挂了</title>
    <link href="https://jingzhouzhao.github.io/archives/2baffaa5.html"/>
    <id>https://jingzhouzhao.github.io/archives/2baffaa5.html</id>
    <published>2021-12-01T09:35:02.000Z</published>
    <updated>2021-12-02T01:31:53.021Z</updated>
    
    <content type="html"><![CDATA[<p>之前不想把博客里面的图片也一同上传，用了utools里面一个默认的免费图床，结果今天发现好像图床挂掉了。之前写的博客里面的图片全挂了。。。果断换了gitee做新的图床。</p><p><img src="https://gitee.com/zhaojingzhou/filebed/raw/master/l19rbp0xbd-1638351541087.png" alt></p><p>这不会再挂了吧。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前不想把博客里面的图片也一同上传，用了utools里面一个默认的免费图床，结果今天发现好像图床挂掉了。之前写的博客里面的图片全挂了。。。果断换了gitee做新的图床。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/zhaojingzhou/file
      
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="图床" scheme="https://jingzhouzhao.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="博客" scheme="https://jingzhouzhao.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Mapper 源码分析</title>
    <link href="https://jingzhouzhao.github.io/archives/fb5cf917.html"/>
    <id>https://jingzhouzhao.github.io/archives/fb5cf917.html</id>
    <published>2021-09-22T06:26:02.000Z</published>
    <updated>2021-09-27T09:23:39.240Z</updated>
    
    <content type="html"><![CDATA[<p>天天都在用的Mybatis，为啥调用一个Mapper接口就能执行SQL，你有没有想过这个问题？</p><p>这一切都得从 <code>@MapperScan</code> 这个注解开始说起。打开这个注解定义可以看到：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;MapperScannerRegistrar.class&#125;)</span><br></pre></td></tr></table></figure><p>上面的元注解中重点关注<code>@Import(MapperScannerRegistrar.class)</code>，这是Spring的一个注解，允许导入@Configuration类、 ImportSelector和ImportBeanDefinitionRegistrar实现。很明显<code>MapperScannerRegistrar.class</code> 应该是<code>ImportBeanDefinitionRegistrar</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">"value"</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String pkg : annoAttrs.getStringArray(<span class="string">"basePackages"</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>)) &#123;</span><br><span class="line">      basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面代码在做一件事，就是初始化<code>ClassPathMapperScanner</code>，最后调用了<code>doScan</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(<span class="string">"No MyBatis mapper was found in '"</span> + Arrays.toString(basePackages) + <span class="string">"' package. Please check your configuration."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先调用了父类的doScan，里面的主要逻辑是查找指定的basePackages下的所有Components，即声明了<code>@Component</code>以及将<code>@Component</code>作为元注解的注解，例如<code>@Repository</code>，<br>感兴趣的可以看看：</p><ul><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents</li><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent(org.springframework.core.type.classreading.MetadataReader)</li><li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters</li><li>org.springframework.core.type.filter.AnnotationTypeFilter#hasAnnotation</li><li>org.springframework.core.annotation.AnnotationUtils#getAnnotation(java.lang.reflect.AnnotatedElement, java.lang.Class<A>)</A></li></ul><p>接下来调用了<code>processBeanDefinitions</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName() </span><br><span class="line">          + <span class="string">"' and '"</span> + definition.getBeanClassName() + <span class="string">"' mapperInterface"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点看看这两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); </span><br><span class="line">definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br></pre></td></tr></table></figure><p>似乎已经可以看出点蛛丝马迹，这里将Mapper的BeanDefinition的BeanClass替换为了<code>this.mapperFactoryBean.getClass()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MapperFactoryBean&lt;?&gt; mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p>并且将原本的BeanClass添加为了构造函数参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br></pre></td></tr></table></figure><p>熟悉Spring的应该都知道，Spring加载完BeanDefinition后会通过BeanClass来去实例化Bean，这里的BeanClass被替换为了一个FactoryBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addToConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intentionally empty </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">    notNull(<span class="keyword">this</span>.mapperInterface, <span class="string">"Property 'mapperInterface' is required"</span>);</span><br><span class="line"></span><br><span class="line">    Configuration configuration = getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        configuration.addMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error while adding the mapper '"</span> + <span class="keyword">this</span>.mapperInterface + <span class="string">"' to configuration."</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------- mutators --------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the mapper interface of the MyBatis mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperInterface class of the interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperInterface</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the mapper interface of the MyBatis mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> class of the interface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If addToConfig is false the mapper will not be added to MyBatis. This means</span></span><br><span class="line"><span class="comment">   * it must have been included in mybatis-config.xml.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * If it is true, the mapper will be added to MyBatis in the case it is not already</span></span><br><span class="line"><span class="comment">   * registered.</span></span><br><span class="line"><span class="comment">   * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">   * By default addToCofig is true.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> addToConfig</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddToConfig</span><span class="params">(<span class="keyword">boolean</span> addToConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addToConfig = addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the flag for addition into MyBatis config.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true if the mapper will be added to MyBatis in the case it is not already</span></span><br><span class="line"><span class="comment">   * registered.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddToConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到之前那个被注册的构造函数参数应该就是在这被使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 关于这个Bean构造函数的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireConstructor</span><br><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，Spring通过构造函数创建了一个 MapperFactoryBean 对象。接下来Spring去初始化这个Bean，Spring对FactoryBean有特殊处理，实际会调用getObject方法返回具体的Bean。<br>感兴趣的可以看：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.FactoryBeanRegistrySupport#doGetObjectFromFactoryBean</span><br></pre></td></tr></table></figure><p>这下又回到了MapperFactoryBean中，来看看getObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用了父类getSqlSession()方法获得SqlSession，然后调用getMapper，传入了当前实际的Mapper。通过：</p><ul><li>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration)</li><li>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</li></ul><p>可以知道SqlSession实际的类型应该是<code>DefaultSqlSession</code>，看看getMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又调用了<code>configuration</code>的getMapper，configuration初始化可以看看<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>，<br>我们写的SQL就是在这个里面被解析的。到这里已经基本很清晰了。接着看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//configuration中的getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MapperRegistry中的getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是 <code>MapperProxyFactory</code>了，这个是在 <code>org.apache.ibatis.binding.MapperRegistry#addMapper</code>  时会为每个Mapper绑定一个。<br>看newInstance：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就是说最终Mapper注册到BeanFactory中的是一个代理类<code>MapperProxy</code>，我们知道被代理的方法最终都会被转发到代理类的<code>invoke</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">       <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">       <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">   <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果不是Object类的方法，也不是Mapper接口的default（默认）方法，那么调用的是<code>mapperMethod.execute(sqlSession, args)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到这就差不多了吧？后面已经没啥好说了，基本就是通过statement name找到MappedStatement然后去执行sql了。</p><p>另外一个小知识，Mybatis是怎么在插入之后返回自增主键的？答案就在：</p><ul><li>org.apache.ibatis.executor.statement.PreparedStatementHandler#update</li><li>org.apache.ibatis.executor.keygen.KeyGenerator#processAfter</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>Spring代码实在太难看了，一环套一环，各种递归，必须debug才能看清。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天天都在用的Mybatis，为啥调用一个Mapper接口就能执行SQL，你有没有想过这个问题？&lt;/p&gt;
&lt;p&gt;这一切都得从 &lt;code&gt;@MapperScan&lt;/code&gt; 这个注解开始说起。打开这个注解定义可以看到：&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>被Chrome一个bug坑了</title>
    <link href="https://jingzhouzhao.github.io/archives/6e43fa1b.html"/>
    <id>https://jingzhouzhao.github.io/archives/6e43fa1b.html</id>
    <published>2021-09-03T08:58:50.000Z</published>
    <updated>2021-09-27T09:24:40.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://files.catbox.moe/xbwdlv.png" alt></p><p>相信Chrome浏览器开发者工具中的Preview你不陌生，但是就这玩意有一个bug。</p><p>事情是这样的，前端跟我说你接口有bug，返回的数据不正确。听到bug，我反手就是一个你会不会用。</p><a id="more"></a><p>他发来了一个截图：</p><p><img src="https://files.catbox.moe/b7x3tw.png" alt></p><p>我给他返回的json中有一个<code>max</code>字段，值是<code>100000000000000</code> ,正确的应该是<code>99999999999999.99999999999999999999</code>,你先别管为什么是这么个值。</p><p>好了，他拿出证据了，我开始怀疑真的是哪里写的有问题了，一顿查找，发现TMD哪里都没有问题啊，怎么可能，怎么会呢？</p><p>中午的饭都不香了。</p><p>我开始怀疑是网关的问题，网关大佬说没问题。。。。。</p><p>于是拿着请求地址，curl了一下，<code>max:99999999999999.99999999999999999999</code>。卧槽。。。又对了？</p><p>于是我开始怀疑最不可能出问题的浏览器，直到我点开了<code>Response</code> :</p><p><img src="https://files.catbox.moe/kygqzl.png" alt></p><p>。。。。。。</p><p>反手就是给提了一个bug：</p><p><img src="https://files.catbox.moe/l53ij6.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://files.catbox.moe/xbwdlv.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;相信Chrome浏览器开发者工具中的Preview你不陌生，但是就这玩意有一个bug。&lt;/p&gt;
&lt;p&gt;事情是这样的，前端跟我说你接口有bug，返回的数据不正确。听到bug，我反手就是一个你会不会用。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="Chrome" scheme="https://jingzhouzhao.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Lambda应用与浅析</title>
    <link href="https://jingzhouzhao.github.io/archives/d53a1750.html"/>
    <id>https://jingzhouzhao.github.io/archives/d53a1750.html</id>
    <published>2021-08-02T12:47:02.000Z</published>
    <updated>2021-12-01T09:19:35.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在Java8之前创建一个线程的写法（之一）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;hello inner class!&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>通过查看编译后的生成的Class文件，可以得知new Runnable这块会生成一个匿名类：</p><p><img src="https://files.catbox.moe/e1vlbc.png" alt></p><p>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final class LambdaTest$1 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    LambdaTest$1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;hello inner class!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java8开始一切都开始变得不同，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello inner class!&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>()-&gt;System.out.println(&quot;hello inner class!&quot;)</code>就是今天的主角<strong><em>lambda表达式</em></strong>!</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Lambda表达式，是一种匿名函数，一开始只有函数式编程语言中有此功能，但是现在已经有越来越多的命令式编程语言中也支持了Lambda表达式。</p><blockquote><p>Lambda表达式不是一个新鲜事，最早支持Lambda表达式的是1958发布的LISP语言。在Java中也存在了快7-8年时间（2014年发布的Java8开始支持），目前Java已经都发布16。</p></blockquote><p>Lambda表达式简化匿名内部类的书写，但Lambda表达式并不能取代所有的匿名内部类，只能用来取代<strong>函数接口（Functional Interface）</strong>的简写。</p><p>说到函数接口，那么来看下什么是函数接口，看看最开始的例子里出现的<strong><em>Runnable</em></strong>  ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看另外一个<strong>Comparable</strong> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public int compareTo(T o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现了什么？只有一个[抽象]方法的接口即是函数接口。</p><p><code>@FunctionalInterface</code> 并不是必须的，加上此注解可以让编译器帮你check当前定义的是不是正确的函数接口：</p><p><img src="/Users/zhaojingzhou/Library/Application%20Support/typora-user-images/image-20211201171908933.png" alt></p><p>Java8 引入Lambda表达式的同时也定义了很多新的函数接口，适用于大部分场景：</p><p><img src="https://files.catbox.moe/qptsmq.png" alt></p><p>也就是说Java8中的Lambda表达式不可以随意乱写，必须有与其对应的函数接口定义，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a, b) -&gt; a + b;</span><br></pre></td></tr></table></figure><p>如果在JDK中找不到对应的函数接口，我们可以自定义一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface TwoParamsOneResultFunction &#123;</span><br><span class="line"></span><br><span class="line">    Integer get(Integer p1, Integer p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>下面来通过一个实例看看Lambda表达式的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private static boolean sync2Es(List&lt;Long&gt; result, EsIndexEnum esIndexEnum, boolean isAsync) &#123;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;同步&#123;&#125;至ES，idList:&#123;&#125;,isAsync:&#123;&#125;&quot;, JSON.toJSONString(esIndexEnum), JSON.toJSONString(result), isAsync);</span><br><span class="line"></span><br><span class="line">    if (esIndexEnum &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CollectionUtils.isEmpty(result)) &#123;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;es最多支持一次同步3000条，所以需要拆分</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Long&gt;&gt; partition &#x3D; Lists.partition(StreamUtils.safeList(result), AssetsConstant.MAX_BATCH_SYNC_SIZE);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;es支持同步和异步，按需选择</span><br><span class="line"></span><br><span class="line">    EsSyncProcessorInstance instance &#x3D; EsSyncProcessorFactory.getInstance(esIndexEnum.getIndexClass());</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; esFunction &#x3D; getEsSyncFunction(isAsync);</span><br><span class="line"></span><br><span class="line">    boolean esResult &#x3D; StreamUtils.allMatch(StreamUtils.listToList(partition, ids -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        EsResult&lt;BulkMessage&gt; bulkMessageEsResult &#x3D; esFunction.apply(instance, ids);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;es可能失败，重试一次，如果还是不行那估计就是大问题了。</span><br><span class="line"></span><br><span class="line">        if (!bulkMessageEsResult.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(&quot;同步ES失败:&#123;&#125;,重试一次&quot;, JSON.toJSONString(bulkMessageEsResult));</span><br><span class="line"></span><br><span class="line">            bulkMessageEsResult &#x3D; esFunction.apply(instance, StreamUtils.listToList(StreamUtils.safeGetField(bulkMessageEsResult.getValue(), BulkMessage::getFailIds), Long::valueOf));</span><br><span class="line"></span><br><span class="line">            if (!bulkMessageEsResult.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                log.error(&quot;同步ES重试再次失败:&#123;&#125;&quot;, JSON.toJSONString(bulkMessageEsResult));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return bulkMessageEsResult.isSuccess();</span><br><span class="line"></span><br><span class="line">    &#125;), Boolean::booleanValue);</span><br><span class="line"></span><br><span class="line">    if (!esResult) &#123;</span><br><span class="line"></span><br><span class="line">        log.error(&quot;同步到ES存在失败:&#123;&#125;&quot;, JSON.toJSONString(result));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return esResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段代码主要是在做同步数据给ES的逻辑，由于ES提供了多种同步方式，不想将细节暴露给上层，所以做了一些封装。</p><p>先看看这一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; esFunction &#x3D; getEsSyncFunction(isAsync);</span><br></pre></td></tr></table></figure><p>调用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static BiFunction&lt;EsSyncProcessorInstance, List&lt;Long&gt;, EsResult&lt;BulkMessage&gt;&gt; getEsSyncFunction(boolean isAsync) &#123;</span><br><span class="line"></span><br><span class="line">    return isAsync ? EsSyncProcessorInstance::syncByPrimaryKey : EsSyncProcessorInstance::syncByPrimaryKeyImmediate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中可以看到类似<code>EsSyncProcessorInstance::syncByPrimaryKey</code>这种写法，这个叫方法引用，可以理解为是一种特殊的lambda表达式（语法糖），相当于给一段函数取了一个名字，然后直接引用，看看syncByPrimaryKey：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public EsResult&lt;BulkMessage&gt; syncByPrimaryKey(List&lt;Long&gt; indexPrimaryKeyList) &#123;</span><br><span class="line"></span><br><span class="line">    String method &#x3D; &quot;EsSyncProcessorInstance#syncByPrimaryKey&quot;;</span><br><span class="line"></span><br><span class="line">    if (indexPrimaryKeyList !&#x3D; null &amp;&amp; indexPrimaryKeyList.size() &gt; 3000) &#123;</span><br><span class="line"></span><br><span class="line">        log.warn(&quot;&#123;&#125; allowable size exceeded, size&#x3D;&#123;&#125;, max&#x3D;&#123;&#125;&quot;, new Object[]&#123;method, indexPrimaryKeyList.size(), 3000&#125;);</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        EsSyncLoopQuery query &#x3D; this.newInstanceQuery();</span><br><span class="line"></span><br><span class="line">        query.setIdList(indexPrimaryKeyList);</span><br><span class="line"></span><br><span class="line">        return this.synchronizeToEs(query, this.defaultConfig());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个List<Long> 参数，一个EsResult<BulkMessage>返回值，那为什么适配的函数接口是BiFunction？看看BiFunction：</BulkMessage></Long></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"></span><br><span class="line">public interface BiFunction&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里需要两个参数</span><br><span class="line"></span><br><span class="line">    R apply(T t, U u);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于syncByPrimaryKey是一个实例方法，所以还需要一个<strong>实例对象</strong>才能调用，所以<code>EsSyncProcessorInstance::syncByPrimaryKey</code> 相当于(<code>EsSyncProcessorInstance instance,List&lt;Long&gt; ids)-&gt;{...}</code></p><p>再一次验证，lambda表达式不能随意乱写，必须有对应的函数接口对应。</p><p>接下来再来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StreamUtils.listToList(partition, ids -&gt; &#123;</span><br></pre></td></tr></table></figure><p>这是对Java8 Stream+Lambda的一层封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, R&gt; List&lt;R&gt; listToList(List&lt;T&gt; list, Function&lt;T, R&gt; function) &#123;</span><br><span class="line"></span><br><span class="line">        return safeList(list).stream().map(function).filter(Objects::nonNull).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到stream().map需要一个function用来转换数据，而其他的基本都是固定写法，这体现了Lambda的另外一个好处：抽象行为。</p><p><img src="https://files.catbox.moe/akijpg.png" alt></p><p>还有很多用法不一一介绍了。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这么🐂🍺的Lambda表达式Java底层是怎么实现的呢？首先可以确定的是，不是匿名内部类，还是最开始的例子，我们改成lambda表达式后编译看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;System.out.println(&quot;hello lambda&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/ular40.png" alt></p><p>可以看到并没有匿名内部类生成，我们查看下LambdaTest.class字节码(<em>javap -c -p -v LambdaTest.class</em>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;Users&#x2F;zhaojingzhou&#x2F;workspace&#x2F;larry&#x2F;lambda&#x2F;src&#x2F;LambdaTest.class</span><br><span class="line"></span><br><span class="line">  Last modified 2021-8-2; size 1047 bytes</span><br><span class="line"></span><br><span class="line">  MD5 checksum 191cb67c3e5a457eb20b4c8a47f5a5d2</span><br><span class="line"></span><br><span class="line">  Compiled from &quot;LambdaTest.java&quot;</span><br><span class="line"></span><br><span class="line">public class LambdaTest</span><br><span class="line"></span><br><span class="line">  minor version: 0</span><br><span class="line"></span><br><span class="line">  major version: 52</span><br><span class="line"></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line"></span><br><span class="line">   #1 &#x3D; Methodref          #9.#19         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">   #2 &#x3D; Class              #20            &#x2F;&#x2F; java&#x2F;lang&#x2F;Thread</span><br><span class="line"></span><br><span class="line">   #3 &#x3D; InvokeDynamic      #0:#25         &#x2F;&#x2F; #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">   #4 &#x3D; Methodref          #2.#26         &#x2F;&#x2F; java&#x2F;lang&#x2F;Thread.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">   #5 &#x3D; Fieldref           #27.#28        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">   #6 &#x3D; String             #29            &#x2F;&#x2F; hello inner class!</span><br><span class="line"></span><br><span class="line">   #7 &#x3D; Methodref          #30.#31        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">   #8 &#x3D; Class              #32            &#x2F;&#x2F; LambdaTest</span><br><span class="line"></span><br><span class="line">   #9 &#x3D; Class              #33            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line"></span><br><span class="line">  #10 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line"></span><br><span class="line">  #11 &#x3D; Utf8               ()V</span><br><span class="line"></span><br><span class="line">  #12 &#x3D; Utf8               Code</span><br><span class="line"></span><br><span class="line">  #13 &#x3D; Utf8               LineNumberTable</span><br><span class="line"></span><br><span class="line">  #14 &#x3D; Utf8               main</span><br><span class="line"></span><br><span class="line">  #15 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">  #16 &#x3D; Utf8               lambda$main$0</span><br><span class="line"></span><br><span class="line">  #17 &#x3D; Utf8               SourceFile</span><br><span class="line"></span><br><span class="line">  #18 &#x3D; Utf8               LambdaTest.java</span><br><span class="line"></span><br><span class="line">  #19 &#x3D; NameAndType        #10:#11        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">  #20 &#x3D; Utf8               java&#x2F;lang&#x2F;Thread</span><br><span class="line"></span><br><span class="line">  #21 &#x3D; Utf8               BootstrapMethods</span><br><span class="line"></span><br><span class="line">  #22 &#x3D; MethodHandle       #6:#34         &#x2F;&#x2F; invokestatic java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #23 &#x3D; MethodType         #11            &#x2F;&#x2F;  ()V</span><br><span class="line"></span><br><span class="line">  #24 &#x3D; MethodHandle       #6:#35         &#x2F;&#x2F; invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #25 &#x3D; NameAndType        #36:#37        &#x2F;&#x2F; run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">  #26 &#x3D; NameAndType        #10:#38        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">  #27 &#x3D; Class              #39            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line"></span><br><span class="line">  #28 &#x3D; NameAndType        #40:#41        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">  #29 &#x3D; Utf8               hello inner class!</span><br><span class="line"></span><br><span class="line">  #30 &#x3D; Class              #42            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line"></span><br><span class="line">  #31 &#x3D; NameAndType        #43:#44        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">  #32 &#x3D; Utf8               LambdaTest</span><br><span class="line"></span><br><span class="line">  #33 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line"></span><br><span class="line">  #34 &#x3D; Methodref          #45.#46        &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #35 &#x3D; Methodref          #8.#47         &#x2F;&#x2F; LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #36 &#x3D; Utf8               run</span><br><span class="line"></span><br><span class="line">  #37 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">  #38 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">  #39 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line"></span><br><span class="line">  #40 &#x3D; Utf8               out</span><br><span class="line"></span><br><span class="line">  #41 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">  #42 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line"></span><br><span class="line">  #43 &#x3D; Utf8               println</span><br><span class="line"></span><br><span class="line">  #44 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">  #45 &#x3D; Class              #48            &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory</span><br><span class="line"></span><br><span class="line">  #46 &#x3D; NameAndType        #49:#53        &#x2F;&#x2F; metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #47 &#x3D; NameAndType        #16:#11        &#x2F;&#x2F; lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">  #48 &#x3D; Utf8               java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory</span><br><span class="line"></span><br><span class="line">  #49 &#x3D; Utf8               metafactory</span><br><span class="line"></span><br><span class="line">  #50 &#x3D; Class              #55            &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup</span><br><span class="line"></span><br><span class="line">  #51 &#x3D; Utf8               Lookup</span><br><span class="line"></span><br><span class="line">  #52 &#x3D; Utf8               InnerClasses</span><br><span class="line"></span><br><span class="line">  #53 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">  #54 &#x3D; Class              #56            &#x2F;&#x2F; java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles</span><br><span class="line"></span><br><span class="line">  #55 &#x3D; Utf8               java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup</span><br><span class="line"></span><br><span class="line">  #56 &#x3D; Utf8               java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  public LambdaTest();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line"></span><br><span class="line">         0: aload_0</span><br><span class="line"></span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line">         4: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 9: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line"></span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line"></span><br><span class="line">         0: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Thread</span><br><span class="line"></span><br><span class="line">         3: dup</span><br><span class="line"></span><br><span class="line">         4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br><span class="line"></span><br><span class="line">         9: invokespecial #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Thread.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;Runnable;)V</span><br><span class="line"></span><br><span class="line">        12: pop</span><br><span class="line"></span><br><span class="line">        13: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br><span class="line"></span><br><span class="line">        line 19: 13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;2, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line"></span><br><span class="line">         0: getstatic     #5                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">         3: ldc           #6                  &#x2F;&#x2F; String hello inner class!</span><br><span class="line"></span><br><span class="line">         5: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SourceFile: &quot;LambdaTest.java&quot;</span><br><span class="line"></span><br><span class="line">InnerClasses:</span><br><span class="line"></span><br><span class="line">     public static final #51&#x3D; #50 of #54; &#x2F;&#x2F;Lookup&#x3D;class java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup of class java&#x2F;lang&#x2F;invoke&#x2F;MethodHandles</span><br><span class="line"></span><br><span class="line">BootstrapMethods:</span><br><span class="line"></span><br><span class="line">  0: #22 invokestatic java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">    Method arguments:</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br><span class="line"></span><br><span class="line">      #24 invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br></pre></td></tr></table></figure><p>很多信息我们关注一下重点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4: invokedynamic #3,  0              &#x2F;&#x2F; InvokeDynamic #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br></pre></td></tr></table></figure><p>第85行可以看到原lambda表达式被编译成了<code>invokedynamic</code> 字节码，这个是Java中多个调用字节码之一，其它的分别是<code>invokestatic</code>、<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokeinterface</code>。也是Java1.0以后第一个被新增的调用字节码。</p><p>接下来看#3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#3 &#x3D; InvokeDynamic      #0:#25         &#x2F;&#x2F; #0:run:()Ljava&#x2F;lang&#x2F;Runnable;</span><br></pre></td></tr></table></figure><p>#0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line"></span><br><span class="line">  0: #22 invokestatic java&#x2F;lang&#x2F;invoke&#x2F;LambdaMetafactory.metafactory:(Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandles$Lookup;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodHandle;Ljava&#x2F;lang&#x2F;invoke&#x2F;MethodType;)Ljava&#x2F;lang&#x2F;invoke&#x2F;CallSite;</span><br><span class="line"></span><br><span class="line">    Method arguments:</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br><span class="line"></span><br><span class="line">      #24 invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line"></span><br><span class="line">      #23 ()V</span><br></pre></td></tr></table></figure><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21" target="_blank" rel="noopener">JVM规范</a>规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定<strong>有且仅有一个</strong>BootstrapMethods属性。BootstrapMethods属性是个变长的表。</p><p>其中根据相关信息会创建一个DynamicCallSite动态调用点，可以看到最终调用的方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">invokestatic LambdaTest.lambda$main$0:()V</span><br><span class="line">  private static void lambda$main$0();</span><br><span class="line"></span><br><span class="line">    descriptor: ()V</span><br><span class="line"></span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">    Code:</span><br><span class="line"></span><br><span class="line">      stack&#x3D;2, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line"></span><br><span class="line">         0: getstatic     #5                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"></span><br><span class="line">         3: ldc           #6                  &#x2F;&#x2F; String hello inner class!</span><br><span class="line"></span><br><span class="line">         5: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line"></span><br><span class="line">      LineNumberTable:</span><br><span class="line"></span><br><span class="line">        line 14: 0</span><br></pre></td></tr></table></figure><p>也就是说Java虽然不会对Lambda表达式生成匿名类，但是会生成匿名静态方法。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://segmentfault.com/a/1190000020607546" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020607546</a></p><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p><p><a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method" target="_blank" rel="noopener">https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;在Java8之前创建一个线程的写法（之一）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class LambdaTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        new Thread(new Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&amp;quot;hello inner class!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty中FastThreadLocal源码解析</title>
    <link href="https://jingzhouzhao.github.io/archives/4b47846d.html"/>
    <id>https://jingzhouzhao.github.io/archives/4b47846d.html</id>
    <published>2021-05-08T02:25:25.000Z</published>
    <updated>2021-09-27T09:23:45.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ThreadLocal</code>一个特殊变体，当从<code>FastThreadLocalThread</code>访问时，可获得更高的访问性能。<br>在内部， <code>FastThreadLocal</code>在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。<br>要利用此线程局部变量，您的线程必须是<code>FastThreadLocalThread</code>或其子类型。 由于这个原因，默认情况下， <code>DefaultThreadFactory</code>创建的所有线程均为<code>FastThreadLocalThread</code> 。<br>请注意，只有在扩展<code>FastThreadLocalThread</code>线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规<code>ThreadLocal</code> 。</p><p>上面这段描述来自<code>FastThreadLocal</code>源码中的文档，从中可以知道<code>FastThreadLocal</code>必须和<code>FastThreadLocalThread</code>或其子类型一起使用才可以达到Fast的效果。</p><a id="more"></a><h2 id="FastThreadLocalThread"><a href="#FastThreadLocalThread" class="headerlink" title="FastThreadLocalThread"></a>FastThreadLocalThread</h2><p>既然必须要和<code>FastThreadLocalThread</code>    一起使用，那就来看看<code>FastThreadLocalThread</code>到底有什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A special &#123;<span class="doctag">@link</span> Thread&#125; that provides fast access to &#123;<span class="doctag">@link</span> FastThreadLocal&#125; variables.</span></span><br><span class="line"><span class="comment"> * 一种特殊的&#123;<span class="doctag">@link</span> Thread&#125;，可以快速访问&#123;<span class="doctag">@link</span> FastThreadLocal&#125;变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// This will be set to true if we have a chance to wrap the Runnable.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> cleanupFastThreadLocals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocalThread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(FastThreadLocalRunnable.wrap(target));</span><br><span class="line">        cleanupFastThreadLocals = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>省略了一部分代码，可以看到<code>FastThreadLocalThread</code>继承自<code>Thread</code>，额外多了一个<code>InternalThreadLocalMap threadLocalMap</code>，从doc中可以看出这个变量就是关键。</p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal data structure that stores the thread-local variables for Netty and all &#123;<span class="doctag">@link</span> FastThreadLocal&#125;s.</span></span><br><span class="line"><span class="comment"> * Note that this class is for internal use only and is subject to change at any time.  Use &#123;<span class="doctag">@link</span> FastThreadLocal&#125;</span></span><br><span class="line"><span class="comment"> * unless you know what you are doing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Used by &#123;<span class="doctag">@link</span> FastThreadLocal&#125; */</span></span><br><span class="line">    Object[] indexedVariables;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> slowGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">        <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">        InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">            slowThreadLocalMap.set(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextIndex.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"too many thread-local indexed variables"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if a new thread-local variable has been created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        Object[] lookup = indexedVariables;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">            Object oldValue = lookup[index];</span><br><span class="line">            lookup[index] = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>InternalThreadLocalMap</code>继承自<code>UnpaddedInternalThreadLocalMap</code>，为了好看一点我把父类中的相关代码放到了一起，dubbo借鉴netty代码也是这么干的。</p><h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>最后看看<code>FastThreadLocal</code>是怎么把这几个核心类给串起来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> variablesToRemoveIndex = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value for the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">        <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = initialValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the initial value for this thread-local variable.</span></span><br><span class="line"><span class="comment">     * 这个方法一般会把覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> V <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.catbox.moe/nxk8yt.png" alt></p><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p><a href="https://github.com/apache/dubbo/pull/1745" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/1745</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;一个特殊变体，当从&lt;code&gt;FastThreadLocalThread&lt;/code&gt;访问时，可获得更高的访问性能。&lt;br&gt;在内部， &lt;code&gt;FastThreadLocal&lt;/code&gt;在数组中使用常量索引来查找变量，而不是使用哈希码和哈希表。 尽管看似非常微妙，但与使用哈希表相比，它在性能上却有一点优势，并且在经常访问时很有用。&lt;br&gt;要利用此线程局部变量，您的线程必须是&lt;code&gt;FastThreadLocalThread&lt;/code&gt;或其子类型。 由于这个原因，默认情况下， &lt;code&gt;DefaultThreadFactory&lt;/code&gt;创建的所有线程均为&lt;code&gt;FastThreadLocalThread&lt;/code&gt; 。&lt;br&gt;请注意，只有在扩展&lt;code&gt;FastThreadLocalThread&lt;/code&gt;线程上才可以使用快速路径，因为它需要一个特殊的字段来存储必要的状态。 任何其他类型的线程的访问都回退到常规&lt;code&gt;ThreadLocal&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;上面这段描述来自&lt;code&gt;FastThreadLocal&lt;/code&gt;源码中的文档，从中可以知道&lt;code&gt;FastThreadLocal&lt;/code&gt;必须和&lt;code&gt;FastThreadLocalThread&lt;/code&gt;或其子类型一起使用才可以达到Fast的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Mybatis批量更新的一个小问题</title>
    <link href="https://jingzhouzhao.github.io/archives/e8013d2a.html"/>
    <id>https://jingzhouzhao.github.io/archives/e8013d2a.html</id>
    <published>2021-03-25T09:20:15.000Z</published>
    <updated>2021-09-27T09:24:08.112Z</updated>
    
    <content type="html"><![CDATA[<p>批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;updateBatch&quot; parameterType&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;item&quot; separator&#x3D;&quot;;&quot; index&#x3D;&quot;index&quot;&gt;</span><br><span class="line">      update test</span><br><span class="line">      &lt;set&gt;</span><br><span class="line">        status &#x3D; #&#123;item.status,jdbcType&#x3D;BIGINT&#125;,</span><br><span class="line">        amount &#x3D; #&#123;item.amount,jdbcType&#x3D;BIGINT&#125;,</span><br><span class="line">        version &#x3D; version+1,</span><br><span class="line">        gmt_modified &#x3D; now(),</span><br><span class="line">      &lt;&#x2F;set&gt;</span><br><span class="line">      &lt;where&gt;</span><br><span class="line">        id &#x3D; #&#123;item.id&#125;</span><br><span class="line">      &lt;&#x2F;where&gt;</span><br><span class="line">    &lt;&#x2F;foreach&gt;</span><br><span class="line">  &lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p>非常简单的update SQL，通过Mybatis foreach 生成多个update SQL同时执行，但是运行时一直报：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;update test</span><br><span class="line">       SET amount &#x3D; -116534270,</span><br><span class="line">        version&#39; at line 10</span><br><span class="line">; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;update test</span><br><span class="line">       SET amount &#x3D; -116534270,</span><br><span class="line">        version&#39; at line 10</span><br></pre></td></tr></table></figure><p>看到这个错误下意识的认为肯定是sql哪里写的不对有语法错误，可是检查了半天没发现问题，而且将报错的sql 通过navicat运行也可以通过。</p><p>后来查到如果批量执行语句需要将database connection url中加上如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowMultiQueries&#x3D;true</span><br></pre></td></tr></table></figure><p>完整的url例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;x.x.x.x:3306&#x2F;xxxx?allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;characterset&#x3D;utf8mb4</span><br></pre></td></tr></table></figure><p>不得不说MySQL报错信息实在是太模糊了。😓</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;批量更新的方式有很多种，例如update case when，foreach update等，今天在使用其中一种foreach update时一直报SQL语法错误，看了半天没看出哪里有问题:&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
      <category term="Mybatis" scheme="https://jingzhouzhao.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上死锁排查</title>
    <link href="https://jingzhouzhao.github.io/archives/9e47523f.html"/>
    <id>https://jingzhouzhao.github.io/archives/9e47523f.html</id>
    <published>2021-03-23T03:46:15.000Z</published>
    <updated>2021-09-27T09:26:41.058Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>最近又收到了相同的告警，可能不是偶然事件，于是开始排查。<br>首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。</p><a id="more"></a><p>于是向DBA要来了deadlock log，日志内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-03-22 16:02:01 0x7f1cfc289700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 153411874, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 8 lock struct(s), heap size 1136, 23 row lock(s), undo log entries 22</span><br><span class="line">MySQL thread id 8203444, OS thread handle 139762013996800, query id 766107488 updating</span><br><span class="line">update test</span><br><span class="line">SET status &#x3D; 4,</span><br><span class="line">version &#x3D; version+1,</span><br><span class="line">gmt_modified &#x3D; &#39;2021-03-22 16:02:01&#39; </span><br><span class="line">where  id &#x3D; 1</span><br><span class="line">and version&#x3D;14</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411874 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 153411876, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">8 lock struct(s), heap size 1136, 7 row lock(s), undo log entries 6</span><br><span class="line">MySQL thread id 8204162, OS thread handle 139762466330368, query id 766107489  updating</span><br><span class="line">update test</span><br><span class="line">         SET approval_status &#x3D; 5,</span><br><span class="line">                biz_date &#x3D; &#39;2021-02-23 00:00:00&#39;,</span><br><span class="line">                modified_id &#x3D; 123,</span><br><span class="line">                modified_name &#x3D; &#39;xxx&#39;,</span><br><span class="line">                contact_company_id &#x3D; 456,</span><br><span class="line">                contact_company_n</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411876 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 40 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96; trx id 153411876 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 28 PHYSICAL RECORD: n_fields 45; compact format; info bits 0</span><br></pre></td></tr></table></figure><p>上面日志只保留了关键部分，表名等也进行了脱敏。<br>可以看到两个事务都在等待PRIMARY也就是主键索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 639 page no 2931 n bits 128 index PRIMARY of table &#96;test&#96;</span><br></pre></td></tr></table></figure><p>然后再结合日志中的SQL和代码，发现问题的原因如下:</p><p>一共涉及3个系统，分别是S、C、F，在S系统中有一个业务操作完成后会给C，F发消息，C收到S的消息处理完成后也会给F发一个消息，如图所示:</p><p><img src="https://i.loli.net/2021/03/23/cqBePdigLzNIUhF.png" alt="9b1b7abc8bdf0a3113e751fce4700924.png"></p><p>在F中几乎同时开启了两个事务，并且两个消息在F中涉及的记录是相同的，id分别是1，2，表为test。<br>于是出现了事务一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test set status &#x3D; 4 ...... where id&#x3D;1</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test set status &#x3D; 4 ...... where id&#x3D;2</span><br></pre></td></tr></table></figure><p>事务二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL1:</span><br><span class="line">update test SET approval_status &#x3D; 5 ...... where id &#x3D;2</span><br><span class="line"></span><br><span class="line">SQL2:</span><br><span class="line">update test SET approval_status &#x3D; 5 ...... where id &#x3D;1</span><br></pre></td></tr></table></figure><p>事务一先持有id=1的锁，事务二持有id=2的锁，事务一尝试获取id=2的锁，事务二尝试获取id=1的锁，所以死锁了。最后MySQL回滚了事务二。</p><p>发生这种情况是由于产品和系统设计不合理导致的，目前正在重构中。</p><p>如果下次再发生死锁直接看deadlock log吧，没必要浪费时间翻代码看业务日志了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间偶尔会收到线上MySQL死锁告警通知，由于有补偿机制，最终业务会处理成功，所以没太关心。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最近又收到了相同的告警，可能不是偶然事件，于是开始排查。&lt;br&gt;首先翻看了日志，结合代码，没有发现什么问题。事发时应该也没有什么大批量并发事件。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://jingzhouzhao.github.io/tags/MySQL/"/>
    
      <category term="Deadlock" scheme="https://jingzhouzhao.github.io/tags/Deadlock/"/>
    
  </entry>
  
  <entry>
    <title>关闭代码块移动</title>
    <link href="https://jingzhouzhao.github.io/archives/7f244d3f.html"/>
    <id>https://jingzhouzhao.github.io/archives/7f244d3f.html</id>
    <published>2020-08-25T07:22:10.000Z</published>
    <updated>2020-08-25T07:26:32.886Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Editor –&gt; General -&gt; Enable Drag’n’Drop functionality in Editor</span><br></pre></td></tr></table></figure><p>关闭即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac 开启了三指拖拽，发现在IDEA的某些Project中，选中代码块时，老是拖动代码。解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>利用mybatis标签替换硬编码</title>
    <link href="https://jingzhouzhao.github.io/archives/ad1a887a.html"/>
    <id>https://jingzhouzhao.github.io/archives/ad1a887a.html</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-13T03:39:22.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>利用mybatis标签替换硬编码</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中偶尔看到这样的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"querySqlString"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       1=1</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"fundsOrderIdList != null and fundsOrderIdList.size()&gt;0"</span>&gt;</span></span><br><span class="line">           and funds_order_id IN</span><br><span class="line">           <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"fundsOrderIdList"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">               #&#123;id&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码中有个<code>1=1</code>很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。</p><a id="more"></a><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>在很久以前，充满智慧的程序员为了解决动态条件拼接的问题，发明了<code>1=1</code>这个写法，对应的还有<code>1=0</code>的写法，我们来看看这个写法在以前是怎么解决问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">"select * from car_table where 1=1"</span></span><br><span class="line"><span class="keyword">for</span>(Condtion condition:conditions)&#123;</span><br><span class="line">    <span class="comment">/**假如没有1=1，第一个条件直接拼接上and语法就错误了</span></span><br><span class="line"><span class="comment">    *还得做出额外判断才行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sql = sql + <span class="string">" and "</span> + condition.field + <span class="string">" = "</span> + condition.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实很巧妙，而且也没有性能问题，不信我给你举个🌰:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> channel_code = <span class="string">'50008'</span>;</span><br></pre></td></tr></table></figure><p>这是一条很简单的SQL，其中就有<code>1=1</code>的写法，我们来看看MySQL查询优化器优化后实际执行的SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pay_channel_with_bank <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> channel_code = <span class="string">'50008'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>;</span><br><span class="line">实际执行的SQL:</span><br><span class="line"><span class="comment">/* select#1 */</span> <span class="keyword">select</span> 此处省略很多<span class="keyword">column</span> <span class="keyword">from</span> <span class="string">`online_paychannel`</span>.<span class="string">`pay_channel_with_bank`</span> <span class="keyword">where</span> (<span class="string">`online_paychannel`</span>.<span class="string">`pay_channel_with_bank`</span>.<span class="string">`channel_code`</span> = <span class="number">50008</span>)</span><br></pre></td></tr></table></figure><p>可以看到<code>1=1</code>已经被优化掉了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然这种写法没啥大问题，但是代码是给人看的。如果不了解这种写法，乍一眼看过去肯定有点懵。</p><p>而且我们现在使用的Mybatis提供的<code>&lt;where&gt;</code>标签本身就会帮我们做优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPrefix</span><span class="params">(StringBuilder sql, String trimmedUppercaseSql)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!prefixApplied) &#123;</span><br><span class="line">        prefixApplied = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefixesToOverride != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">            <span class="comment">//此处会移除一些前缀  </span></span><br><span class="line">            <span class="keyword">if</span> (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">              sql.delete(<span class="number">0</span>, toRemove.trim().length());</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sql.insert(<span class="number">0</span>, <span class="string">" "</span>);</span><br><span class="line">          sql.insert(<span class="number">0</span>, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>WhereSqlNode</code>中定义的<code>prefixesToOverride</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">"AND "</span>,<span class="string">"OR "</span>,<span class="string">"AND\n"</span>, <span class="string">"OR\n"</span>, <span class="string">"AND\r"</span>, <span class="string">"OR\r"</span>, <span class="string">"AND\t"</span>, <span class="string">"OR\t"</span>);</span><br></pre></td></tr></table></figure><p>所以使用了<code>&lt;where&gt;</code>标签后可以放心大胆的去掉<code>1=1</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建议&quot;&gt;&lt;a href=&quot;#建议&quot; class=&quot;headerlink&quot; title=&quot;建议&quot;&gt;&lt;/a&gt;建议&lt;/h2&gt;&lt;p&gt;利用mybatis标签替换硬编码&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目中偶尔看到这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sql&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;querySqlString&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;where&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       1=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fundsOrderIdList != null and fundsOrderIdList.size()&amp;gt;0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           and funds_order_id IN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;collection&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;fundsOrderIdList&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;item&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;index&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;open&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;(&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;close&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;separator&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               #&amp;#123;id&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;foreach&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;if&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码中有个&lt;code&gt;1=1&lt;/code&gt;很扎眼，这个不是bug，也没有什么性能问题，只是程序员世代传承下来的一个习惯。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>命令收藏</title>
    <link href="https://jingzhouzhao.github.io/archives/afa41a9c.html"/>
    <id>https://jingzhouzhao.github.io/archives/afa41a9c.html</id>
    <published>2020-07-22T02:45:53.000Z</published>
    <updated>2021-07-05T08:55:11.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h4 id="关闭SPI-获取根目录写权限"><a href="#关闭SPI-获取根目录写权限" class="headerlink" title="关闭SPI(获取根目录写权限)"></a>关闭SPI(获取根目录写权限)</h4><ul><li>重启 <code>command+R</code> 进入恢复界面</li><li>实用工具 - 终端 输入：<code>csrutil disable</code></li><li>重启：<code>reboot</code></li><li>打开终端，挂载根目录：<code>sudo mount -uw /</code><a id="more"></a><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:9999</span><br></pre></td></tr></table></figure><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><h4 id="更新app"><a href="#更新app" class="headerlink" title="更新app"></a>更新app</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cu -a -f</span><br></pre></td></tr></table></figure><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><h4 id="保存堆快照"><a href="#保存堆快照" class="headerlink" title="保存堆快照"></a>保存堆快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h2&gt;&lt;h4 id=&quot;关闭SPI-获取根目录写权限&quot;&gt;&lt;a href=&quot;#关闭SPI-获取根目录写权限&quot; class=&quot;headerlink&quot; title=&quot;关闭SPI(获取根目录写权限)&quot;&gt;&lt;/a&gt;关闭SPI(获取根目录写权限)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;重启 &lt;code&gt;command+R&lt;/code&gt; 进入恢复界面&lt;/li&gt;
&lt;li&gt;实用工具 - 终端 输入：&lt;code&gt;csrutil disable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启：&lt;code&gt;reboot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开终端，挂载根目录：&lt;code&gt;sudo mount -uw /&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>常见集群方式</title>
    <link href="https://jingzhouzhao.github.io/archives/6a6e8ff1.html"/>
    <id>https://jingzhouzhao.github.io/archives/6a6e8ff1.html</id>
    <published>2020-06-16T05:45:53.000Z</published>
    <updated>2020-06-16T05:47:23.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从（master-slave）"><a href="#主从（master-slave）" class="headerlink" title="主从（master-slave）"></a>主从（master-slave）</h3><p>写master，同步到slave 。slave可用于读。常见mysql，redis。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>在主从的基础上，添加了master宕机时，slave自动切换为master。</p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>集群内每个节点都是分片。通过分布式一致性协议沟通。</p><p>例如redis，通过Gossip 协议，在集群内同步，各个分片的哈希槽信息。</p><p>便于重定向请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主从（master-slave）&quot;&gt;&lt;a href=&quot;#主从（master-slave）&quot; class=&quot;headerlink&quot; title=&quot;主从（master-slave）&quot;&gt;&lt;/a&gt;主从（master-slave）&lt;/h3&gt;&lt;p&gt;写master，同步到sla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ RMQ_SYS_TRANS_HALF_TOPIC 爆掉的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/cfa05355.html"/>
    <id>https://jingzhouzhao.github.io/archives/cfa05355.html</id>
    <published>2020-06-05T05:22:44.000Z</published>
    <updated>2021-04-01T02:05:00.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>SaaS项目东郭反应，项目中发的事务消息一直在<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：<img src="https://files.catbox.moe/gdp5ap.png" alt></p><p>这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了<code>TRANS_CHECK_MAXTIME_TOPIC</code>中。</p><p>不正常的是<code>REAL_TOPIC</code>变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。</p><a id="more"></a><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><h4 id="一、排查"><a href="#一、排查" class="headerlink" title="一、排查"></a>一、排查</h4><p>一开始我们以为是Producer的问题，因为得到的反馈是这个消息没有被“消费”，所以我们开始排查Producer所在的项目。发现并没有什么问题。后来我们观察到上述日志中有一个DELAY=3，结合在网上查询的<a href="http://mail-archives.apache.org/mod_mbox/rocketmq-dev/201910.mbox/%3C157129868332.7323.16435164322004213562.gitbox@gitbox.apache.org%3E" target="_blank" rel="noopener">资料</a>，认为可能是触发了RocketMQ的一个问题，就是事务消息进行了延迟发送。我们以为快接近真相了，我们开始查找Producer是否在发送事务消息时设置了DELAY参数。很快我们就失望了，Producer没有任何地方设置了DELAY参数。</p><h4 id="二、翻阅源码"><a href="#二、翻阅源码" class="headerlink" title="二、翻阅源码"></a>二、翻阅源码</h4><p>我们回头去看上面那个日志，发现<code>RECONSUME_TIME=1</code>并且<code>RETRY_TOPIC</code>也不为空，这说明这个消息肯定是被消费者消费到了，但是由于某种原因消费失败了，触发了重试。于是我们开始看RocketMQ重试相关源码。我们首先找到了DELAY=3这个参数的来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的消费者中设置了ConsumeConcurrentlyContext 延时级别</span></span><br><span class="line">context.setDelayLevelWhenNextConsume(getDelayLevelWhenNextConsume(reconsumeTimes));</span><br><span class="line"><span class="comment">//可以看到这个delayLevel最终是会被发送到broker</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wrap topic with namespace before sending back message.</span></span><br><span class="line">  msg.setTopic(<span class="keyword">this</span>.defaultMQPushConsumer.withNamespace(msg.getTopic()));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"sendMessageBack exception, group: "</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">" msg: "</span> + msg.toString(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找到对应broker版本(4.6.0)的源码一步步找到了这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.CommitLog#putMessage</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line"><span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">    || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">  <span class="comment">// Delay Delivery</span></span><br><span class="line">  <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">      msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">    queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">    msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">    msg.setTopic(topic);</span><br><span class="line">    msg.setQueueId(queueId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对照之前日志里的参数，<code>sysFlag=8,delay=3</code>，我们认为很可能走了这段逻辑，然后触发了事务消息进行了延迟发送的问题。继续看了延时消息发送的逻辑，没有找到问题，而且这也解释不了为什么<code>REAL_TOPIC</code>变成了``RMQ_SYS_TRANS_HALF_TOPIC`</p><h4 id="三、真相"><a href="#三、真相" class="headerlink" title="三、真相"></a>三、真相</h4><p>上面还提到了一个<code>RETRY_TOPIC</code>，这个在之前的排查过程中没有发现有什么地方设置，于是我们搜索了一把，发现在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#sendMessageBack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(MessageExt msg, <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String brokerAddr = (<span class="keyword">null</span> != brokerName) ? <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</span><br><span class="line">            : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class="number">5000</span>, getMaxReconsumeTimes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"sendMessageBack Exception, "</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</span><br><span class="line"></span><br><span class="line">        Message newMsg = <span class="keyword">new</span> Message(MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span><br><span class="line"></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msg);</span><br><span class="line">        MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">        newMsg.setFlag(msg.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(newMsg, msg.getProperties());</span><br><span class="line">       <span class="comment">//这里设置了RETRY_TOPIC</span></span><br><span class="line">        MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span><br><span class="line">        MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class="number">1</span>));</span><br><span class="line">        MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span><br><span class="line">       </span><br><span class="line">        newMsg.setDelayTimeLevel(<span class="number">3</span> + msg.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="keyword">this</span>.defaultMQPushConsumer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显是个异常流程，那么到底是什么导致了这个异常流程呢？既然知道是在消费的时候出了异常，于是我们找到对应的消费者日志，发现如下错误：</p><p><img src="https://files.catbox.moe/42fapz.png" alt></p><p>这里Broker返回的错误是<code>MESSAGE_ILIEGAL</code>，在回过头去看重试相关代码，有了之前的经验这次很快就定位到了可能报这个错误的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一处：org.apache.rocketmq.store.DefaultMessageStore#putMessage </span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line"> log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//第二处：org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend(long, java.nio.ByteBuffer, int, org.apache.rocketmq.store.MessageExtBrokerInner)</span></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">  log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br></pre></td></tr></table></figure><p>果断找运维要了<code>store.log</code>，发现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN SendMessageThread_1 - putMessage message topic length too long 149</span><br></pre></td></tr></table></figure><p>所以应该就是第一处的问题了。至此问题的原因基本找到了，但还有以下问题：</p><ol><li><p>为什么TOPIC会超长？</p><p>重试的消息TOPIC规则为%RETRY%+consumerGroup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup())</span><br></pre></td></tr></table></figure><p>而我们的consumerGroup的规则为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group + <span class="string">"_"</span> + getTopic() + <span class="string">"_"</span> + getTags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题的consumer的tags为：<code>SAAS_PURCHASE_PURCHASE_ORDER_UPDATE||SAAS_PURCHASE_PURCHASE_ORDER_OPEN_RECEVIED||SAAS_PURCHASE_PURCHASE_ORDER_COMPLETED_RECEVIED</code></p><p>所以最终拼出来的TOPIC超出了长度。</p></li><li><p>为什么走了Catch里面的流程就会导致HALF队列爆掉？</p><p>这是由于我们使用的RocketMQ-client版本为<code>4.5.0</code>，这个版本Catch里的代码有个bug，没有清除掉原始消息的事务消息标志<code>TRANS_MSG=true</code>。所以这个消息发出去后在broker端又会走事务消息的流程，并且还是带延时的。这会导致真实的TOPIC丢掉。</p><p>下面用一张图来说明一下：</p><p><img src="https://files.catbox.moe/ssraef.png" alt></p><p>事务消息消费失败，topic转为<code>%RETRY%xxxx</code>发送到broker，由于事务消息标志没有被清除，于是topic转成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。又由于delay参数没有被清除，topic最后被转为了<code>schedule_topic_xxxx</code>。等到schedule执行时，消息会发到<code>RMQ_SYS_TRANS_HALF_TOPIC</code>中。由于不是Producer发的事务消息，所以拿不到LocalTransactionState。只能等待事务消息回查。</p><p>这时刚好又碰到我们的LocalTransactionListener的一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">  Object msg = HessianUtils.decode(messageExt.getBody());</span><br><span class="line">  String topic = messageExt.getTopic();</span><br><span class="line">  String tag = messageExt.getTags();</span><br><span class="line">  <span class="comment">//由于拿着rmq_sys_trans_half_topic来获取handler所以肯定获取不到。</span></span><br><span class="line">  LocalTransactionHandler localTransacationHandler = getLocalTransacationHandler(topic, tag);</span><br><span class="line"></span><br><span class="line">  String msgId = messageExt.getMsgId();</span><br><span class="line">  <span class="keyword">if</span>( localTransacationHandler == <span class="keyword">null</span> )&#123;</span><br><span class="line">    logger.error(<span class="string">"localTransacationHandler is empty should never happened! msgId=&#123;&#125;, arg=&#123;&#125;"</span>, msgId, JSON.toJSONString(msg));</span><br><span class="line">    <span class="comment">//于是这个地方会返回COMMIT_MESSAGE</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> checkResult = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkResult = localTransacationHandler.localTransactionCheck(msgId, msg);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">"localTransacationCheck failed! msgId=&#123;&#125;, arg=&#123;&#125;"</span>, msgId, JSON.toJSONString(msg), e);</span><br><span class="line">    checkResult = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> checkResult ? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broker收到<code>COMMIT_MESSAGE</code>后会将消息写往REAL_TOPIC中。而此时REAL_TOPIC早已变成了<code>RMQ_SYS_TRANS_HALF_TOPIC</code>。就这样，<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉了。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>首先我们将handler为空时返回<code>COMMIT_MESSAGE</code>，改为了<code>ROLLBACK_MESSAGE</code>。</p></li><li><p>升级stone中RocketMQ为4.6.1，可以看到在Catch代码中多了一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageAccessor.clearProperty(newMsg, &quot;TRAN_MSG&quot;);</span><br></pre></td></tr></table></figure></li><li><p>有问题的consumer将tag拆分</p><p>第一步和第二步只能解决<code>RMQ_SYS_TRANS_HALF_TOPIC</code>爆掉的问题。但是topic超长还是会有问题。所以目前暂时是将consumer的tag拆开。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;SaaS项目东郭反应，项目中发的事务消息一直在&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;中，并且不断增长。随即我们查看RocketMQ日志发现如下情况：&lt;img src=&quot;https://files.catbox.moe/gdp5ap.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个本来是RocketMQ正常的逻辑，发送事务消息后没有提交状态的话，当达到超时时间后，RocketMQ会回查本地事务状态。这里显示的是回查的次数超限，消息被移到了&lt;code&gt;TRANS_CHECK_MAXTIME_TOPIC&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;不正常的是&lt;code&gt;REAL_TOPIC&lt;/code&gt;变成了&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;，正常应该是原始的业务消息TOPIC才对。于是我们带着这个问题开始排查起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
      <category term="RocketMQ" scheme="https://jingzhouzhao.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>读取Jar中指定目录下的所有文件</title>
    <link href="https://jingzhouzhao.github.io/archives/f728629b.html"/>
    <id>https://jingzhouzhao.github.io/archives/f728629b.html</id>
    <published>2020-03-19T03:47:54.000Z</published>
    <updated>2020-03-19T05:46:01.558Z</updated>
    
    <content type="html"><![CDATA[<p>读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。</p><a id="more"></a><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>首先要读取Jar中的目录下的文件，得先搞清楚Jar中的目录结构，例如常见的SpringBoot打包后的Jar中目录如下：</p><p><img src="/archives/f728629b/1.png" alt="1"></p><p>假如我们要读取的目录是<code>BOOT-INF/classes/processes</code>（对应源文件目录是<code>resources/processes</code>）</p><p><img src="/archives/f728629b/2.png" alt="2"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前Jar文件路径</span></span><br><span class="line">URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">""</span>);</span><br><span class="line">    String jarPath = url.toString().substring(<span class="number">0</span>, url.toString().indexOf(<span class="string">"!/"</span>) + <span class="number">2</span>);</span><br><span class="line">    log.info(<span class="string">"jarPath:&#123;&#125;"</span>, jarPath);</span><br><span class="line">    URL jarURL = <span class="keyword">new</span> URL(jarPath);</span><br><span class="line">    JarURLConnection jarCon = (JarURLConnection) jarURL.openConnection();</span><br><span class="line">    JarFile jarFile = jarCon.getJarFile();</span><br><span class="line"><span class="comment">//获取Jar下所有文件</span></span><br><span class="line">    Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">        JarEntry jarEntry = entries.nextElement();</span><br><span class="line">      <span class="comment">//获取文件路径</span></span><br><span class="line">        String innerPath = jarEntry.getName();</span><br><span class="line">        log.info(<span class="string">"jarEntry Name:&#123;&#125;"</span>, innerPath);</span><br><span class="line">      <span class="comment">//判断是否需要处理的目录下的文件，PROCESSES=BOOT-INF/classes/processes</span></span><br><span class="line">        <span class="keyword">if</span> (innerPath.startsWith(PROCESSES) &amp;&amp; !jarEntry.isDirectory()) &#123;</span><br><span class="line">          <span class="comment">//获取到文件流</span></span><br><span class="line">            InputStream inputStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(innerPath);</span><br><span class="line">          <span class="comment">//doSomething</span></span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式优缺点：无第三方库依赖，用的都是JDK 相关API。但是只能在jar模式下运行，本地调试会出错。</p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>如果有使用到Spring，那么不管是打成Jar运行还是本地运行，获取指定目录中的文件就很简单了。主要是利用了Spring 的<code>ResourcePatternResolver</code>，详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    List&lt;Resource&gt; resourceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = Arrays.asLIst("**.bpmn20.xml","**.bpmn")</span></span><br><span class="line">    <span class="keyword">for</span> (String suffix : PROCESS_DEFINITION_LOCATION_SUFFIXES) &#123;</span><br><span class="line">      <span class="comment">//PROCESS_DEFINITION_LOCATION_SUFFIXES = classpath://processes/</span></span><br><span class="line">        <span class="comment">//拼接路径pattern</span></span><br><span class="line">        String path = PROCESS_DEFINITION_LOCATION_PREFIX + suffix;</span><br><span class="line">      <span class="comment">//通过ResourcePatternResolver获取资源文件,</span></span><br><span class="line">        <span class="comment">//resourceLoader = @Autowired ResourcePatternResolver resourceLoader</span></span><br><span class="line">        Resource[] resources = resourceLoader.getResources(path);</span><br><span class="line">        <span class="keyword">if</span> (resources != <span class="keyword">null</span> &amp;&amp; resources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            resourceList.addAll(Arrays.asList(resources));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过resource.getInputStream()即可获取文件流</span></span><br><span class="line"><span class="comment">//doSomething</span></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>此方式优缺点，依赖了Spring框架，但是对运行环境没有要求。</p><p>总结：</p><p>推荐使用第二种方式，毕竟现在基本上都会使用到Spring。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读取Jar中文件使用类似getResourceAsStream等以流的方式获取即可。但是想要读取Jar中某个目录下的所有文件却不是那么容易。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>tk.mybatis与Activiti共存问题解决</title>
    <link href="https://jingzhouzhao.github.io/archives/7008e148.html"/>
    <id>https://jingzhouzhao.github.io/archives/7008e148.html</id>
    <published>2020-03-05T12:53:07.000Z</published>
    <updated>2020-03-05T13:03:39.084Z</updated>
    
    <content type="html"><![CDATA[<p>由于tk.mybatis依赖了persistence-api，会让Activiti装配JpaProcessEngineAutoConfiguration，因为其@conditonalOnclass(name = “javax.persistence.EntityManagerFactory”)。</p><p>但实际没有使用JPA，导致启动报错。如果排除persistence-api，又会导致tk.mybatis报错。</p><p>参考了一番其它的人做法，无论是各种排除还是添加依赖都无效。</p><p>最终自己的解决方案是：</p><p>首先排除activiti jpa的自动装配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude&#x3D;&#123;JpaProcessEngineAutoConfiguration.class&#125;)。</span><br></pre></td></tr></table></figure><p>然后找到activiti中的<code>DataSourceProcessEngineAutoConfiguration.class</code> 复制出源码，在自己的项目中添加一个同名文件（不同名也行）。然后粘贴内容到新建的文件中。最后删掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnMissionClass(name &#x3D; &quot;javax.persistence.EntityManagerFactory&quot;)</span><br></pre></td></tr></table></figure><p>Ok,搞定！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于tk.mybatis依赖了persistence-api，会让Activiti装配JpaProcessEngineAutoConfiguration，因为其@conditonalOnclass(name = “javax.persistence.EntityManage
      
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Activiti" scheme="https://jingzhouzhao.github.io/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>被隔离的第7天</title>
    <link href="https://jingzhouzhao.github.io/archives/3eda1a9.html"/>
    <id>https://jingzhouzhao.github.io/archives/3eda1a9.html</id>
    <published>2020-03-03T05:22:11.000Z</published>
    <updated>2020-03-03T05:28:00.747Z</updated>
    
    <content type="html"><![CDATA[<p>被隔离的第7天，每天接到无数个部门的电话，量体温，报情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;被隔离的第7天，每天接到无数个部门的电话，量体温，报情况。&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://jingzhouzhao.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>更换电脑后hexo deploy访问出现404的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/32745de6.html"/>
    <id>https://jingzhouzhao.github.io/archives/32745de6.html</id>
    <published>2019-10-16T10:49:53.000Z</published>
    <updated>2019-10-16T11:14:24.615Z</updated>
    
    <content type="html"><![CDATA[<p>更换电脑后重新拉下hexo相关sources，安装完成hexo-cli以及hexo-deployer-git和其他node_modules。</p><p>执行hexo clean &amp;&amp; hexo g </p><p>然后执行hexo d。</p><a id="more"></a><p>完成后发现访问出现404，提示<strong>There isn’t a GitHub Pages site here.</strong></p><p>并且github发了大量警告邮件，有得没得，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are attempting to use a Jekyll theme, &quot;icarus&quot;, which is not supported by GitHub Pages.</span><br></pre></td></tr></table></figure><p>定位问题：</p><ol><li>查看github pages对应repository，发现里面的文件完全不正确，不是hexo g生成的文件。而变成了博客对应的源文件。</li><li>查看文件是否正确生成，public目录下正确生成。</li><li>通过上面两个步骤，说明问题出在deploy。</li></ol><p>解决问题：</p><p>删除<code>.deploy_git</code>，重新<code>hexo d</code>，一切恢复正常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更换电脑后重新拉下hexo相关sources，安装完成hexo-cli以及hexo-deployer-git和其他node_modules。&lt;/p&gt;
&lt;p&gt;执行hexo clean &amp;amp;&amp;amp; hexo g &lt;/p&gt;
&lt;p&gt;然后执行hexo d。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑记录" scheme="https://jingzhouzhao.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>PriorityQueue解析</title>
    <link href="https://jingzhouzhao.github.io/archives/f50feeee.html"/>
    <id>https://jingzhouzhao.github.io/archives/f50feeee.html</id>
    <published>2019-10-10T02:13:00.000Z</published>
    <updated>2019-10-16T09:05:40.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载至github：<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md</a></p></blockquote><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><a id="more"></a><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p><code>leftNo = parentNo*2+1</code></p><p><code>rightNo = parentNo*2+2</code></p><p><code>parentNo = (nodeNo-1)/2</code></p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftUp()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></p><p>代码也就非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftDown()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    <span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载至github：&lt;a href=&quot;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PriorityQueue&quot;&gt;&lt;a href=&quot;#PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue&quot;&gt;&lt;/a&gt;PriorityQueue&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerlink&quot; title=&quot;总体介绍&quot;&gt;&lt;/a&gt;总体介绍&lt;/h1&gt;&lt;p&gt;前面以Java &lt;em&gt;ArrayDeque&lt;/em&gt;为例讲解了&lt;em&gt;Stack&lt;/em&gt;和&lt;em&gt;Queue&lt;/em&gt;，其实还有一种特殊的队列叫做&lt;em&gt;PriorityQueue&lt;/em&gt;，即优先队列。&lt;strong&gt;优先队列的作用是能保证每次取出的元素都是队列中权值最小的&lt;/strong&gt;（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，&lt;strong&gt;元素大小的评判可以通过元素本身的自然顺序（&lt;em&gt;natural ordering&lt;/em&gt;），也可以通过构造时传入的比较器&lt;/strong&gt;（&lt;em&gt;Comparator&lt;/em&gt;，类似于C++的仿函数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随记" scheme="https://jingzhouzhao.github.io/categories/Java%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://jingzhouzhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker-alpine镜像导致的问题</title>
    <link href="https://jingzhouzhao.github.io/archives/f3674cca.html"/>
    <id>https://jingzhouzhao.github.io/archives/f3674cca.html</id>
    <published>2019-09-26T05:04:26.000Z</published>
    <updated>2019-10-16T09:05:40.003Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。</p><a id="more"></a><p>通过查找日志发现以下异常堆栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: <span class="keyword">null</span></span><br><span class="line">        at sun.awt.X11FontManager.getDefaultPlatformFont(X11FontManager.java:<span class="number">779</span>)</span><br><span class="line">        at sun.font.SunFontManager$<span class="number">2</span>.run(SunFontManager.java:<span class="number">433</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:<span class="number">376</span>)</span><br><span class="line">        at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:<span class="number">32</span>)</span><br><span class="line">        at sun.reflect.GeneratedConstructorAccessor62.newInstance(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">        at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">526</span>)</span><br><span class="line">        at java.lang.Class.newInstance(Class.java:<span class="number">383</span>)</span><br><span class="line">        at sun.font.FontManagerFactory$<span class="number">1</span>.run(FontManagerFactory.java:<span class="number">83</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:<span class="number">74</span>)</span><br><span class="line">        at java.awt.Font.getFont2D(Font.java:<span class="number">490</span>)</span><br><span class="line">        at java.awt.Font.access$<span class="number">000</span>(Font.java:<span class="number">224</span>)</span><br><span class="line">        at java.awt.Font$FontAccessImpl.getFont2D(Font.java:<span class="number">228</span>)</span><br><span class="line">        at sun.font.FontUtilities.getFont2D(FontUtilities.java:<span class="number">180</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:<span class="number">645</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:<span class="number">806</span>)</span><br><span class="line">        at sun.java2d.pipe.GlyphListPipe.drawString(GlyphListPipe.java:<span class="number">50</span>)</span><br><span class="line">        at sun.java2d.SunGraphics2D.drawString(SunGraphics2D.java:<span class="number">2887</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>结合源码发现，应该是无法获取到字体导致的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graphics.setFont(new Font(&quot;Default&quot;, Font.PLAIN, fsize));</span><br></pre></td></tr></table></figure><p>由于代码没有做出过变更，所以毫无疑问，应该是环境的问题了。</p><p>于是我进入Dokcer容器查看相关字体：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it containerId bash</span><br><span class="line">fc-list</span><br></pre></td></tr></table></figure><p>发现无任何内容输出。经过一番查找，解决办法如下：</p><ol><li><p>进入容器安装字体（只能临时解决，当重新构建后，字体会丢失）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>修改Dockerfile 在构建镜像时安装字体（会影响构建速度，安装字体比较慢）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li><li><p>更改基础镜像（推荐）</p><p>我这边出问题的容器是基于<code>tomcat:8.0-jre7-alpine</code>构建的，alpine tag的镜像比较小，比较干净。</p><p>我到docker hub上找到了类似的镜像，<code>slim</code> tag的。</p><p>修改Dockerfile，将<code>FROM tomcat:8.0-jre7-alpine</code> 改为 <code>FROM tomcat:8.0-jre7-slim</code>即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间接到一个需求，将现有的一个项目容器化部署。经过一段时间的折腾，总算成功的跑起来了。但是最近发现一个问题：图形验证码没法显示了。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker随记" scheme="https://jingzhouzhao.github.io/categories/Docker%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://jingzhouzhao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>为什么苹果不自己制造芯片</title>
    <link href="https://jingzhouzhao.github.io/archives/52360944.html"/>
    <id>https://jingzhouzhao.github.io/archives/52360944.html</id>
    <published>2019-09-20T02:01:43.000Z</published>
    <updated>2019-10-16T09:05:40.010Z</updated>
    
    <content type="html"><![CDATA[<p>苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？</p><a id="more"></a><p>原来业内习惯把半导体行业的公司分为三类：</p><p>fabless（无晶圆芯片设计厂）：这样的公司只设计芯片，不自己制造芯片。最大的fabless企业有高通、博通、AMD、联发科、搭上人工智能这波热点最近火的不行的Nvidia等等。国内的fabless企业有收购了展讯和锐迪科的清华紫光、华为海思等。<br>Foundry（代工厂）：这样的公司专门为别人制造芯片。最大的Foundry企业有台积电（TSMC）、GlobalFoundry、UMC等。国内最大的是中芯国际。随着工艺进步到20nm以下，从平面晶体管向三维FinFET演化，新一代工艺所需要的投资越来越大，已经只有少数几个玩家能玩得起了（台积电、三星、Intel）。国内的中芯国际跟台积电有几代的差距。中芯国际目前商用的最先进工艺是28nm，台积电16nm已经大规模商用，7nm也马上就要用起来。<br>IDM（制造垂直整合）：这样的公司既设计芯片，也自己制造芯片。最大的有Intel和三星。</p><p>这样做的好处是，分担风险，苹果不用花费巨大投资建立生产线，因此轻资产，灵活性高，可以对市场快速反应，活力足。</p><p>再说另外一个问题，为什么主流的手机处理器厂商中很少见到英特尔呢？<br>首先提一下CPU的简单构成：ALU（算术逻辑单元）、控制单元、寄存器<br>控制单元通过时钟控制着指令执行的节奏，将指令加载存放在寄存器、并通过ALU计算。<br>这里提到了指令，指令基本上分为两类：RISC（精简指令集） 、CISC （复杂指令集），指令越复杂意味着能耗越高，试想一下，在目前手机电池技术还未突破的情况下，手机CPU会上CISC吗？<br>上面说的两个指令集的典型代表就是ARM和x86，ARM是目前主流的手机CPU架构，也就是精简指令。而x86才是英特尔等厂商的强项。<br>也许是英特尔出于战略考虑放弃了移动处理器这块蛋糕，或者说英特尔没有意料到这块蛋糕这么大。不过，目前App背后对应的还是各种Server，Server离不开x86。</p><p>参考资料：<br><a href="https://www.zhihu.com/question/68283951/answer/262481048" target="_blank" rel="noopener">https://www.zhihu.com/question/68283951/answer/262481048</a><br><a href="https://www.zhihu.com/question/20148756" target="_blank" rel="noopener">https://www.zhihu.com/question/20148756</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果近期发布了最新的处理器Apple A13 Bionic，由台积电代工。为什么苹果不自己制造设计出来的芯片呢？&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://jingzhouzhao.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
